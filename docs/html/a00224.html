<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CryptoAuthLib: Basic Crypto API methods (atcab_)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CryptoAuthLib
   </div>
   <div id="projectbrief">Atmel CryptoAuthentication Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00224.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Basic Crypto API methods (atcab_)</div>  </div>
</div><!--header-->
<div class="contents">

<p>These methods provide the most convenient, simple API to CryptoAuth chips.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">atca_sha256_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga530ccce9f617be7dbf3661e19a4c0546"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a00028.html">atca_sha256_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a></td></tr>
<tr class="separator:ga530ccce9f617be7dbf3661e19a4c0546"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga563f3d7c25ee88ff5b2c988f4eb59bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga563f3d7c25ee88ff5b2c988f4eb59bc3">atcab_version</a> (char *verstr)</td></tr>
<tr class="memdesc:ga563f3d7c25ee88ff5b2c988f4eb59bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a version string for the CryptoAuthLib release. The format of the version string returned is "yyyymmdd"  <a href="#ga563f3d7c25ee88ff5b2c988f4eb59bc3">More...</a><br /></td></tr>
<tr class="separator:ga563f3d7c25ee88ff5b2c988f4eb59bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gacdc4fa3d2f2f6d197af8c10ab1f288b8">atcab_init</a> (<a class="el" href="a00046.html">ATCAIfaceCfg</a> *cfg)</td></tr>
<tr class="memdesc:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">atcab_init is called once for the life of the application and creates a global ATCADevice object used by Basic API. This method builds a global ATCADevice instance behinds the scenes that's used for all Basic API operations  <a href="#gacdc4fa3d2f2f6d197af8c10ab1f288b8">More...</a><br /></td></tr>
<tr class="separator:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb5f2d8f7796c6d7e93d36a86dc3ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga1cb5f2d8f7796c6d7e93d36a86dc3ce9">atcab_init_device</a> (<a class="el" href="a00221.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> cadevice)</td></tr>
<tr class="memdesc:ga1cb5f2d8f7796c6d7e93d36a86dc3ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">atcab_init_device can be used to initialize the global ATCADevice object to point to one of your choosing for use with all the atcab_ basic API.  <a href="#ga1cb5f2d8f7796c6d7e93d36a86dc3ce9">More...</a><br /></td></tr>
<tr class="separator:ga1cb5f2d8f7796c6d7e93d36a86dc3ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga3a061c1f96bb641b36fc56b6cb2dd4e4">atcab_release</a> (void)</td></tr>
<tr class="memdesc:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">release (free) the global ATCADevice instance. This must be called in order to release or free up the interface.  <a href="#ga3a061c1f96bb641b36fc56b6cb2dd4e4">More...</a><br /></td></tr>
<tr class="separator:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00221.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga4af82005556c549c30e1c4bd35d4f4e4">atcab_get_device</a> (void)</td></tr>
<tr class="memdesc:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a way to get the global device object. Generally for more sophisticated users of atca  <a href="#ga4af82005556c549c30e1c4bd35d4f4e4">More...</a><br /></td></tr>
<tr class="separator:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3bc620aedd9322d160eece0d8d20c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gad3bc620aedd9322d160eece0d8d20c82">atcab_wakeup</a> (void)</td></tr>
<tr class="memdesc:gad3bc620aedd9322d160eece0d8d20c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">wakeup the CryptoAuth device  <a href="#gad3bc620aedd9322d160eece0d8d20c82">More...</a><br /></td></tr>
<tr class="separator:gad3bc620aedd9322d160eece0d8d20c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaf47433a371b9fcb8d65a4214cd9e4fa0">atcab_idle</a> (void)</td></tr>
<tr class="memdesc:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">idle the CryptoAuth device  <a href="#gaf47433a371b9fcb8d65a4214cd9e4fa0">More...</a><br /></td></tr>
<tr class="separator:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9475e032c388144c5a0df45d1df182a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga9475e032c388144c5a0df45d1df182a5">atcab_sleep</a> (void)</td></tr>
<tr class="memdesc:ga9475e032c388144c5a0df45d1df182a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke sleep on the CryptoAuth device  <a href="#ga9475e032c388144c5a0df45d1df182a5">More...</a><br /></td></tr>
<tr class="separator:ga9475e032c388144c5a0df45d1df182a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed2c204c79b094e064385c85f3c1b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gabed2c204c79b094e064385c85f3c1b3d">atcab_cfg_discover</a> (<a class="el" href="a00046.html">ATCAIfaceCfg</a> cfgArray[], int <a class="el" href="a00226.html#gaf13cc0c18a825fdc030b007656b14d0b">max</a>)</td></tr>
<tr class="separator:gabed2c204c79b094e064385c85f3c1b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e19ecd60be4c74665d9ec142e460771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga6e19ecd60be4c74665d9ec142e460771">atcab_info</a> (uint8_t *revision)</td></tr>
<tr class="memdesc:ga6e19ecd60be4c74665d9ec142e460771"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the device revision information  <a href="#ga6e19ecd60be4c74665d9ec142e460771">More...</a><br /></td></tr>
<tr class="separator:ga6e19ecd60be4c74665d9ec142e460771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b13f56c701eb5564e555923a621ae85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga8b13f56c701eb5564e555923a621ae85">atcab_challenge</a> (const uint8_t *challenge)</td></tr>
<tr class="memdesc:ga8b13f56c701eb5564e555923a621ae85"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a challenge to the device (a pass-through nonce)  <a href="#ga8b13f56c701eb5564e555923a621ae85">More...</a><br /></td></tr>
<tr class="separator:ga8b13f56c701eb5564e555923a621ae85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc5691ab3a484d7a07cbbc214e6a8f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga4fc5691ab3a484d7a07cbbc214e6a8f5">atcab_challenge_seed_update</a> (const uint8_t *seed, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga4fc5691ab3a484d7a07cbbc214e6a8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a challenge to the device (a seed update nonce)  <a href="#ga4fc5691ab3a484d7a07cbbc214e6a8f5">More...</a><br /></td></tr>
<tr class="separator:ga4fc5691ab3a484d7a07cbbc214e6a8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff392b11a0d00fefa2dff30ec7040fc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaff392b11a0d00fefa2dff30ec7040fc6">atcab_nonce_base</a> (uint8_t mode, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaff392b11a0d00fefa2dff30ec7040fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Nonce command generates a nonce for use by subsequent commands.  <a href="#gaff392b11a0d00fefa2dff30ec7040fc6">More...</a><br /></td></tr>
<tr class="separator:gaff392b11a0d00fefa2dff30ec7040fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10c899d3b8cfb1b9ada47f925b8cbce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gab10c899d3b8cfb1b9ada47f925b8cbce">atcab_nonce</a> (const uint8_t *tempkey)</td></tr>
<tr class="memdesc:gab10c899d3b8cfb1b9ada47f925b8cbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a pass-through Nonce command to initialize TempKey to the specified value.  <a href="#gab10c899d3b8cfb1b9ada47f925b8cbce">More...</a><br /></td></tr>
<tr class="separator:gab10c899d3b8cfb1b9ada47f925b8cbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf162c6327e0cc2e43fc6b483dbc21a32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaf162c6327e0cc2e43fc6b483dbc21a32">atcab_nonce_rand</a> (const uint8_t *seed, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaf162c6327e0cc2e43fc6b483dbc21a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize TempKey with a random Nonce.  <a href="#gaf162c6327e0cc2e43fc6b483dbc21a32">More...</a><br /></td></tr>
<tr class="separator:gaf162c6327e0cc2e43fc6b483dbc21a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa442396dfbb89e59dfca837b565cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga4fa442396dfbb89e59dfca837b565cec">atcab_random</a> (uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga4fa442396dfbb89e59dfca837b565cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a 32 byte random number from the CryptoAuth device.  <a href="#ga4fa442396dfbb89e59dfca837b565cec">More...</a><br /></td></tr>
<tr class="separator:ga4fa442396dfbb89e59dfca837b565cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefce484222bdbedef37787a9b10d4426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaefce484222bdbedef37787a9b10d4426">atcab_is_locked</a> (uint8_t zone, bool *is_locked)</td></tr>
<tr class="memdesc:gaefce484222bdbedef37787a9b10d4426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query to see if the specified zone is locked.  <a href="#gaefce484222bdbedef37787a9b10d4426">More...</a><br /></td></tr>
<tr class="separator:gaefce484222bdbedef37787a9b10d4426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac244d4c7a4bbb4004d30ba680c5136ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gac244d4c7a4bbb4004d30ba680c5136ad">atcab_is_slot_locked</a> (uint8_t slot, bool *is_locked)</td></tr>
<tr class="memdesc:gac244d4c7a4bbb4004d30ba680c5136ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query to see if the specified slot is locked.  <a href="#gac244d4c7a4bbb4004d30ba680c5136ad">More...</a><br /></td></tr>
<tr class="separator:gac244d4c7a4bbb4004d30ba680c5136ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gabdfeb1f8d28039e9b30d4e39b8caa33a">atcab_get_addr</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint16_t *addr)</td></tr>
<tr class="memdesc:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the address given the zone, slot, block, and offset.  <a href="#gabdfeb1f8d28039e9b30d4e39b8caa33a">More...</a><br /></td></tr>
<tr class="separator:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga7a823d2a391bf80ff336eb2ccbd37412">atcab_get_zone_size</a> (uint8_t zone, uint16_t slot, size_t *size)</td></tr>
<tr class="memdesc:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified zone in bytes.  <a href="#ga7a823d2a391bf80ff336eb2ccbd37412">More...</a><br /></td></tr>
<tr class="separator:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga3ce01f02f456c08891ca1d67cd3ed0eb">atcab_read_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">read either 4 or 32 bytes of data into given slot  <a href="#ga3ce01f02f456c08891ca1d67cd3ed0eb">More...</a><br /></td></tr>
<tr class="separator:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gabf2b29b4d3ae926b63c403d084380dbe">atcab_write</a> (uint8_t zone, uint16_t address, const uint8_t *value, const uint8_t *mac)</td></tr>
<tr class="memdesc:gabf2b29b4d3ae926b63c403d084380dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Write command writes either one four byte word or an 8-word block of 32 bytes to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys.  <a href="#gabf2b29b4d3ae926b63c403d084380dbe">More...</a><br /></td></tr>
<tr class="separator:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga1f5a6bbcf4f840803635fb8951b3a7e2">atcab_write_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write either 4 or 32 bytes of data into a device zone.  <a href="#ga1f5a6bbcf4f840803635fb8951b3a7e2">More...</a><br /></td></tr>
<tr class="separator:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac395a7e195aa3cf28b48de345755feb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gac395a7e195aa3cf28b48de345755feb0">atcab_write_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset_bytes, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gac395a7e195aa3cf28b48de345755feb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into config, otp, or data zone with a given byte offset and length. Offset and length must be multiples of a word (4 bytes).  <a href="#gac395a7e195aa3cf28b48de345755feb0">More...</a><br /></td></tr>
<tr class="separator:gac395a7e195aa3cf28b48de345755feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef5ecc82d845eaebdf50a58ac489e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gafef5ecc82d845eaebdf50a58ac489e66">atcab_read_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset_bytes, uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gafef5ecc82d845eaebdf50a58ac489e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from config, otp, or data zone with a given byte offset and length.  <a href="#gafef5ecc82d845eaebdf50a58ac489e66">More...</a><br /></td></tr>
<tr class="separator:gafef5ecc82d845eaebdf50a58ac489e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga96c434878e1f435e2cda5b0b5fec444f">atcab_read_serial_number</a> (uint8_t *serial_number)</td></tr>
<tr class="memdesc:ga96c434878e1f435e2cda5b0b5fec444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the serial number of the device  <a href="#ga96c434878e1f435e2cda5b0b5fec444f">More...</a><br /></td></tr>
<tr class="separator:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe236622ac65a2ccbf313d4a1971c258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gabe236622ac65a2ccbf313d4a1971c258">atcab_read_pubkey</a> (uint16_t slot8toF, uint8_t *pubkey)</td></tr>
<tr class="memdesc:gabe236622ac65a2ccbf313d4a1971c258"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads a pub key from a readable data slot versus atcab_get_pubkey which generates a pubkey from a private key slot  <a href="#gabe236622ac65a2ccbf313d4a1971c258">More...</a><br /></td></tr>
<tr class="separator:gabe236622ac65a2ccbf313d4a1971c258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09f2d9d7d0bfa4badfcea82b9b02f151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga09f2d9d7d0bfa4badfcea82b9b02f151">atcab_write_pubkey</a> (uint16_t slot8toF, const uint8_t *pubkey)</td></tr>
<tr class="memdesc:ga09f2d9d7d0bfa4badfcea82b9b02f151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a pub key from to a data slot.  <a href="#ga09f2d9d7d0bfa4badfcea82b9b02f151">More...</a><br /></td></tr>
<tr class="separator:ga09f2d9d7d0bfa4badfcea82b9b02f151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddea9705cb35400bf64c43f8ef3ec368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaddea9705cb35400bf64c43f8ef3ec368">atcab_read_sig</a> (uint8_t slot8toF, uint8_t *sig)</td></tr>
<tr class="memdesc:gaddea9705cb35400bf64c43f8ef3ec368"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads a signature found in one of slots 8 through F.  <a href="#gaddea9705cb35400bf64c43f8ef3ec368">More...</a><br /></td></tr>
<tr class="separator:gaddea9705cb35400bf64c43f8ef3ec368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga8ef47330eef6bc72ae8f7a8ef026dae3">atcab_read_config_zone</a> (uint8_t *config_data)</td></tr>
<tr class="memdesc:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">given an SHA configuration zone buffer and dev type, read its parts from the device's config zone  <a href="#ga8ef47330eef6bc72ae8f7a8ef026dae3">More...</a><br /></td></tr>
<tr class="separator:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0777a86aa412a97b19cc72a12c171b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga0777a86aa412a97b19cc72a12c171b94">atcab_write_config_zone</a> (const uint8_t *config_data)</td></tr>
<tr class="memdesc:ga0777a86aa412a97b19cc72a12c171b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the configuration zone skipping the lock values.  <a href="#ga0777a86aa412a97b19cc72a12c171b94">More...</a><br /></td></tr>
<tr class="separator:ga0777a86aa412a97b19cc72a12c171b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gadb91d2c3601b95f0ad413cf84a4dfd87">atcab_cmp_config_zone</a> (uint8_t *config_data, bool *same_config)</td></tr>
<tr class="memdesc:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares all writable bytes in the configuration zone that is passed in to the bytes on the device.  <a href="#gadb91d2c3601b95f0ad413cf84a4dfd87">More...</a><br /></td></tr>
<tr class="separator:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dac8b8c0a82dac68da82724129e278d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga8dac8b8c0a82dac68da82724129e278d">atcab_read_enc</a> (uint16_t key_id, uint8_t block, uint8_t *data, const uint8_t *enckey, const uint16_t enckeyid)</td></tr>
<tr class="memdesc:ga8dac8b8c0a82dac68da82724129e278d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32 bytes of data from the given slot. The function returns clear text bytes. Encrypted bytes are read over the wire, then subsequently decrypted Data zone must be locked and the slot configuration must be set to encrypted read for the block to be successfully read.  <a href="#ga8dac8b8c0a82dac68da82724129e278d">More...</a><br /></td></tr>
<tr class="separator:ga8dac8b8c0a82dac68da82724129e278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf099dc4245d056db33547fe1d49b541b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaf099dc4245d056db33547fe1d49b541b">atcab_write_enc</a> (uint16_t key_id, uint8_t block, const uint8_t *data, const uint8_t *enckey, const uint16_t enckeyid)</td></tr>
<tr class="memdesc:gaf099dc4245d056db33547fe1d49b541b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32 bytes of data into given slot. The function takes clear text bytes, but encrypts them for writing over the wire Data zone must be locked and the slot configuration must be set to encrypted write for the block to be successfully written.  <a href="#gaf099dc4245d056db33547fe1d49b541b">More...</a><br /></td></tr>
<tr class="separator:gaf099dc4245d056db33547fe1d49b541b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d2895192d93c524f5dba92a492cdfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga25d2895192d93c524f5dba92a492cdfb">atcab_lock</a> (uint8_t mode, uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga25d2895192d93c524f5dba92a492cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked.  <a href="#ga25d2895192d93c524f5dba92a492cdfb">More...</a><br /></td></tr>
<tr class="separator:ga25d2895192d93c524f5dba92a492cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga7cd67c03c7184ad041e2c0ad4f27db23">atcab_lock_config_zone</a> (void)</td></tr>
<tr class="memdesc:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the config zone.  <a href="#ga7cd67c03c7184ad041e2c0ad4f27db23">More...</a><br /></td></tr>
<tr class="separator:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad758b97819383fbee19336bf9f9540aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gad758b97819383fbee19336bf9f9540aa">atcab_lock_config_zone_crc</a> (uint16_t crc)</td></tr>
<tr class="memdesc:gad758b97819383fbee19336bf9f9540aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the config zone with summary CRC.  <a href="#gad758b97819383fbee19336bf9f9540aa">More...</a><br /></td></tr>
<tr class="separator:gad758b97819383fbee19336bf9f9540aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga8020aa89a5bed09ad35320b78e0fb890">atcab_lock_data_zone</a> (void)</td></tr>
<tr class="memdesc:ga8020aa89a5bed09ad35320b78e0fb890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the data zone (slots and OTP).  <a href="#ga8020aa89a5bed09ad35320b78e0fb890">More...</a><br /></td></tr>
<tr class="separator:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d94968da77056acf8098ef47b8fd53e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga2d94968da77056acf8098ef47b8fd53e">atcab_lock_data_zone_crc</a> (uint16_t crc)</td></tr>
<tr class="memdesc:ga2d94968da77056acf8098ef47b8fd53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the data zone (slots and OTP) with summary CRC.  <a href="#ga2d94968da77056acf8098ef47b8fd53e">More...</a><br /></td></tr>
<tr class="separator:ga2d94968da77056acf8098ef47b8fd53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb1cbc186d12e50b9d86dd8e0100604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga7fb1cbc186d12e50b9d86dd8e0100604">atcab_lock_data_slot</a> (uint8_t slot)</td></tr>
<tr class="memdesc:ga7fb1cbc186d12e50b9d86dd8e0100604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1).  <a href="#ga7fb1cbc186d12e50b9d86dd8e0100604">More...</a><br /></td></tr>
<tr class="separator:ga7fb1cbc186d12e50b9d86dd8e0100604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1aabfb0aa6876304c7c096a27902a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gade1aabfb0aa6876304c7c096a27902a5">atcab_priv_write</a> (uint16_t key_id, const uint8_t priv_key[36], uint8_t write_key_slot, const uint8_t write_key[32])</td></tr>
<tr class="memdesc:gade1aabfb0aa6876304c7c096a27902a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a P256 private key in given slot using mac computation  <a href="#gade1aabfb0aa6876304c7c096a27902a5">More...</a><br /></td></tr>
<tr class="separator:gade1aabfb0aa6876304c7c096a27902a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaa8b6953ad2c7f749e61566fd38fe6903">atcab_genkey_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *other_data, uint8_t *public_key)</td></tr>
<tr class="memdesc:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can generate a private key, compute a public key, and/or compute a digest of of a public key.  <a href="#gaa8b6953ad2c7f749e61566fd38fe6903">More...</a><br /></td></tr>
<tr class="separator:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga617bdbdce7b5736351d93214d44c5b8f">atcab_genkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga617bdbdce7b5736351d93214d44c5b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new random private key and return the public key.  <a href="#ga617bdbdce7b5736351d93214d44c5b8f">More...</a><br /></td></tr>
<tr class="separator:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2096a4618dd37c48ed48847fe63d844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gad2096a4618dd37c48ed48847fe63d844">atcab_get_pubkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:gad2096a4618dd37c48ed48847fe63d844"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a public key found in a designated slot. The slot must be configured as a slot with a private key. This method will use GenKey to generate the corresponding public key from the private key in the given slot.  <a href="#gad2096a4618dd37c48ed48847fe63d844">More...</a><br /></td></tr>
<tr class="separator:gad2096a4618dd37c48ed48847fe63d844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga5c1e598bf3d4d25b522f42d6038a4268">atcab_sign_base</a> (uint8_t mode, uint16_t key_id, uint8_t *signature)</td></tr>
<tr class="memdesc:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Sign command generates a signature using the ECDSA algorithm.  <a href="#ga5c1e598bf3d4d25b522f42d6038a4268">More...</a><br /></td></tr>
<tr class="separator:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga69b8282d1b1e0c54b9a7d286fed503b8">atcab_sign</a> (uint16_t key_id, const uint8_t *msg, uint8_t *signature)</td></tr>
<tr class="memdesc:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a 32-byte message using the private key in the specified slot.  <a href="#ga69b8282d1b1e0c54b9a7d286fed503b8">More...</a><br /></td></tr>
<tr class="separator:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga559add3e8b4f85a9d91fc0ed86aefa29">atcab_sign_internal</a> (uint16_t key_id, bool is_invalidate, bool is_full_sn, uint8_t *signature)</td></tr>
<tr class="memdesc:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign an internally generated message.  <a href="#ga559add3e8b4f85a9d91fc0ed86aefa29">More...</a><br /></td></tr>
<tr class="separator:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023ff586b49807c67f5af587f7480a3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga023ff586b49807c67f5af587f7480a3f">atcab_verify</a> (uint8_t mode, uint16_t key_id, const uint8_t *signature, const uint8_t *public_key, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga023ff586b49807c67f5af587f7480a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Verify command takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command.  <a href="#ga023ff586b49807c67f5af587f7480a3f">More...</a><br /></td></tr>
<tr class="separator:ga023ff586b49807c67f5af587f7480a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3e18de900ba705192963d08b37f600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga2c3e18de900ba705192963d08b37f600">atcab_verify_extern</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga2c3e18de900ba705192963d08b37f600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. Uses the CryptoAuthentication hardware instead of software.  <a href="#ga2c3e18de900ba705192963d08b37f600">More...</a><br /></td></tr>
<tr class="separator:ga2c3e18de900ba705192963d08b37f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8cc7670847805423ad591985eecd832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gae8cc7670847805423ad591985eecd832">atcab_verify_stored</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:gae8cc7670847805423ad591985eecd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a signature and message (ECDSA verify operation) against a public key stored in a specified slot.  <a href="#gae8cc7670847805423ad591985eecd832">More...</a><br /></td></tr>
<tr class="separator:gae8cc7670847805423ad591985eecd832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gacf9a0c7772ebb65b87c4a4788850702b">atcab_verify_validate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:gacf9a0c7772ebb65b87c4a4788850702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a public key stored in a slot.  <a href="#gacf9a0c7772ebb65b87c4a4788850702b">More...</a><br /></td></tr>
<tr class="separator:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga9393b545b2fa1fdd539672a0428a30ab">atcab_verify_invalidate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:ga9393b545b2fa1fdd539672a0428a30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate a public key stored in a slot.  <a href="#ga9393b545b2fa1fdd539672a0428a30ab">More...</a><br /></td></tr>
<tr class="separator:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9201defb41eaea6eb37df9a20db791ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga9201defb41eaea6eb37df9a20db791ca">atcab_ecdh</a> (uint16_t key_id, const uint8_t *pubkey, uint8_t *pms)</td></tr>
<tr class="memdesc:ga9201defb41eaea6eb37df9a20db791ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with premaster secret returned in the response.  <a href="#ga9201defb41eaea6eb37df9a20db791ca">More...</a><br /></td></tr>
<tr class="separator:ga9201defb41eaea6eb37df9a20db791ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c5daaedc57ca6655e5c23bb2b6f2cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gae2c5daaedc57ca6655e5c23bb2b6f2cd">atcab_ecdh_enc</a> (uint16_t key_id, const uint8_t *pubkey, uint8_t *pms, const uint8_t *enckey, uint16_t enckeyid)</td></tr>
<tr class="memdesc:gae2c5daaedc57ca6655e5c23bb2b6f2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with premaster secret read (encrypted) from next slot.  <a href="#gae2c5daaedc57ca6655e5c23bb2b6f2cd">More...</a><br /></td></tr>
<tr class="separator:gae2c5daaedc57ca6655e5c23bb2b6f2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga70751ea87f2cf913986bc7bca2cc661f">atcab_gendig</a> (uint8_t zone, uint16_t key_id, const uint8_t *other_data, uint8_t other_data_size)</td></tr>
<tr class="memdesc:ga70751ea87f2cf913986bc7bca2cc661f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to.  <a href="#ga70751ea87f2cf913986bc7bca2cc661f">More...</a><br /></td></tr>
<tr class="separator:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga98cb802fbb5d78cd552bb05c21d6c791">atcab_mac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, uint8_t *digest)</td></tr>
<tr class="memdesc:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a 32 byte MAC from the CryptoAuth device given a key ID and a challenge.  <a href="#ga98cb802fbb5d78cd552bb05c21d6c791">More...</a><br /></td></tr>
<tr class="separator:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga5ba49c05f7b3fb5acaf55df993ccd3ee">atcab_checkmac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, const uint8_t *response, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a MAC response with input values.  <a href="#ga5ba49c05f7b3fb5acaf55df993ccd3ee">More...</a><br /></td></tr>
<tr class="separator:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga45f1d09a51f7a1f68916536ab5125b9d">atcab_hmac</a> (uint8_t mode, uint16_t key_id, uint8_t *digest)</td></tr>
<tr class="memdesc:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HMAC command computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device. The output of this command is the output of the HMAC algorithm computed over this key and message. If the message includes the serial number of the device, the response is said to be "diversified".  <a href="#ga45f1d09a51f7a1f68916536ab5125b9d">More...</a><br /></td></tr>
<tr class="separator:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd8da6a78188668976dcce54f54bbc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaebd8da6a78188668976dcce54f54bbc9">atcab_derivekey</a> (uint8_t random, uint16_t key_id, uint8_t *mac)</td></tr>
<tr class="memdesc:gaebd8da6a78188668976dcce54f54bbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a DeriveKey Command to the device.  <a href="#gaebd8da6a78188668976dcce54f54bbc9">More...</a><br /></td></tr>
<tr class="separator:gaebd8da6a78188668976dcce54f54bbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98100897f317f28b768a484080056e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga98100897f317f28b768a484080056e7d">atcab_sha_base</a> (uint8_t mode, uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga98100897f317f28b768a484080056e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SHA command computes a SHA-256 digest for general purpose use by the system. Any message length can be accommodated. The system is responsible for sending the pad and length bytes with the last block for ATSHA devices.  <a href="#ga98100897f317f28b768a484080056e7d">More...</a><br /></td></tr>
<tr class="separator:ga98100897f317f28b768a484080056e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gae0a7ef89fce4cbd0ee1c76759cd93b9a">atcab_sha_start</a> (void)</td></tr>
<tr class="memdesc:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SHA-256 calculation engine.  <a href="#gae0a7ef89fce4cbd0ee1c76759cd93b9a">More...</a><br /></td></tr>
<tr class="separator:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga39bd70baa7a4c7f4849fcf8b94d4d949">atcab_sha_update</a> (const uint8_t *message)</td></tr>
<tr class="memdesc:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the message to be digested.  <a href="#ga39bd70baa7a4c7f4849fcf8b94d4d949">More...</a><br /></td></tr>
<tr class="separator:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db86704035048066a370815b657234d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga1db86704035048066a370815b657234d">atcab_sha_end</a> (uint8_t *digest, uint16_t length, const uint8_t *message)</td></tr>
<tr class="memdesc:ga1db86704035048066a370815b657234d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SHA-256 calculation is complete.  <a href="#ga1db86704035048066a370815b657234d">More...</a><br /></td></tr>
<tr class="separator:ga1db86704035048066a370815b657234d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d269ccdafd08519a899a8aebf53df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga31d269ccdafd08519a899a8aebf53df1">atcab_sha</a> (uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga31d269ccdafd08519a899a8aebf53df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a SHA-256 digest.  <a href="#ga31d269ccdafd08519a899a8aebf53df1">More...</a><br /></td></tr>
<tr class="separator:ga31d269ccdafd08519a899a8aebf53df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga416e4aeacf3acc35b1d5b76028c6947d">atcab_updateextra</a> (uint8_t mode, uint16_t new_value)</td></tr>
<tr class="memdesc:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UpdateExtra command is used to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85).  <a href="#ga416e4aeacf3acc35b1d5b76028c6947d">More...</a><br /></td></tr>
<tr class="separator:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade49e7746864105730fa7d531645ff62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gade49e7746864105730fa7d531645ff62">atcab_hw_sha2_256_init</a> (<a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx)</td></tr>
<tr class="separator:gade49e7746864105730fa7d531645ff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga67f2ce6224651d9cc65e9915e35558bd">atcab_hw_sha2_256_update</a> (<a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="separator:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a374d0ed07002b4c20eb49592641c95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga0a374d0ed07002b4c20eb49592641c95">atcab_hw_sha2_256_finish</a> (<a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx, uint8_t digest[<a class="el" href="a00225.html#ga86364f6d07b86740f3170d9d1ca60641">ATCA_SHA2_256_DIGEST_SIZE</a>])</td></tr>
<tr class="separator:ga0a374d0ed07002b4c20eb49592641c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f26091b8754321ab55440a9e6b01ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga89f26091b8754321ab55440a9e6b01ae">atcab_hw_sha2_256</a> (const uint8_t *data, size_t data_size, uint8_t digest[<a class="el" href="a00225.html#ga86364f6d07b86740f3170d9d1ca60641">ATCA_SHA2_256_DIGEST_SIZE</a>])</td></tr>
<tr class="separator:ga89f26091b8754321ab55440a9e6b01ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d5baf82b381edc5521fdb625749936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaf8d5baf82b381edc5521fdb625749936">atcab_printbin</a> (uint8_t *binary, int binLen, bool addspace)</td></tr>
<tr class="memdesc:gaf8d5baf82b381edc5521fdb625749936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print each hex character in the binary buffer.  <a href="#gaf8d5baf82b381edc5521fdb625749936">More...</a><br /></td></tr>
<tr class="separator:gaf8d5baf82b381edc5521fdb625749936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42c5720d63a1c85799f4939477616873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga42c5720d63a1c85799f4939477616873">atcab_bin2hex</a> (const uint8_t *binary, int binLen, char *asciiHex, int *asciiHexLen)</td></tr>
<tr class="separator:ga42c5720d63a1c85799f4939477616873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a1b905ff74a5ebe787eb3ec58260eed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga6a1b905ff74a5ebe787eb3ec58260eed">atcab_bin2hex_</a> (const uint8_t *binary, int binLen, char *asciiHex, int *asciiHexLen, bool addSpace)</td></tr>
<tr class="separator:ga6a1b905ff74a5ebe787eb3ec58260eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d34d89b6937a9510617b16177ede497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga4d34d89b6937a9510617b16177ede497">atcab_hex2bin</a> (const char *asciiHex, int asciiHexLen, uint8_t *binary, int *binLen)</td></tr>
<tr class="separator:ga4d34d89b6937a9510617b16177ede497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffab4798370a3e146093b3e30e61e91d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaffab4798370a3e146093b3e30e61e91d">atcab_printbin_sp</a> (uint8_t *binary, int binLen)</td></tr>
<tr class="memdesc:gaffab4798370a3e146093b3e30e61e91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print each hex character in the binary buffer with spaces between bytes.  <a href="#gaffab4798370a3e146093b3e30e61e91d">More...</a><br /></td></tr>
<tr class="separator:gaffab4798370a3e146093b3e30e61e91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae71a73ce045e5e1985309349ea0b7392"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gae71a73ce045e5e1985309349ea0b7392">atcab_printbin_label</a> (const char *label, uint8_t *binary, int binLen)</td></tr>
<tr class="memdesc:gae71a73ce045e5e1985309349ea0b7392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print each hex character in the binary buffer with spaces between bytes.  <a href="#gae71a73ce045e5e1985309349ea0b7392">More...</a><br /></td></tr>
<tr class="separator:gae71a73ce045e5e1985309349ea0b7392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d282d7c84cde638daf268e4f24757d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga9d282d7c84cde638daf268e4f24757d6">packHex</a> (const char *asciiHex, int asciiHexLen, char *packedHex, int *packedLen)</td></tr>
<tr class="memdesc:ga9d282d7c84cde638daf268e4f24757d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove white space from a ASCII hex string.  <a href="#ga9d282d7c84cde638daf268e4f24757d6">More...</a><br /></td></tr>
<tr class="separator:ga9d282d7c84cde638daf268e4f24757d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a929bf65cbc777bab7e533a2755cfad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga7a929bf65cbc777bab7e533a2755cfad">isDigit</a> (char c)</td></tr>
<tr class="memdesc:ga7a929bf65cbc777bab7e533a2755cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is an ASCII representation of a digit ((c ge '0') and (c le '9'))  <a href="#ga7a929bf65cbc777bab7e533a2755cfad">More...</a><br /></td></tr>
<tr class="separator:ga7a929bf65cbc777bab7e533a2755cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3db1b55b966b792e8308a1819933c0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gab3db1b55b966b792e8308a1819933c0e">isWhiteSpace</a> (char c)</td></tr>
<tr class="memdesc:gab3db1b55b966b792e8308a1819933c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is whitespace ((c == '<br />
') || (c == '') || (c == '') || (c == ' '))  <a href="#gab3db1b55b966b792e8308a1819933c0e">More...</a><br /></td></tr>
<tr class="separator:gab3db1b55b966b792e8308a1819933c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592c23e94097ad5e212beb6390aa88c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga592c23e94097ad5e212beb6390aa88c6">isAlpha</a> (char c)</td></tr>
<tr class="memdesc:ga592c23e94097ad5e212beb6390aa88c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f'))  <a href="#ga592c23e94097ad5e212beb6390aa88c6">More...</a><br /></td></tr>
<tr class="separator:ga592c23e94097ad5e212beb6390aa88c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78abefc293c0a04d8ef649c94c8a1057"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga78abefc293c0a04d8ef649c94c8a1057">isHexAlpha</a> (char c)</td></tr>
<tr class="memdesc:ga78abefc293c0a04d8ef649c94c8a1057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f'))  <a href="#ga78abefc293c0a04d8ef649c94c8a1057">More...</a><br /></td></tr>
<tr class="separator:ga78abefc293c0a04d8ef649c94c8a1057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ca9ee391118aafe6f3cf7df4fa5de3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gab7ca9ee391118aafe6f3cf7df4fa5de3">isHex</a> (char c)</td></tr>
<tr class="memdesc:gab7ca9ee391118aafe6f3cf7df4fa5de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid hex character or if this is whitespace (The character can be included in a valid hexstring).  <a href="#gab7ca9ee391118aafe6f3cf7df4fa5de3">More...</a><br /></td></tr>
<tr class="separator:gab7ca9ee391118aafe6f3cf7df4fa5de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39003da4dc8a0b8999f1325c2f96f641"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga39003da4dc8a0b8999f1325c2f96f641">isHexDigit</a> (char c)</td></tr>
<tr class="memdesc:ga39003da4dc8a0b8999f1325c2f96f641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid hex character.  <a href="#ga39003da4dc8a0b8999f1325c2f96f641">More...</a><br /></td></tr>
<tr class="separator:ga39003da4dc8a0b8999f1325c2f96f641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe017cfc3167b7e4872e75be7e608ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaffe017cfc3167b7e4872e75be7e608ad">packBase64</a> (const char *asciiBase64, int asciiBase64Len, char *packedBase64, int *packedLen)</td></tr>
<tr class="memdesc:gaffe017cfc3167b7e4872e75be7e608ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove white space from a base 64 string.  <a href="#gaffe017cfc3167b7e4872e75be7e608ad">More...</a><br /></td></tr>
<tr class="separator:gaffe017cfc3167b7e4872e75be7e608ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89139d0fcf1457efa9e1de483465698f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga89139d0fcf1457efa9e1de483465698f">isBase64</a> (char c)</td></tr>
<tr class="memdesc:ga89139d0fcf1457efa9e1de483465698f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid base 64 character or if this is whitespace (A character can be included in a valid base 64 string).  <a href="#ga89139d0fcf1457efa9e1de483465698f">More...</a><br /></td></tr>
<tr class="separator:ga89139d0fcf1457efa9e1de483465698f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04f828b5950ae57a02d5c01cf23b1a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaa04f828b5950ae57a02d5c01cf23b1a1">isBase64Digit</a> (char c)</td></tr>
<tr class="memdesc:gaa04f828b5950ae57a02d5c01cf23b1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid base 64 character.  <a href="#gaa04f828b5950ae57a02d5c01cf23b1a1">More...</a><br /></td></tr>
<tr class="separator:gaa04f828b5950ae57a02d5c01cf23b1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125f989126de7bc7d768846be99ba3a5"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga125f989126de7bc7d768846be99ba3a5">base64Index</a> (char c)</td></tr>
<tr class="memdesc:ga125f989126de7bc7d768846be99ba3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base 64 index of the given character.  <a href="#ga125f989126de7bc7d768846be99ba3a5">More...</a><br /></td></tr>
<tr class="separator:ga125f989126de7bc7d768846be99ba3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad70c731acf19a3783555a3c876067b57"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gad70c731acf19a3783555a3c876067b57">base64Char</a> (char id)</td></tr>
<tr class="memdesc:gad70c731acf19a3783555a3c876067b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base 64 character of the given index.  <a href="#gad70c731acf19a3783555a3c876067b57">More...</a><br /></td></tr>
<tr class="separator:gad70c731acf19a3783555a3c876067b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b2d17ed4ef06fdfd0552e32b9331d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga21b2d17ed4ef06fdfd0552e32b9331d8">atcab_base64decode</a> (const char *encoded, size_t encodedLen, uint8_t *byteArray, size_t *arrayLen)</td></tr>
<tr class="memdesc:ga21b2d17ed4ef06fdfd0552e32b9331d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode base 64 encoded characters into a byte array.  <a href="#ga21b2d17ed4ef06fdfd0552e32b9331d8">More...</a><br /></td></tr>
<tr class="separator:ga21b2d17ed4ef06fdfd0552e32b9331d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f2a204b6a4caca055994810137de8af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga3f2a204b6a4caca055994810137de8af">atcab_base64encode</a> (const uint8_t *byteArray, size_t arrayLen, char *encoded, size_t *encodedLen)</td></tr>
<tr class="memdesc:ga3f2a204b6a4caca055994810137de8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a byte array into base 64 encoded characters with <br />
 character every 64 bytes.  <a href="#ga3f2a204b6a4caca055994810137de8af">More...</a><br /></td></tr>
<tr class="separator:ga3f2a204b6a4caca055994810137de8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ffe8b04a0dcc2520de73eb88a61b87b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga3ffe8b04a0dcc2520de73eb88a61b87b">atcab_base64encode_</a> (const uint8_t *byteArray, size_t arrayLen, char *encoded, size_t *encodedLen, bool addNewLine)</td></tr>
<tr class="memdesc:ga3ffe8b04a0dcc2520de73eb88a61b87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a byte array into base 64 encoded characters. Optionally with <br />
 character every 64 bytes.  <a href="#ga3ffe8b04a0dcc2520de73eb88a61b87b">More...</a><br /></td></tr>
<tr class="separator:ga3ffe8b04a0dcc2520de73eb88a61b87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These methods provide the most convenient, simple API to CryptoAuth chips. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga530ccce9f617be7dbf3661e19a4c0546"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a00028.html">atca_sha256_ctx</a>  <a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga21b2d17ed4ef06fdfd0552e32b9331d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_base64decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encodedLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>arrayLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode base 64 encoded characters into a byte array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded</td><td>The input base 64 encoded characters that will be decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encodedLen</td><td>The length of the encoded characters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">byteArray</td><td>The output buffer that contains the decoded byte array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arrayLen</td><td>Input: The size of the decoded buffer Output: The length of the decoded byte array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f2a204b6a4caca055994810137de8af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_base64encode </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>byteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arrayLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>encodedLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a byte array into base 64 encoded characters with <br />
 character every 64 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">byteArray</td><td>The input byte array that will be converted to base 64 encoded characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLen</td><td>The length of the byte array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">encoded</td><td>The output converted to base 64 encoded characters. The <br />
 will be added every 64 characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">encodedLen</td><td>Input: The size of the encoded buffer Output: The length of the encoded base 64 character string including the additional <br />
 characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ffe8b04a0dcc2520de73eb88a61b87b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_base64encode_ </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>byteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arrayLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>encodedLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addNewLine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a byte array into base 64 encoded characters. Optionally with <br />
 character every 64 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">byteArray</td><td>The input byte array that will be converted to base 64 encoded characters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arrayLen</td><td>The length of the byte array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">encoded</td><td>The output converted to base 64 encoded characters. The <br />
 will optionally be added every 64 characters. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">encodedLen</td><td>Input: The size of the encoded buffer Output: The length of the encoded base 64 character string including the additional <br />
 characters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addNewLine</td><td>Optionally add a <br />
 every 64 characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga42c5720d63a1c85799f4939477616873"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_bin2hex </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>asciiHex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>asciiHexLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6a1b905ff74a5ebe787eb3ec58260eed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_bin2hex_ </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>asciiHex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>asciiHexLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gabed2c204c79b094e064385c85f3c1b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_cfg_discover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00046.html">ATCAIfaceCfg</a>&#160;</td>
          <td class="paramname"><em>cfgArray</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8b13f56c701eb5564e555923a621ae85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_challenge </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>challenge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a challenge to the device (a pass-through nonce) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">challenge</td><td>- pointer to 32 bytes of data which will be sent as the challenge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fc5691ab3a484d7a07cbbc214e6a8f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_challenge_seed_update </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a challenge to the device (a seed update nonce) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>- pointer to 32 bytes of data which will be sent as the challenge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>- points to space to receive random number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ba49c05f7b3fb5acaf55df993ccd3ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_checkmac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>challenge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a MAC response with input values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>The key in the CryptoAuth device to use for the MAC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">challenge</td><td>The 32 byte challenge number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">response</td><td>The 32 byte mac response number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>The 13 byte other data number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gadb91d2c3601b95f0ad413cf84a4dfd87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_cmp_config_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>same_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function compares all writable bytes in the configuration zone that is passed in to the bytes on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config_data</td><td>pointer to all bytes in configuration zone. Not used if NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">same_config</td><td>pointer to boolean status whether config data passed in matches the actual config zone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>
<p>Max for all configs </p>

</div>
</div>
<a class="anchor" id="gaebd8da6a78188668976dcce54f54bbc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_derivekey </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>target_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a DeriveKey Command to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Bit 2 must match the value in TempKey.SourceFlag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_key</td><td>Key slot to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>Optional 32 byte MAC used to validate operation. NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="ga9201defb41eaea6eb37df9a20db791ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_ecdh </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pubkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with premaster secret returned in the response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pubkey</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here. 32 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="gae2c5daaedc57ca6655e5c23bb2b6f2cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_ecdh_enc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pubkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>enckey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>enckeyid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with premaster secret read (encrypted) from next slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pubkey</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here. 32 bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enckey</td><td>Read key for the premaster secret slot (slotid+1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enckeyid</td><td>Read key slot for enckey.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga70751ea87f2cf913986bc7bca2cc661f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_gendig </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>other_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Designates the source of the data to hash with TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Indicates the key, OTP block, or message order for shared nonce mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>Four bytes of data for SHA calculation when using a NoMac key, 32 bytes for "Shared Nonce" mode, otherwise ignored (can be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data_size</td><td>Size of other_data in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga617bdbdce7b5736351d93214d44c5b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_genkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a new random private key and return the public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot where an ECC private key is configured. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8b6953ad2c7f749e61566fd38fe6903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_genkey_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This command can generate a private key, compute a public key, and/or compute a digest of of a public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode bit mask determines what operations the GenKey command performs. Bit 4 overrides bits 2 and 3. Bit 2 will create a new random private key in key_id and return the public key. Leave 0 to just calculate the public key from an existing private key. Bit 3 will create a PubKey digest from the calculated public key and store it in TempKey. Bit 4 will create a PubKey digest from the public key stored in key_id and store it in TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot to perform the GenKey command on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>If bit 4 of mode is set, these 3 bytes replace Param1 and Param2 in the PubKey digest calculation. Can be set to NULL otherwise. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>If the mode indicates a public key will be calculated, it will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="gabdfeb1f8d28039e9b30d4e39b8caa33a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_get_addr </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the address given the zone, slot, block, and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga4af82005556c549c30e1c4bd35d4f4e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00221.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> atcab_get_device </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a way to get the global device object. Generally for more sophisticated users of atca </p>
<dl class="section return"><dt>Returns</dt><dd>instance of global ATCADevice </dd></dl>

</div>
</div>
<a class="anchor" id="gad2096a4618dd37c48ed48847fe63d844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_get_pubkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a public key found in a designated slot. The slot must be configured as a slot with a private key. This method will use GenKey to generate the corresponding public key from the private key in the given slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>ID of the private key slot </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>- pointer to space receiving the contents of the public key that was generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a823d2a391bf80ff336eb2ccbd37412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_get_zone_size </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the specified zone in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to get size information from. Config(0), OTP(1), or Data(2) which requires a slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If zone is Data(2), the slot to query for size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Zone size is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d34d89b6937a9510617b16177ede497"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hex2bin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>asciiHex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>asciiHexLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>binLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga45f1d09a51f7a1f68916536ab5125b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hmac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HMAC command computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device. The output of this command is the output of the HMAC algorithm computed over this key and message. If the message includes the serial number of the device, the response is said to be "diversified". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Which key is to be used to generate the response. Bits 0:3 only are used to select a slot but all 16 bits are used in the HMAC message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>HMAC digest is returned in this buffer (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="ga89f26091b8754321ab55440a9e6b01ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hw_sha2_256 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>digest</em>[ATCA_SHA2_256_DIGEST_SIZE]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0a374d0ed07002b4c20eb49592641c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hw_sha2_256_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>digest</em>[ATCA_SHA2_256_DIGEST_SIZE]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gade49e7746864105730fa7d531645ff62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hw_sha2_256_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga67f2ce6224651d9cc65e9915e35558bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_hw_sha2_256_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf47433a371b9fcb8d65a4214cd9e4fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_idle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>idle the CryptoAuth device </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e19ecd60be4c74665d9ec142e460771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_info </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>revision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the device revision information </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">revision</td><td>- 4-byte storage for receiving the revision number from the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gacdc4fa3d2f2f6d197af8c10ab1f288b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00046.html">ATCAIfaceCfg</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>atcab_init is called once for the life of the application and creates a global ATCADevice object used by Basic API. This method builds a global ATCADevice instance behinds the scenes that's used for all Basic API operations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>is a pointer to an interface configuration. This is usually a predefined configuration found in <a class="el" href="a00066.html" title="a set of default configurations for various ATCA devices and interfaces ">atca_cfgs.h</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00224.html#ga1cb5f2d8f7796c6d7e93d36a86dc3ce9" title="atcab_init_device can be used to initialize the global ATCADevice object to point to one of your choo...">atcab_init_device()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1cb5f2d8f7796c6d7e93d36a86dc3ce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_init_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00221.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>cadevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>atcab_init_device can be used to initialize the global ATCADevice object to point to one of your choosing for use with all the atcab_ basic API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cadevice</td><td>ATCADevice instance to use as the global Basic API crypto device instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gaefce484222bdbedef37787a9b10d4426"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_is_locked </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query to see if the specified zone is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>The zone to query for locked (use LOCK_ZONE_CONFIG or LOCK_ZONE_DATA) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>true if the specified zone is locked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="gac244d4c7a4bbb4004d30ba680c5136ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_is_slot_locked </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query to see if the specified slot is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>The slot to query for locked (slot 0-15) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>true if the specified slot is locked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="ga25d2895192d93c524f5dba92a492cdfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>summary_crc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Zone, and/or slot, and summary check (bit 7). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">summary_crc</td><td>CRC of the config or data zones. Ignored for slot locks or when mode bit 7 is set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga7cd67c03c7184ad041e2c0ad4f27db23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock_config_zone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally (no CRC required) lock the config zone. </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="gad758b97819383fbee19336bf9f9540aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock_config_zone_crc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>crc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the config zone with summary CRC. </p>
<p>The CRC is calculated over the entire config zone contents. 88 bytes for ATSHA devices, 128 bytes for ATECC devices. Lock will fail if the provided CRC doesn't match the internally calculated one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crc</td><td>Expected CRC over the config zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fb1cbc186d12e50b9d86dd8e0100604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock_data_slot </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot to be locked in data zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga8020aa89a5bed09ad35320b78e0fb890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock_data_zone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally (no CRC required) lock the data zone (slots and OTP). </p>
<p>ConfigZone must be locked and DataZone must be unlocked for the zone to be successfully locked.</p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d94968da77056acf8098ef47b8fd53e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_lock_data_zone_crc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>crc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the data zone (slots and OTP) with summary CRC. </p>
<p>The CRC is calculated over the concatenated contents of all the slots and OTP at the end. Private keys (KeyConfig.Private=1) are skipped. Lock will fail if the provided CRC doesn't match the internally calculated one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">crc</td><td>Expected CRC over the data zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga98cb802fbb5d78cd552bb05c21d6c791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_mac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>challenge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a 32 byte MAC from the CryptoAuth device given a key ID and a challenge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>The key in the CryptoAuth device to use for the MAC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">challenge</td><td>The 32 byte challenge number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>The response of the MAC command using the given challenge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gab10c899d3b8cfb1b9ada47f925b8cbce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_nonce </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>tempkey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a pass-through Nonce command to initialize TempKey to the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tempkey</td><td>- pointer to 32 bytes of data which will be used to initialize TempKey </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gaff392b11a0d00fefa2dff30ec7040fc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_nonce_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Nonce command generates a nonce for use by subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls the mechanism of the internal RNG and seed update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Input value to either be included in the nonce calculation in random modes (20 bytes) or to be written to TempKey directly (32 bytes) in pass-through mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>If using a a random mode, the internally generated 32-byte random number that was used in the nonce calculation is returned here. Can be NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="gaf162c6327e0cc2e43fc6b483dbc21a32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_nonce_rand </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize TempKey with a random Nonce. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>- pointer to 20 bytes of data which will be used to calculate TempKey </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>- pointer to 32 bytes of data that is the output of the Nonce command </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gaf8d5baf82b381edc5521fdb625749936"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_printbin </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addspace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print each hex character in the binary buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">binary</td><td>input buffer to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binLen</td><td>length of buffer to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addspace</td><td>indicates whether spaces and returns should be added for pretty printing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gae71a73ce045e5e1985309349ea0b7392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_printbin_label </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print each hex character in the binary buffer with spaces between bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>label to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binary</td><td>input buffer to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binLen</td><td>length of buffer to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gaffab4798370a3e146093b3e30e61e91d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_printbin_sp </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print each hex character in the binary buffer with spaces between bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">binary</td><td>input buffer to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binLen</td><td>length of buffer to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gade1aabfb0aa6876304c7c096a27902a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_priv_write </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>priv_key</em>[36], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>write_key_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>write_key</em>[32]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write a P256 private key in given slot using mac computation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priv_key</td><td>first 4 bytes of 36 bytes should be zero for P256 curve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_key_slot</td><td>slot to make a session key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_key</td><td>key to make a session key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fa442396dfbb89e59dfca837b565cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_random </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a 32 byte random number from the CryptoAuth device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>ptr to 32 bytes of storage for random number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the operation </dd></dl>

</div>
</div>
<a class="anchor" id="gafef5ecc82d845eaebdf50a58ac489e66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_bytes_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from config, otp, or data zone with a given byte offset and length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to read data from: Config(0), OTP(1), or Data(2). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If zone is Data(2), the slot number to read from. Ignored for all other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_bytes</td><td>Byte offset within the zone to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Buffer to read data into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ef47330eef6bc72ae8f7a8ef026dae3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_config_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given an SHA configuration zone buffer and dev type, read its parts from the device's config zone </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">config_data</td><td>pointer to buffer containing a contiguous set of bytes to write to the config zone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga8dac8b8c0a82dac68da82724129e278d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_enc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>enckey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>enckeyid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 32 bytes of data from the given slot. The function returns clear text bytes. Encrypted bytes are read over the wire, then subsequently decrypted Data zone must be locked and the slot configuration must be set to encrypted read for the block to be successfully read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>The slot id for the encrypted read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>The block id in the specified slot </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The 32 bytes of clear text data that was read encrypted from the slot, then decrypted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enckey</td><td>The key to encrypt with for writing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enckeyid</td><td>The keyid of the parent encryption key returns ATCA_STATUS </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabe236622ac65a2ccbf313d4a1971c258"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_pubkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot8toF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pubkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads a pub key from a readable data slot versus atcab_get_pubkey which generates a pubkey from a private key slot </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot8toF</td><td>- slot number to read, expected value is 0x8 through 0xF </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pubkey</td><td>- space to receive read pubkey </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga96c434878e1f435e2cda5b0b5fec444f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_serial_number </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>serial_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read the serial number of the device </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">serial_number</td><td>pointer to space to receive serial number. This space should be 9 bytes long </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gaddea9705cb35400bf64c43f8ef3ec368"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_sig </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot8toF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads a signature found in one of slots 8 through F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot8toF</td><td>- which slot to read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sig</td><td>- pointer to the space to receive the signature found in the slot </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ce01f02f456c08891ca1d67cd3ed0eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_read_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read either 4 or 32 bytes of data into given slot </p>
<p>for 32 byte read, offset is ignored data receives the contents read from the slot</p>
<p>data zone must be locked and the slot configuration must not be secret for a slot to be successfully read</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Must be either 4 or 32 returns ATCA_STATUS </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a061c1f96bb641b36fc56b6cb2dd4e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_release </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release (free) the global ATCADevice instance. This must be called in order to release or free up the interface. </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga31d269ccdafd08519a899a8aebf53df1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a SHA-256 digest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of bytes in the message parameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>- pointer to variable length message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>The SHA256 digest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga98100897f317f28b768a484080056e7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SHA command computes a SHA-256 digest for general purpose use by the system. Any message length can be accommodated. The system is responsible for sending the pad and length bytes with the last block for ATSHA devices. </p>
<p>Only the Start(0) and Compute(1) modes are available for ATSHA devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>SHA command mode: Start(0), Update/Compute(1), End(2), Public(3), HMACstart(4), MHACend(5) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes in the Message parameter. Must be 0 for start command, 64 for update/compute commands, and 0 to 63 for end commands. KeySlot for the HMAC key if Mode is "HMACstart". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message bytes to be hashed. Can be NULL if not required by the mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">digest</td><td>Digest (32 bytes) is returned here for end commands (or compute command for ATSHA devices).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga1db86704035048066a370815b657234d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_end </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SHA-256 calculation is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>The SHA256 digest that is calculated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of any remaining data to include in hash. Max 64 bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Remaining data to include in hash. NULL if length is 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="gae0a7ef89fce4cbd0ee1c76759cd93b9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize SHA-256 calculation engine. </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga39bd70baa7a4c7f4849fcf8b94d4d949"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sha_update </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the message to be digested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Add 64 bytes in the message parameter to the SHA context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga69b8282d1b1e0c54b9a7d286fed503b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sign </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign a 32-byte message using the private key in the specified slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of the private key to be used to sign the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>32-byte message to be signed. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature is returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c1e598bf3d4d25b522f42d6038a4268"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sign_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Sign command generates a signature using the ECDSA algorithm. </p>
<p>For external messages, it must be loaded into TempKey.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Bit mask indicating signing mode. Bit 0: 1 for Verify(Invalidate), 0 for Verify(Validate) and all others Bits 1-5: Must be 0 Bit 6: If bit 7 is 1, include SN[2:3] and SN[4:7] in message, ignored otherwise Bit 7: 0 for internal message, 1 for external message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Private key slot used to sign the message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature is returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga559add3e8b4f85a9d91fc0ed86aefa29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sign_internal </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_invalidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_full_sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sign an internally generated message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of the private key to be used to sign the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_invalidate</td><td>Set to true if the signature will be used with the Verify(Invalidate) command. false for all other cases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_full_sn</td><td>Set to true if the message should incorporate the device's full serial number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature is returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga9475e032c388144c5a0df45d1df182a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>invoke sleep on the CryptoAuth device </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga416e4aeacf3acc35b1d5b76028c6947d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_updateextra </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The UpdateExtra command is used to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85). </p>
<p>Can also be used to decrement the limited use counter associated with the key in slot NewValue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Bit 0: 0 = update user extra (config[84]), 1 = update selector (config[85]) Bit 1: Ignores bit 0 and decrements the limited use counter associated with the key in new_value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_value</td><td>When mode bit 1 is set, this the key for which the limited use counter will be decremented.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga023ff586b49807c67f5af587f7480a3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Verify command takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command. </p>
<p>For the Stored, External, and ValidateExternal Modes, the contents of TempKey should contain the SHA-256 digest of the message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Verify command mode: Stored(0), ValidateExternal(1), External(2), Validate(3), or Invalidate(7) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Stored Mode - The slot containing the public key to be used for the verification. ValidateExternal Mode - The slot containing the public key to be validated. External Mode - KeyID contains the curve type to be used to Verify the signature. Validate or Invalidate Mode - The slot containing the public key to be (in)validated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>If mode is External, the public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. NULL for all other modes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>If mode is Validate, the bytes used to generate the message for the validation (19 bytes). NULL for all other modes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c3e18de900ba705192963d08b37f600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify_extern </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. Uses the CryptoAuthentication hardware instead of software. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9393b545b2fa1fdd539672a0428a30ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify_invalidate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate a public key stored in a slot. </p>
<p>This command can only be run after GenKey has been used to create a PubKey digest of the public key to be invalidated in TempKey (mode=0x10).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be invalidated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>19 bytes of data used to build the verification message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, validation public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="gae8cc7670847805423ad591985eecd832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify_stored </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify a signature and message (ECDSA verify operation) against a public key stored in a specified slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be used in the verification. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf9a0c7772ebb65b87c4a4788850702b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_verify_validate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate a public key stored in a slot. </p>
<p>This command can only be run after GenKey has been used to create a PubKey digest of the public key to be validated in TempKey (mode=0x10).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be validated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>19 bytes of data used to build the verification message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, validation public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="ga563f3d7c25ee88ff5b2c988f4eb59bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_version </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>verstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a version string for the CryptoAuthLib release. The format of the version string returned is "yyyymmdd" </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">verstr</td><td>ptr to space to receive version string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gad3bc620aedd9322d160eece0d8d20c82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wakeup the CryptoAuth device </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gabf2b29b4d3ae926b63c403d084380dbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Write command writes either one four byte word or an 8-word block of 32 bytes to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone/Param1 for the write command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Addres/Param2 for the write command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Plain-text data to be written or cipher-text for encrypted writes. 32 or 4 bytes depending on bit 7 in the zone. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>MAC required for encrypted writes (32 bytes). Set to NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="gac395a7e195aa3cf28b48de345755feb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_bytes_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data into config, otp, or data zone with a given byte offset and length. Offset and length must be multiples of a word (4 bytes). </p>
<p>Config zone must be unlocked for writes to that zone. If data zone is unlocked, only 32-byte writes are allowed to slots and OTP and the offset and length must be multiples of 32 or the write will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to write data to: <a class="el" href="a00068.html#add3796a1d4de55604283aef5a70f7945" title="Configuration zone. ">ATCA_ZONE_CONFIG(0)</a>, <a class="el" href="a00068.html#a547efc6fa3cb0501b2e53f80023dff7e" title="OTP (One Time Programming) zone. ">ATCA_ZONE_OTP(1)</a>, or <a class="el" href="a00068.html#a4c65b241280290fae9fd4faa9d7a292b" title="Data zone. ">ATCA_ZONE_DATA(2)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If zone is <a class="el" href="a00068.html#a4c65b241280290fae9fd4faa9d7a292b" title="Data zone. ">ATCA_ZONE_DATA(2)</a>, the slot number to write to. Ignored for all other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_bytes</td><td>Byte offset within the zone to write to. Must be a multiple of a word (4 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to be written. Must be a multiple of a word (4 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="ga0777a86aa412a97b19cc72a12c171b94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_config_zone </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the configuration zone skipping the lock values. </p>
<p>First 16 bytes are skipped as they are not writable. LockValue and LockConfig are also skipped and can only be changed via the Lock command.</p>
<p>This command may fail if UserExtra and/or Selector bytes have already been set to non-zero values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config_data</td><td>Data to the config zone data. This should be 88 bytes for SHA devices and 128 bytes for ECC devices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="gaf099dc4245d056db33547fe1d49b541b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_enc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>enckey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>enckeyid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 32 bytes of data into given slot. The function takes clear text bytes, but encrypts them for writing over the wire Data zone must be locked and the slot configuration must be set to encrypted write for the block to be successfully written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The 32 bytes of clear text data to be written to the slot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enckey</td><td>The key to encrypt with for writing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enckeyid</td><td>The keyid of the parent encryption key returns ATCA_STATUS </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09f2d9d7d0bfa4badfcea82b9b02f151"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_pubkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot8toF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pubkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a pub key from to a data slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot8toF</td><td>Slot number to write, expected value is 0x8 through 0xF </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pubkey</td><td>The public key to write into the slot specified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f5a6bbcf4f840803635fb8951b3a7e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> atcab_write_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write either 4 or 32 bytes of data into a device zone. </p>
<p>See ECC108A datasheet, datazone address values, table 9-8</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Device zone to write to (0=config, 1=OTP, 2=data). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If writing to the data zone, whit is the slot to write to, otherwise it should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>32-byte block to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>4-byte word within the specified block to write to. If performing a 32-byte write, this should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to be written. Must be either 4 or 32. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a class="anchor" id="gad70c731acf19a3783555a3c876067b57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char base64Char </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the base 64 character of the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>index to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base 64 character of the given index </dd></dl>

</div>
</div>
<a class="anchor" id="ga125f989126de7bc7d768846be99ba3a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char base64Index </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the base 64 index of the given character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the base 64 index of the given character </dd></dl>

</div>
</div>
<a class="anchor" id="ga592c23e94097ad5e212beb6390aa88c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isAlpha </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f')) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a hex </dd></dl>

</div>
</div>
<a class="anchor" id="ga89139d0fcf1457efa9e1de483465698f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isBase64 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid base 64 character or if this is whitespace (A character can be included in a valid base 64 string). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid base 64 string </dd></dl>

</div>
</div>
<a class="anchor" id="gaa04f828b5950ae57a02d5c01cf23b1a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isBase64Digit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid base 64 character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid base 64 string </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a929bf65cbc777bab7e533a2755cfad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is an ASCII representation of a digit ((c ge '0') and (c le '9')) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a digit </dd></dl>

</div>
</div>
<a class="anchor" id="gab7ca9ee391118aafe6f3cf7df4fa5de3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isHex </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid hex character or if this is whitespace (The character can be included in a valid hexstring). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid hexstring </dd></dl>

</div>
</div>
<a class="anchor" id="ga78abefc293c0a04d8ef649c94c8a1057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isHexAlpha </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f')) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a hex </dd></dl>

</div>
</div>
<a class="anchor" id="ga39003da4dc8a0b8999f1325c2f96f641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isHexDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid hex character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid hexstring </dd></dl>

</div>
</div>
<a class="anchor" id="gab3db1b55b966b792e8308a1819933c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isWhiteSpace </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is whitespace ((c == '<br />
') || (c == '') || (c == '') || (c == ' ')) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is whitespace </dd></dl>

</div>
</div>
<a class="anchor" id="gaffe017cfc3167b7e4872e75be7e608ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> packBase64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>asciiBase64</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>asciiBase64Len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>packedBase64</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>packedLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove white space from a base 64 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">asciiBase64</td><td>Initial base 64 string to remove white space from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">asciiBase64Len</td><td>Length of the initial base 64 string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packedBase64</td><td>Resulting base 64 string without white space </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packedLen</td><td>In: Size to packedHex buffer Out: Number of bytes in the packed base 64 string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS if asciiBase64 was packed without errors </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d282d7c84cde638daf268e4f24757d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> packHex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>asciiHex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>asciiHexLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>packedHex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>packedLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove white space from a ASCII hex string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">asciiHex</td><td>Initial hex string to remove white space from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">asciiHexLen</td><td>Length of the initial hex string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packedHex</td><td>Resulting hex string without white space </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packedLen</td><td>In: Size to packedHex buffer Out: Number of bytes in the packed hex string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS if asciiHex was packed without errors </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>

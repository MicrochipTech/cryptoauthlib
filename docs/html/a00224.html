<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CryptoAuthLib: atca_basic.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CryptoAuthLib
   </div>
   <div id="projectbrief">Microchip CryptoAuthentication Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a00224.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">atca_basic.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CryptoAuthLib Basic API methods - a simple crypto authentication API. These methods manage a global ATCADevice object behind the scenes. They also manage the wake/idle state transitions so callers don't need to.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="a00359_source.html">cryptoauthlib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="a00344_source.html">crypto/atca_crypto_sw_sha2.h</a>&quot;</code><br />
</div>
<p><a href="a00224_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01069.html">atca_aes_cbc_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01073.html">atca_aes_cmac_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01077.html">atca_aes_ctr_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01081.html">atca_sha256_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga66d0b18bba952f5acdee8cf68b889b75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga66d0b18bba952f5acdee8cf68b889b75">BLOCK_NUMBER</a>(a)&#160;&#160;&#160;(a / 32)</td></tr>
<tr class="separator:ga66d0b18bba952f5acdee8cf68b889b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e5ab0fea07bd91159ab96f18105d1b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga9e5ab0fea07bd91159ab96f18105d1b1">WORD_OFFSET</a>(a)&#160;&#160;&#160;((a % 32) / 4)</td></tr>
<tr class="separator:ga9e5ab0fea07bd91159ab96f18105d1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d0b05dd9b5d0987e24eef9674922ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gad4d0b05dd9b5d0987e24eef9674922ce">ATCA_AES_GCM_IV_STD_LENGTH</a>&#160;&#160;&#160;12</td></tr>
<tr class="separator:gad4d0b05dd9b5d0987e24eef9674922ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa702726fe160635225abc3c1ed421f7e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a01069.html">atca_aes_cbc_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a></td></tr>
<tr class="separator:gaa702726fe160635225abc3c1ed421f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05fa8c58bf4408381db8871b0dca64b6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a01073.html">atca_aes_cmac_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a></td></tr>
<tr class="separator:ga05fa8c58bf4408381db8871b0dca64b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b18f051752d214a2d5b485270f5b15"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a01077.html">atca_aes_ctr_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a></td></tr>
<tr class="separator:ga52b18f051752d214a2d5b485270f5b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530ccce9f617be7dbf3661e19a4c0546"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a01081.html">atca_sha256_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a></td></tr>
<tr class="separator:ga530ccce9f617be7dbf3661e19a4c0546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c1f62e502c168be9261d2af921e78ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00991.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a></td></tr>
<tr class="separator:ga4c1f62e502c168be9261d2af921e78ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaff701132013eaac5600dd9fd6253505d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaff701132013eaac5600dd9fd6253505d">atcab_version</a> (char *ver_str)</td></tr>
<tr class="memdesc:gaff701132013eaac5600dd9fd6253505d"><td class="mdescLeft">&#160;</td><td class="mdescRight">basic API methods are all prefixed with atcab_ (CryptoAuthLib Basic) the fundamental premise of the basic API is it is based on a single interface instance and that instance is global, so all basic API commands assume that one global device is the one to operate on.  <a href="a00991.html#gaff701132013eaac5600dd9fd6253505d">More...</a><br /></td></tr>
<tr class="separator:gaff701132013eaac5600dd9fd6253505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gacdc4fa3d2f2f6d197af8c10ab1f288b8">atcab_init</a> (<a class="el" href="a01013.html">ATCAIfaceCfg</a> *cfg)</td></tr>
<tr class="memdesc:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a global ATCADevice object used by Basic API.  <a href="a00991.html#gacdc4fa3d2f2f6d197af8c10ab1f288b8">More...</a><br /></td></tr>
<tr class="separator:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gab22d2a32e6c32c14c4e58ce794ff3ec4">atcab_init_device</a> (<a class="el" href="a00988.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> ca_device)</td></tr>
<tr class="memdesc:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the global ATCADevice object to point to one of your choosing for use with all the atcab_ basic API.  <a href="a00991.html#gab22d2a32e6c32c14c4e58ce794ff3ec4">More...</a><br /></td></tr>
<tr class="separator:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga3a061c1f96bb641b36fc56b6cb2dd4e4">atcab_release</a> (void)</td></tr>
<tr class="memdesc:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">release (free) the global ATCADevice instance. This must be called in order to release or free up the interface.  <a href="a00991.html#ga3a061c1f96bb641b36fc56b6cb2dd4e4">More...</a><br /></td></tr>
<tr class="separator:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00988.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga4af82005556c549c30e1c4bd35d4f4e4">atcab_get_device</a> (void)</td></tr>
<tr class="memdesc:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global device object.  <a href="a00991.html#ga4af82005556c549c30e1c4bd35d4f4e4">More...</a><br /></td></tr>
<tr class="separator:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b02163fab87313b81dd7f51345d3eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00988.html#gafb234ccd6a80d09c0efbe336c2354267">ATCADeviceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga2b02163fab87313b81dd7f51345d3eb6">atcab_get_device_type</a> (void)</td></tr>
<tr class="memdesc:ga2b02163fab87313b81dd7f51345d3eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current device type.  <a href="a00991.html#ga2b02163fab87313b81dd7f51345d3eb6">More...</a><br /></td></tr>
<tr class="separator:ga2b02163fab87313b81dd7f51345d3eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5802cd6847a837458604db5dbec4a6f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga5802cd6847a837458604db5dbec4a6f0">_atcab_exit</a> (void)</td></tr>
<tr class="memdesc:ga5802cd6847a837458604db5dbec4a6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">common cleanup code which idles the device after any operation  <a href="a00991.html#ga5802cd6847a837458604db5dbec4a6f0">More...</a><br /></td></tr>
<tr class="separator:ga5802cd6847a837458604db5dbec4a6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3bc620aedd9322d160eece0d8d20c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gad3bc620aedd9322d160eece0d8d20c82">atcab_wakeup</a> (void)</td></tr>
<tr class="memdesc:gad3bc620aedd9322d160eece0d8d20c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">wakeup the CryptoAuth device  <a href="a00991.html#gad3bc620aedd9322d160eece0d8d20c82">More...</a><br /></td></tr>
<tr class="separator:gad3bc620aedd9322d160eece0d8d20c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaf47433a371b9fcb8d65a4214cd9e4fa0">atcab_idle</a> (void)</td></tr>
<tr class="memdesc:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">idle the CryptoAuth device  <a href="a00991.html#gaf47433a371b9fcb8d65a4214cd9e4fa0">More...</a><br /></td></tr>
<tr class="separator:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9475e032c388144c5a0df45d1df182a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga9475e032c388144c5a0df45d1df182a5">atcab_sleep</a> (void)</td></tr>
<tr class="memdesc:ga9475e032c388144c5a0df45d1df182a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke sleep on the CryptoAuth device  <a href="a00991.html#ga9475e032c388144c5a0df45d1df182a5">More...</a><br /></td></tr>
<tr class="separator:ga9475e032c388144c5a0df45d1df182a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1518196e269b549eec78087abd130de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga1518196e269b549eec78087abd130de7">atcab_cfg_discover</a> (<a class="el" href="a01013.html">ATCAIfaceCfg</a> cfg_array[], int <a class="el" href="a00993.html#gaffe776513b24d84b39af8ab0930fef7f">max</a>)</td></tr>
<tr class="memdesc:ga1518196e269b549eec78087abd130de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto discovery of crypto auth devices  <a href="a00991.html#ga1518196e269b549eec78087abd130de7">More...</a><br /></td></tr>
<tr class="separator:ga1518196e269b549eec78087abd130de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gabdfeb1f8d28039e9b30d4e39b8caa33a">atcab_get_addr</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint16_t *addr)</td></tr>
<tr class="memdesc:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the address given the zone, slot, block, and offset.  <a href="a00991.html#gabdfeb1f8d28039e9b30d4e39b8caa33a">More...</a><br /></td></tr>
<tr class="separator:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga7a823d2a391bf80ff336eb2ccbd37412">atcab_get_zone_size</a> (uint8_t zone, uint16_t slot, size_t *size)</td></tr>
<tr class="memdesc:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified zone in bytes.  <a href="a00991.html#ga7a823d2a391bf80ff336eb2ccbd37412">More...</a><br /></td></tr>
<tr class="separator:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad115ce255664a48b80e90ea19c156b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gad115ce255664a48b80e90ea19c156b79">atcab_aes</a> (uint8_t mode, uint16_t key_id, const uint8_t *aes_in, uint8_t *aes_out)</td></tr>
<tr class="memdesc:gad115ce255664a48b80e90ea19c156b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the AES-128 encrypt, decrypt, or GFM calculation.  <a href="a00991.html#gad115ce255664a48b80e90ea19c156b79">More...</a><br /></td></tr>
<tr class="separator:gad115ce255664a48b80e90ea19c156b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gacc9a58dc49f91674213f34fa7bbd05e1">atcab_aes_encrypt</a> (uint16_t key_id, uint8_t key_block, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 encrypt operation with a key in the device.  <a href="a00991.html#gacc9a58dc49f91674213f34fa7bbd05e1">More...</a><br /></td></tr>
<tr class="separator:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9658e84055727e6357cf7ef636b4e398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga9658e84055727e6357cf7ef636b4e398">atcab_aes_decrypt</a> (uint16_t key_id, uint8_t key_block, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:ga9658e84055727e6357cf7ef636b4e398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 decrypt operation with a key in the device.  <a href="a00991.html#ga9658e84055727e6357cf7ef636b4e398">More...</a><br /></td></tr>
<tr class="separator:ga9658e84055727e6357cf7ef636b4e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5554940ed4c7c7e28652ce6923cf9314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga5554940ed4c7c7e28652ce6923cf9314">atcab_aes_gfm</a> (const uint8_t *h, const uint8_t *input, uint8_t *output)</td></tr>
<tr class="memdesc:ga5554940ed4c7c7e28652ce6923cf9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a Galois Field Multiply (GFM) operation.  <a href="a00991.html#ga5554940ed4c7c7e28652ce6923cf9314">More...</a><br /></td></tr>
<tr class="separator:ga5554940ed4c7c7e28652ce6923cf9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc41b824cdc9b10efa46bcbf74850184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gabc41b824cdc9b10efa46bcbf74850184">atcab_aes_cbc_init</a> (<a class="el" href="a00991.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a> *ctx, uint16_t key_id, uint8_t key_block, const uint8_t *iv)</td></tr>
<tr class="memdesc:gabc41b824cdc9b10efa46bcbf74850184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES CBC operation.  <a href="a00991.html#gabc41b824cdc9b10efa46bcbf74850184">More...</a><br /></td></tr>
<tr class="separator:gabc41b824cdc9b10efa46bcbf74850184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7414e3dc8215cedc1bffc6cf576d7d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga7414e3dc8215cedc1bffc6cf576d7d1e">atcab_aes_cbc_encrypt_block</a> (<a class="el" href="a00991.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a> *ctx, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:ga7414e3dc8215cedc1bffc6cf576d7d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a block of data using CBC mode and a key within the ATECC608A. <a class="el" href="a00991.html#gabc41b824cdc9b10efa46bcbf74850184" title="Initialize context for AES CBC operation.">atcab_aes_cbc_init()</a> should be called before the first use of this function.  <a href="a00991.html#ga7414e3dc8215cedc1bffc6cf576d7d1e">More...</a><br /></td></tr>
<tr class="separator:ga7414e3dc8215cedc1bffc6cf576d7d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c66e1b8b31bb87be3de6c9a9084c21e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga7c66e1b8b31bb87be3de6c9a9084c21e">atcab_aes_cbc_decrypt_block</a> (<a class="el" href="a00991.html#gaa702726fe160635225abc3c1ed421f7e">atca_aes_cbc_ctx_t</a> *ctx, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:ga7c66e1b8b31bb87be3de6c9a9084c21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a block of data using CBC mode and a key within the ATECC608A. <a class="el" href="a00991.html#gabc41b824cdc9b10efa46bcbf74850184" title="Initialize context for AES CBC operation.">atcab_aes_cbc_init()</a> should be called before the first use of this function.  <a href="a00991.html#ga7c66e1b8b31bb87be3de6c9a9084c21e">More...</a><br /></td></tr>
<tr class="separator:ga7c66e1b8b31bb87be3de6c9a9084c21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84506ff4105e63823c99527788d36d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga84506ff4105e63823c99527788d36d52">atcab_aes_cmac_init</a> (<a class="el" href="a00991.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a> *ctx, uint16_t key_id, uint8_t key_block)</td></tr>
<tr class="memdesc:ga84506ff4105e63823c99527788d36d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a CMAC calculation using an AES-128 key in the ATECC608A.  <a href="a00991.html#ga84506ff4105e63823c99527788d36d52">More...</a><br /></td></tr>
<tr class="separator:ga84506ff4105e63823c99527788d36d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf22e893c713890faeb9fa8784760b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga0cf22e893c713890faeb9fa8784760b1">atcab_aes_cmac_update</a> (<a class="el" href="a00991.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a> *ctx, const uint8_t *data, uint32_t data_size)</td></tr>
<tr class="memdesc:ga0cf22e893c713890faeb9fa8784760b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add data to an initialized CMAC calculation.  <a href="a00991.html#ga0cf22e893c713890faeb9fa8784760b1">More...</a><br /></td></tr>
<tr class="separator:ga0cf22e893c713890faeb9fa8784760b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0be51b283b107465dcf42758ca31687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gac0be51b283b107465dcf42758ca31687">atcab_aes_cmac_finish</a> (<a class="el" href="a00991.html#ga05fa8c58bf4408381db8871b0dca64b6">atca_aes_cmac_ctx_t</a> *ctx, uint8_t *cmac, uint32_t cmac_size)</td></tr>
<tr class="memdesc:gac0be51b283b107465dcf42758ca31687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish a CMAC operation returning the CMAC value.  <a href="a00991.html#gac0be51b283b107465dcf42758ca31687">More...</a><br /></td></tr>
<tr class="separator:gac0be51b283b107465dcf42758ca31687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db7d24f31dc2dd4805e3c433ae604ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga0db7d24f31dc2dd4805e3c433ae604ad">atcab_aes_ctr_init</a> (<a class="el" href="a00991.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx, uint16_t key_id, uint8_t key_block, uint8_t counter_size, const uint8_t *iv)</td></tr>
<tr class="memdesc:ga0db7d24f31dc2dd4805e3c433ae604ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt operation.  <a href="a00991.html#ga0db7d24f31dc2dd4805e3c433ae604ad">More...</a><br /></td></tr>
<tr class="separator:ga0db7d24f31dc2dd4805e3c433ae604ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7558905ea6a82c4bd50d4b99e954d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gae7558905ea6a82c4bd50d4b99e954d91">atcab_aes_ctr_init_rand</a> (<a class="el" href="a00991.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx, uint16_t key_id, uint8_t key_block, uint8_t counter_size, uint8_t *iv)</td></tr>
<tr class="memdesc:gae7558905ea6a82c4bd50d4b99e954d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV, which is common when starting an encrypt operation.  <a href="a00991.html#gae7558905ea6a82c4bd50d4b99e954d91">More...</a><br /></td></tr>
<tr class="separator:gae7558905ea6a82c4bd50d4b99e954d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76937b340e59be4dc1a30d8c7b76ebe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga76937b340e59be4dc1a30d8c7b76ebe0">atcab_aes_ctr_block</a> (<a class="el" href="a00991.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx, const uint8_t *input, uint8_t *output)</td></tr>
<tr class="memdesc:ga76937b340e59be4dc1a30d8c7b76ebe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a block of data using CTR mode and a key within the ATECC608A device. <a class="el" href="a00991.html#ga0db7d24f31dc2dd4805e3c433ae604ad" title="Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt op...">atcab_aes_ctr_init()</a> or <a class="el" href="a00991.html#gae7558905ea6a82c4bd50d4b99e954d91" title="Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV,...">atcab_aes_ctr_init_rand()</a> should be called before the first use of this function.  <a href="a00991.html#ga76937b340e59be4dc1a30d8c7b76ebe0">More...</a><br /></td></tr>
<tr class="separator:ga76937b340e59be4dc1a30d8c7b76ebe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7182e48a847f9c1b31f19c60f373e2da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga7182e48a847f9c1b31f19c60f373e2da">atcab_aes_ctr_encrypt_block</a> (<a class="el" href="a00991.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:ga7182e48a847f9c1b31f19c60f373e2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt a block of data using CTR mode and a key within the ATECC608A device. <a class="el" href="a00991.html#ga0db7d24f31dc2dd4805e3c433ae604ad" title="Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt op...">atcab_aes_ctr_init()</a> or <a class="el" href="a00991.html#gae7558905ea6a82c4bd50d4b99e954d91" title="Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV,...">atcab_aes_ctr_init_rand()</a> should be called before the first use of this function.  <a href="a00991.html#ga7182e48a847f9c1b31f19c60f373e2da">More...</a><br /></td></tr>
<tr class="separator:ga7182e48a847f9c1b31f19c60f373e2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9491be0c81fb18b021f71b9a6eda3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gada9491be0c81fb18b021f71b9a6eda3e">atcab_aes_ctr_decrypt_block</a> (<a class="el" href="a00991.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:gada9491be0c81fb18b021f71b9a6eda3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt a block of data using CTR mode and a key within the ATECC608A device. <a class="el" href="a00991.html#ga0db7d24f31dc2dd4805e3c433ae604ad" title="Initialize context for AES CTR operation with an existing IV, which is common when start a decrypt op...">atcab_aes_ctr_init()</a> or <a class="el" href="a00991.html#gae7558905ea6a82c4bd50d4b99e954d91" title="Initialize context for AES CTR operation with a random nonce and counter set to 0 as the IV,...">atcab_aes_ctr_init_rand()</a> should be called before the first use of this function.  <a href="a00991.html#gada9491be0c81fb18b021f71b9a6eda3e">More...</a><br /></td></tr>
<tr class="separator:gada9491be0c81fb18b021f71b9a6eda3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475b72450dcd21c822de5cb366197927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga475b72450dcd21c822de5cb366197927">atcab_aes_ctr_increment</a> (<a class="el" href="a00991.html#ga52b18f051752d214a2d5b485270f5b15">atca_aes_ctr_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:ga475b72450dcd21c822de5cb366197927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments AES CTR counter value.  <a href="a00991.html#ga475b72450dcd21c822de5cb366197927">More...</a><br /></td></tr>
<tr class="separator:ga475b72450dcd21c822de5cb366197927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga5ba49c05f7b3fb5acaf55df993ccd3ee">atcab_checkmac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, const uint8_t *response, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a MAC response with input values.  <a href="a00991.html#ga5ba49c05f7b3fb5acaf55df993ccd3ee">More...</a><br /></td></tr>
<tr class="separator:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaaaef242649206029e1c10ac6d1fb7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gabaaaef242649206029e1c10ac6d1fb7d">atcab_counter</a> (uint8_t mode, uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:gabaaaef242649206029e1c10ac6d1fb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Counter functions.  <a href="a00991.html#gabaaaef242649206029e1c10ac6d1fb7d">More...</a><br /></td></tr>
<tr class="separator:gabaaaef242649206029e1c10ac6d1fb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e510e056ea16a0a34b405b7ca378f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga6e510e056ea16a0a34b405b7ca378f16">atcab_counter_increment</a> (uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:ga6e510e056ea16a0a34b405b7ca378f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments one of the device's monotonic counters.  <a href="a00991.html#ga6e510e056ea16a0a34b405b7ca378f16">More...</a><br /></td></tr>
<tr class="separator:ga6e510e056ea16a0a34b405b7ca378f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee666028a097659af69cc828a6bd68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaeee666028a097659af69cc828a6bd68b">atcab_counter_read</a> (uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:gaeee666028a097659af69cc828a6bd68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one of the device's monotonic counters.  <a href="a00991.html#gaeee666028a097659af69cc828a6bd68b">More...</a><br /></td></tr>
<tr class="separator:gaeee666028a097659af69cc828a6bd68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b7b6d46868f0d63d195216ef9939b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga34b7b6d46868f0d63d195216ef9939b1">atcab_derivekey</a> (uint8_t mode, uint16_t key_id, const uint8_t *mac)</td></tr>
<tr class="memdesc:ga34b7b6d46868f0d63d195216ef9939b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key.  <a href="a00991.html#ga34b7b6d46868f0d63d195216ef9939b1">More...</a><br /></td></tr>
<tr class="separator:ga34b7b6d46868f0d63d195216ef9939b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga211c9405bb5049dd4a5da92d25c83f3c">atcab_ecdh_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *public_key, uint8_t *pms, uint8_t *out_nonce)</td></tr>
<tr class="memdesc:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base function for generating premaster secret key using ECDH.  <a href="a00991.html#ga211c9405bb5049dd4a5da92d25c83f3c">More...</a><br /></td></tr>
<tr class="separator:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc480ad2824df6309f4f370ffad15f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga6fc480ad2824df6309f4f370ffad15f9">atcab_ecdh</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms)</td></tr>
<tr class="memdesc:ga6fc480ad2824df6309f4f370ffad15f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is returned in the clear.  <a href="a00991.html#ga6fc480ad2824df6309f4f370ffad15f9">More...</a><br /></td></tr>
<tr class="separator:ga6fc480ad2824df6309f4f370ffad15f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e0c175cbcb5f794b12a8ec22485176"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gab6e0c175cbcb5f794b12a8ec22485176">atcab_ecdh_enc</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms, const uint8_t *read_key, uint16_t read_key_id)</td></tr>
<tr class="memdesc:gab6e0c175cbcb5f794b12a8ec22485176"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is read from the next slot.  <a href="a00991.html#gab6e0c175cbcb5f794b12a8ec22485176">More...</a><br /></td></tr>
<tr class="separator:gab6e0c175cbcb5f794b12a8ec22485176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975f7303086190d3b6f76c367583d622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga975f7303086190d3b6f76c367583d622">atcab_ecdh_ioenc</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms, const uint8_t *io_key)</td></tr>
<tr class="memdesc:ga975f7303086190d3b6f76c367583d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is returned encrypted using the IO protection key.  <a href="a00991.html#ga975f7303086190d3b6f76c367583d622">More...</a><br /></td></tr>
<tr class="separator:ga975f7303086190d3b6f76c367583d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac244b83b061ffd8ae3d59b5f973baa53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gac244b83b061ffd8ae3d59b5f973baa53">atcab_ecdh_tempkey</a> (const uint8_t *public_key, uint8_t *pms)</td></tr>
<tr class="memdesc:gac244b83b061ffd8ae3d59b5f973baa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in TempKey and the premaster secret is returned in the clear.  <a href="a00991.html#gac244b83b061ffd8ae3d59b5f973baa53">More...</a><br /></td></tr>
<tr class="separator:gac244b83b061ffd8ae3d59b5f973baa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaccb0c9d12154b0c5b917f89f233721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gafaccb0c9d12154b0c5b917f89f233721">atcab_ecdh_tempkey_ioenc</a> (const uint8_t *public_key, uint8_t *pms, const uint8_t *io_key)</td></tr>
<tr class="memdesc:gafaccb0c9d12154b0c5b917f89f233721"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in TempKey and the premaster secret is returned encrypted using the IO protection key.  <a href="a00991.html#gafaccb0c9d12154b0c5b917f89f233721">More...</a><br /></td></tr>
<tr class="separator:gafaccb0c9d12154b0c5b917f89f233721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga70751ea87f2cf913986bc7bca2cc661f">atcab_gendig</a> (uint8_t zone, uint16_t key_id, const uint8_t *other_data, uint8_t other_data_size)</td></tr>
<tr class="memdesc:ga70751ea87f2cf913986bc7bca2cc661f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to.  <a href="a00991.html#ga70751ea87f2cf913986bc7bca2cc661f">More...</a><br /></td></tr>
<tr class="separator:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaa8b6953ad2c7f749e61566fd38fe6903">atcab_genkey_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *other_data, uint8_t *public_key)</td></tr>
<tr class="memdesc:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which can generate a private key, compute a public key, nd/or compute a digest of a public key.  <a href="a00991.html#gaa8b6953ad2c7f749e61566fd38fe6903">More...</a><br /></td></tr>
<tr class="separator:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga617bdbdce7b5736351d93214d44c5b8f">atcab_genkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga617bdbdce7b5736351d93214d44c5b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which generates a new random private key in slot and returns the public key.  <a href="a00991.html#ga617bdbdce7b5736351d93214d44c5b8f">More...</a><br /></td></tr>
<tr class="separator:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2096a4618dd37c48ed48847fe63d844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gad2096a4618dd37c48ed48847fe63d844">atcab_get_pubkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:gad2096a4618dd37c48ed48847fe63d844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses GenKey command to calculate the public key from an existing private key in a slot.  <a href="a00991.html#gad2096a4618dd37c48ed48847fe63d844">More...</a><br /></td></tr>
<tr class="separator:gad2096a4618dd37c48ed48847fe63d844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga45f1d09a51f7a1f68916536ab5125b9d">atcab_hmac</a> (uint8_t mode, uint16_t key_id, uint8_t *digest)</td></tr>
<tr class="memdesc:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a HMAC command, which computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device.  <a href="a00991.html#ga45f1d09a51f7a1f68916536ab5125b9d">More...</a><br /></td></tr>
<tr class="separator:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806d07982fda5c30755af6b5b4ef9314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga806d07982fda5c30755af6b5b4ef9314">atcab_info_base</a> (uint8_t mode, uint16_t param2, uint8_t *out_data)</td></tr>
<tr class="memdesc:ga806d07982fda5c30755af6b5b4ef9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues an Info command, which return internal device information and can control GPIO and the persistent latch.  <a href="a00991.html#ga806d07982fda5c30755af6b5b4ef9314">More...</a><br /></td></tr>
<tr class="separator:ga806d07982fda5c30755af6b5b4ef9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e19ecd60be4c74665d9ec142e460771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga6e19ecd60be4c74665d9ec142e460771">atcab_info</a> (uint8_t *revision)</td></tr>
<tr class="memdesc:ga6e19ecd60be4c74665d9ec142e460771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the device revision (DevRev).  <a href="a00991.html#ga6e19ecd60be4c74665d9ec142e460771">More...</a><br /></td></tr>
<tr class="separator:ga6e19ecd60be4c74665d9ec142e460771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2649126606db8a0b64ae8e19d09f6600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga2649126606db8a0b64ae8e19d09f6600">atcab_info_set_latch</a> (bool state)</td></tr>
<tr class="memdesc:ga2649126606db8a0b64ae8e19d09f6600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to set the persistent latch state for an ATECC608A device.  <a href="a00991.html#ga2649126606db8a0b64ae8e19d09f6600">More...</a><br /></td></tr>
<tr class="separator:ga2649126606db8a0b64ae8e19d09f6600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga376b6ae92f14c60fba4ca5c6461e0b48">atcab_info_get_latch</a> (bool *state)</td></tr>
<tr class="memdesc:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the persistent latch current state for an ATECC608A device.  <a href="a00991.html#ga376b6ae92f14c60fba4ca5c6461e0b48">More...</a><br /></td></tr>
<tr class="separator:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a6c01492a76366f9402302b527c4e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga40a6c01492a76366f9402302b527c4e1">atcab_kdf</a> (uint8_t mode, uint16_t key_id, const uint32_t details, const uint8_t *message, uint8_t *out_data, uint8_t *out_nonce)</td></tr>
<tr class="memdesc:ga40a6c01492a76366f9402302b527c4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the KDF command, which derives a new key in PRF, AES, or HKDF modes.  <a href="a00991.html#ga40a6c01492a76366f9402302b527c4e1">More...</a><br /></td></tr>
<tr class="separator:ga40a6c01492a76366f9402302b527c4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d2895192d93c524f5dba92a492cdfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga25d2895192d93c524f5dba92a492cdfb">atcab_lock</a> (uint8_t mode, uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga25d2895192d93c524f5dba92a492cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked.  <a href="a00991.html#ga25d2895192d93c524f5dba92a492cdfb">More...</a><br /></td></tr>
<tr class="separator:ga25d2895192d93c524f5dba92a492cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga7cd67c03c7184ad041e2c0ad4f27db23">atcab_lock_config_zone</a> (void)</td></tr>
<tr class="memdesc:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the config zone.  <a href="a00991.html#ga7cd67c03c7184ad041e2c0ad4f27db23">More...</a><br /></td></tr>
<tr class="separator:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0698e0c55ad700fe57498321e842cb38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga0698e0c55ad700fe57498321e842cb38">atcab_lock_config_zone_crc</a> (uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga0698e0c55ad700fe57498321e842cb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the config zone with summary CRC.  <a href="a00991.html#ga0698e0c55ad700fe57498321e842cb38">More...</a><br /></td></tr>
<tr class="separator:ga0698e0c55ad700fe57498321e842cb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga8020aa89a5bed09ad35320b78e0fb890">atcab_lock_data_zone</a> (void)</td></tr>
<tr class="memdesc:ga8020aa89a5bed09ad35320b78e0fb890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the data zone (slots and OTP).  <a href="a00991.html#ga8020aa89a5bed09ad35320b78e0fb890">More...</a><br /></td></tr>
<tr class="separator:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaf29e398e2aca927ab4606aa1ec0308c6">atcab_lock_data_zone_crc</a> (uint16_t summary_crc)</td></tr>
<tr class="memdesc:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the data zone (slots and OTP) with summary CRC.  <a href="a00991.html#gaf29e398e2aca927ab4606aa1ec0308c6">More...</a><br /></td></tr>
<tr class="separator:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958190a9182d1b54f82fbca8216406ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga958190a9182d1b54f82fbca8216406ea">atcab_lock_data_slot</a> (uint16_t slot)</td></tr>
<tr class="memdesc:ga958190a9182d1b54f82fbca8216406ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1).  <a href="a00991.html#ga958190a9182d1b54f82fbca8216406ea">More...</a><br /></td></tr>
<tr class="separator:ga958190a9182d1b54f82fbca8216406ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga98cb802fbb5d78cd552bb05c21d6c791">atcab_mac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, uint8_t *digest)</td></tr>
<tr class="memdesc:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes MAC command, which computes a SHA-256 digest of a key stored in the device, a challenge, and other information on the device.  <a href="a00991.html#ga98cb802fbb5d78cd552bb05c21d6c791">More...</a><br /></td></tr>
<tr class="separator:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaf8e10791759a8a5e5dcd82774f4895d6">atcab_nonce_base</a> (uint8_t mode, uint16_t zero, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Nonce command, which loads a random or fixed nonce/data into the device for use by subsequent commands.  <a href="a00991.html#gaf8e10791759a8a5e5dcd82774f4895d6">More...</a><br /></td></tr>
<tr class="separator:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2293df1c1c794496790bae25d3844fa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga2293df1c1c794496790bae25d3844fa5">atcab_nonce</a> (const uint8_t *num_in)</td></tr>
<tr class="memdesc:ga2293df1c1c794496790bae25d3844fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to initialize TempKey to a specified value.  <a href="a00991.html#ga2293df1c1c794496790bae25d3844fa5">More...</a><br /></td></tr>
<tr class="separator:ga2293df1c1c794496790bae25d3844fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2239ae3a87c341a48aa108bd82a58552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga2239ae3a87c341a48aa108bd82a58552">atcab_nonce_load</a> (uint8_t target, const uint8_t *num_in, uint16_t num_in_size)</td></tr>
<tr class="memdesc:ga2239ae3a87c341a48aa108bd82a58552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to load one of the device's internal buffers with a fixed value.  <a href="a00991.html#ga2239ae3a87c341a48aa108bd82a58552">More...</a><br /></td></tr>
<tr class="separator:ga2239ae3a87c341a48aa108bd82a58552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaed67d447d547c67b7b8be6b958d1fb5c">atcab_nonce_rand</a> (const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number.  <a href="a00991.html#gaed67d447d547c67b7b8be6b958d1fb5c">More...</a><br /></td></tr>
<tr class="separator:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114a721517c95d5ba5fcac5b226669d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga114a721517c95d5ba5fcac5b226669d6">atcab_challenge</a> (const uint8_t *num_in)</td></tr>
<tr class="memdesc:ga114a721517c95d5ba5fcac5b226669d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to initialize TempKey to a specified value.  <a href="a00991.html#ga114a721517c95d5ba5fcac5b226669d6">More...</a><br /></td></tr>
<tr class="separator:ga114a721517c95d5ba5fcac5b226669d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadde4309089c569fd87c24a1a2326cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaadde4309089c569fd87c24a1a2326cd4">atcab_challenge_seed_update</a> (const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaadde4309089c569fd87c24a1a2326cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random challenge combining a host nonce (num_in) and a device random number.  <a href="a00991.html#gaadde4309089c569fd87c24a1a2326cd4">More...</a><br /></td></tr>
<tr class="separator:gaadde4309089c569fd87c24a1a2326cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01e8e785073d8655de9116e7df8e7b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gad01e8e785073d8655de9116e7df8e7b5">atcab_priv_write</a> (uint16_t key_id, const uint8_t priv_key[36], uint16_t write_key_id, const uint8_t write_key[32])</td></tr>
<tr class="memdesc:gad01e8e785073d8655de9116e7df8e7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes PrivWrite command, to write externally generated ECC private keys into the device.  <a href="a00991.html#gad01e8e785073d8655de9116e7df8e7b5">More...</a><br /></td></tr>
<tr class="separator:gad01e8e785073d8655de9116e7df8e7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa442396dfbb89e59dfca837b565cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga4fa442396dfbb89e59dfca837b565cec">atcab_random</a> (uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga4fa442396dfbb89e59dfca837b565cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Random command, which generates a 32 byte random number from the CryptoAuth device.  <a href="a00991.html#ga4fa442396dfbb89e59dfca837b565cec">More...</a><br /></td></tr>
<tr class="separator:ga4fa442396dfbb89e59dfca837b565cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga3ce01f02f456c08891ca1d67cd3ed0eb">atcab_read_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads either 4 or 32 bytes of data from a given slot, configuration zone, or the OTP zone.  <a href="a00991.html#ga3ce01f02f456c08891ca1d67cd3ed0eb">More...</a><br /></td></tr>
<tr class="separator:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefce484222bdbedef37787a9b10d4426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaefce484222bdbedef37787a9b10d4426">atcab_is_locked</a> (uint8_t zone, bool *is_locked)</td></tr>
<tr class="memdesc:gaefce484222bdbedef37787a9b10d4426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the configuration zone to see if the specified zone is locked.  <a href="a00991.html#gaefce484222bdbedef37787a9b10d4426">More...</a><br /></td></tr>
<tr class="separator:gaefce484222bdbedef37787a9b10d4426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802de50265ff91dc30dd7c93d9e026e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga802de50265ff91dc30dd7c93d9e026e1">atcab_is_slot_locked</a> (uint16_t slot, bool *is_locked)</td></tr>
<tr class="memdesc:ga802de50265ff91dc30dd7c93d9e026e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the configuration zone to see if the specified slot is locked.  <a href="a00991.html#ga802de50265ff91dc30dd7c93d9e026e1">More...</a><br /></td></tr>
<tr class="separator:ga802de50265ff91dc30dd7c93d9e026e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga750704332198726725a327344f4f7dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga750704332198726725a327344f4f7dd5">atcab_read_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset, uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:ga750704332198726725a327344f4f7dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to read an arbitrary number of bytes from any zone configured for clear reads.  <a href="a00991.html#ga750704332198726725a327344f4f7dd5">More...</a><br /></td></tr>
<tr class="separator:ga750704332198726725a327344f4f7dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga96c434878e1f435e2cda5b0b5fec444f">atcab_read_serial_number</a> (uint8_t *serial_number)</td></tr>
<tr class="memdesc:ga96c434878e1f435e2cda5b0b5fec444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the 9 byte serial number of the device from the config zone.  <a href="a00991.html#ga96c434878e1f435e2cda5b0b5fec444f">More...</a><br /></td></tr>
<tr class="separator:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga782ca1e5b1574b2b6793c841be22b28b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga782ca1e5b1574b2b6793c841be22b28b">atcab_read_pubkey</a> (uint16_t slot, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga782ca1e5b1574b2b6793c841be22b28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read an ECC P256 public key from a slot configured for clear reads.  <a href="a00991.html#ga782ca1e5b1574b2b6793c841be22b28b">More...</a><br /></td></tr>
<tr class="separator:ga782ca1e5b1574b2b6793c841be22b28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga098c4c2c724b90b7e2f4ecf12b9530b7">atcab_read_sig</a> (uint16_t slot, uint8_t *sig)</td></tr>
<tr class="memdesc:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read a 64 byte ECDSA P256 signature from a slot configured for clear reads.  <a href="a00991.html#ga098c4c2c724b90b7e2f4ecf12b9530b7">More...</a><br /></td></tr>
<tr class="separator:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga8ef47330eef6bc72ae8f7a8ef026dae3">atcab_read_config_zone</a> (uint8_t *config_data)</td></tr>
<tr class="memdesc:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read the complete device configuration zone.  <a href="a00991.html#ga8ef47330eef6bc72ae8f7a8ef026dae3">More...</a><br /></td></tr>
<tr class="separator:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gadb91d2c3601b95f0ad413cf84a4dfd87">atcab_cmp_config_zone</a> (uint8_t *config_data, bool *same_config)</td></tr>
<tr class="memdesc:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a specified configuration zone with the configuration zone currently on the device.  <a href="a00991.html#gadb91d2c3601b95f0ad413cf84a4dfd87">More...</a><br /></td></tr>
<tr class="separator:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778a262b86fa1f8a38139cbae34376e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga778a262b86fa1f8a38139cbae34376e4">atcab_read_enc</a> (uint16_t key_id, uint8_t block, uint8_t *data, const uint8_t *enc_key, const uint16_t enc_key_id)</td></tr>
<tr class="memdesc:ga778a262b86fa1f8a38139cbae34376e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command on a slot configured for encrypted reads and decrypts the data to return it as plaintext.  <a href="a00991.html#ga778a262b86fa1f8a38139cbae34376e4">More...</a><br /></td></tr>
<tr class="separator:ga778a262b86fa1f8a38139cbae34376e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9506331ea7d454fe3c9b2585128c77aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga9506331ea7d454fe3c9b2585128c77aa">atcab_secureboot</a> (uint8_t mode, uint16_t param2, const uint8_t *digest, const uint8_t *signature, uint8_t *mac)</td></tr>
<tr class="memdesc:ga9506331ea7d454fe3c9b2585128c77aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Secure Boot command, which provides support for secure boot of an external MCU or MPU.  <a href="a00991.html#ga9506331ea7d454fe3c9b2585128c77aa">More...</a><br /></td></tr>
<tr class="separator:ga9506331ea7d454fe3c9b2585128c77aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga5c11f2012a03ec79cb46de8e03ed0534">atcab_secureboot_mac</a> (uint8_t mode, const uint8_t *digest, const uint8_t *signature, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Secure Boot command with encrypted digest and validated MAC response using the IO protection key.  <a href="a00991.html#ga5c11f2012a03ec79cb46de8e03ed0534">More...</a><br /></td></tr>
<tr class="separator:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaeb4a36bc6992612cc3b1f950c0d020b7">atcab_selftest</a> (uint8_t mode, uint16_t param2, uint8_t *result)</td></tr>
<tr class="memdesc:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the SelfTest command, which performs a test of one or more of the cryptographic engines within the ATECC608A chip.  <a href="a00991.html#gaeb4a36bc6992612cc3b1f950c0d020b7">More...</a><br /></td></tr>
<tr class="separator:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gab3a32e171ca1c30bd31a216b32c9b5a4">atcab_sha_base</a> (uint8_t mode, uint16_t length, const uint8_t *data_in, uint8_t *data_out, uint16_t *data_out_size)</td></tr>
<tr class="memdesc:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command, which computes a SHA-256 or HMAC/SHA-256 digest for general purpose use by the host system.  <a href="a00991.html#gab3a32e171ca1c30bd31a216b32c9b5a4">More...</a><br /></td></tr>
<tr class="separator:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gae0a7ef89fce4cbd0ee1c76759cd93b9a">atcab_sha_start</a> (void)</td></tr>
<tr class="memdesc:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to initialize SHA-256 calculation engine.  <a href="a00991.html#gae0a7ef89fce4cbd0ee1c76759cd93b9a">More...</a><br /></td></tr>
<tr class="separator:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga39bd70baa7a4c7f4849fcf8b94d4d949">atcab_sha_update</a> (const uint8_t *message)</td></tr>
<tr class="memdesc:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to add 64 bytes of message data to the current context.  <a href="a00991.html#ga39bd70baa7a4c7f4849fcf8b94d4d949">More...</a><br /></td></tr>
<tr class="separator:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db86704035048066a370815b657234d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga1db86704035048066a370815b657234d">atcab_sha_end</a> (uint8_t *digest, uint16_t length, const uint8_t *message)</td></tr>
<tr class="memdesc:ga1db86704035048066a370815b657234d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to complete SHA-256 or HMAC/SHA-256 operation.  <a href="a00991.html#ga1db86704035048066a370815b657234d">More...</a><br /></td></tr>
<tr class="separator:ga1db86704035048066a370815b657234d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d1db50562642ce511fa7cbd384c2ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga74d1db50562642ce511fa7cbd384c2ab">atcab_sha_read_context</a> (uint8_t *context, uint16_t *context_size)</td></tr>
<tr class="memdesc:ga74d1db50562642ce511fa7cbd384c2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to read the SHA-256 context back. Only for ATECC608A with SHA-256 contexts. HMAC not supported.  <a href="a00991.html#ga74d1db50562642ce511fa7cbd384c2ab">More...</a><br /></td></tr>
<tr class="separator:ga74d1db50562642ce511fa7cbd384c2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga070fa80ac0d76f6816d9f7affbcfb120">atcab_sha_write_context</a> (const uint8_t *context, uint16_t context_size)</td></tr>
<tr class="memdesc:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to write (restore) a SHA-256 context into the the device. Only supported for ATECC608A with SHA-256 contexts.  <a href="a00991.html#ga070fa80ac0d76f6816d9f7affbcfb120">More...</a><br /></td></tr>
<tr class="separator:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d269ccdafd08519a899a8aebf53df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga31d269ccdafd08519a899a8aebf53df1">atcab_sha</a> (uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga31d269ccdafd08519a899a8aebf53df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute a SHA-256 digest.  <a href="a00991.html#ga31d269ccdafd08519a899a8aebf53df1">More...</a><br /></td></tr>
<tr class="separator:ga31d269ccdafd08519a899a8aebf53df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf8b665fe1712626a480742c2daa16b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga4bf8b665fe1712626a480742c2daa16b">atcab_hw_sha2_256</a> (const uint8_t *data, size_t data_size, uint8_t *digest)</td></tr>
<tr class="memdesc:ga4bf8b665fe1712626a480742c2daa16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute a SHA-256 digest.  <a href="a00991.html#ga4bf8b665fe1712626a480742c2daa16b">More...</a><br /></td></tr>
<tr class="separator:ga4bf8b665fe1712626a480742c2daa16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade49e7746864105730fa7d531645ff62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gade49e7746864105730fa7d531645ff62">atcab_hw_sha2_256_init</a> (<a class="el" href="a00991.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:gade49e7746864105730fa7d531645ff62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a SHA context for performing a hardware SHA-256 operation on a device. Note that only one SHA operation can be run at a time.  <a href="a00991.html#gade49e7746864105730fa7d531645ff62">More...</a><br /></td></tr>
<tr class="separator:gade49e7746864105730fa7d531645ff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga67f2ce6224651d9cc65e9915e35558bd">atcab_hw_sha2_256_update</a> (<a class="el" href="a00991.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:ga67f2ce6224651d9cc65e9915e35558bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add message data to a SHA context for performing a hardware SHA-256 operation on a device.  <a href="a00991.html#ga67f2ce6224651d9cc65e9915e35558bd">More...</a><br /></td></tr>
<tr class="separator:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga6ed7e645262fcc32b00d8a9facf09e91">atcab_hw_sha2_256_finish</a> (<a class="el" href="a00991.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx, uint8_t *digest)</td></tr>
<tr class="memdesc:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish SHA-256 digest for a SHA context for performing a hardware SHA-256 operation on a device.  <a href="a00991.html#ga6ed7e645262fcc32b00d8a9facf09e91">More...</a><br /></td></tr>
<tr class="separator:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga310a017cddce9ef05071cb619b4b6db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga310a017cddce9ef05071cb619b4b6db9">atcab_sha_hmac_init</a> (<a class="el" href="a00991.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *ctx, uint16_t key_slot)</td></tr>
<tr class="memdesc:ga310a017cddce9ef05071cb619b4b6db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to start an HMAC/SHA-256 operation.  <a href="a00991.html#ga310a017cddce9ef05071cb619b4b6db9">More...</a><br /></td></tr>
<tr class="separator:ga310a017cddce9ef05071cb619b4b6db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3343c160e80365b7e96bdfdc9b6365c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gae3343c160e80365b7e96bdfdc9b6365c">atcab_sha_hmac_update</a> (<a class="el" href="a00991.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:gae3343c160e80365b7e96bdfdc9b6365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to add an arbitrary amount of message data to a HMAC/SHA-256 operation.  <a href="a00991.html#gae3343c160e80365b7e96bdfdc9b6365c">More...</a><br /></td></tr>
<tr class="separator:gae3343c160e80365b7e96bdfdc9b6365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4be9972396b7cadb08dd8e2199daf08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaa4be9972396b7cadb08dd8e2199daf08">atcab_sha_hmac_finish</a> (<a class="el" href="a00991.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *ctx, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gaa4be9972396b7cadb08dd8e2199daf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to complete a HMAC/SHA-256 operation.  <a href="a00991.html#gaa4be9972396b7cadb08dd8e2199daf08">More...</a><br /></td></tr>
<tr class="separator:gaa4be9972396b7cadb08dd8e2199daf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae655ce06583c08169170102fbb0b55c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gae655ce06583c08169170102fbb0b55c9">atcab_sha_hmac</a> (const uint8_t *data, size_t data_size, uint16_t key_slot, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gae655ce06583c08169170102fbb0b55c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute an HMAC/SHA-256 operation.  <a href="a00991.html#gae655ce06583c08169170102fbb0b55c9">More...</a><br /></td></tr>
<tr class="separator:gae655ce06583c08169170102fbb0b55c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga5c1e598bf3d4d25b522f42d6038a4268">atcab_sign_base</a> (uint8_t mode, uint16_t key_id, uint8_t *signature)</td></tr>
<tr class="memdesc:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Sign command, which generates a signature using the ECDSA algorithm.  <a href="a00991.html#ga5c1e598bf3d4d25b522f42d6038a4268">More...</a><br /></td></tr>
<tr class="separator:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga69b8282d1b1e0c54b9a7d286fed503b8">atcab_sign</a> (uint16_t key_id, const uint8_t *msg, uint8_t *signature)</td></tr>
<tr class="memdesc:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices.  <a href="a00991.html#ga69b8282d1b1e0c54b9a7d286fed503b8">More...</a><br /></td></tr>
<tr class="separator:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga559add3e8b4f85a9d91fc0ed86aefa29">atcab_sign_internal</a> (uint16_t key_id, bool is_invalidate, bool is_full_sn, uint8_t *signature)</td></tr>
<tr class="memdesc:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command to sign an internally generated message.  <a href="a00991.html#ga559add3e8b4f85a9d91fc0ed86aefa29">More...</a><br /></td></tr>
<tr class="separator:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga416e4aeacf3acc35b1d5b76028c6947d">atcab_updateextra</a> (uint8_t mode, uint16_t new_value)</td></tr>
<tr class="memdesc:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes UpdateExtra command to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85).  <a href="a00991.html#ga416e4aeacf3acc35b1d5b76028c6947d">More...</a><br /></td></tr>
<tr class="separator:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694d921c7bc17a0e158ef96e3d476700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga694d921c7bc17a0e158ef96e3d476700">atcab_verify</a> (uint8_t mode, uint16_t key_id, const uint8_t *signature, const uint8_t *public_key, const uint8_t *other_data, uint8_t *mac)</td></tr>
<tr class="memdesc:ga694d921c7bc17a0e158ef96e3d476700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command.  <a href="a00991.html#ga694d921c7bc17a0e158ef96e3d476700">More...</a><br /></td></tr>
<tr class="separator:ga694d921c7bc17a0e158ef96e3d476700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3e18de900ba705192963d08b37f600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga2c3e18de900ba705192963d08b37f600">atcab_verify_extern</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga2c3e18de900ba705192963d08b37f600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices.  <a href="a00991.html#ga2c3e18de900ba705192963d08b37f600">More...</a><br /></td></tr>
<tr class="separator:ga2c3e18de900ba705192963d08b37f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga17bf17c4786be097a0bb111a6f9d8ca6">atcab_verify_extern_mac</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. This function is only available on the ATECC608A.  <a href="a00991.html#ga17bf17c4786be097a0bb111a6f9d8ca6">More...</a><br /></td></tr>
<tr class="separator:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8cc7670847805423ad591985eecd832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gae8cc7670847805423ad591985eecd832">atcab_verify_stored</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:gae8cc7670847805423ad591985eecd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices.  <a href="a00991.html#gae8cc7670847805423ad591985eecd832">More...</a><br /></td></tr>
<tr class="separator:gae8cc7670847805423ad591985eecd832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gaa52cdbbfd2f089d8eb42ef2640204ca7">atcab_verify_stored_mac</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with a public key stored in the device. This function is only available on the ATECC608A.  <a href="a00991.html#gaa52cdbbfd2f089d8eb42ef2640204ca7">More...</a><br /></td></tr>
<tr class="separator:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gacf9a0c7772ebb65b87c4a4788850702b">atcab_verify_validate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:gacf9a0c7772ebb65b87c4a4788850702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command in Validate mode to validate a public key stored in a slot.  <a href="a00991.html#gacf9a0c7772ebb65b87c4a4788850702b">More...</a><br /></td></tr>
<tr class="separator:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga9393b545b2fa1fdd539672a0428a30ab">atcab_verify_invalidate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:ga9393b545b2fa1fdd539672a0428a30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command in Invalidate mode which invalidates a previously validated public key stored in a slot.  <a href="a00991.html#ga9393b545b2fa1fdd539672a0428a30ab">More...</a><br /></td></tr>
<tr class="separator:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gabf2b29b4d3ae926b63c403d084380dbe">atcab_write</a> (uint8_t zone, uint16_t address, const uint8_t *value, const uint8_t *mac)</td></tr>
<tr class="memdesc:gabf2b29b4d3ae926b63c403d084380dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either one four byte word or a 32-byte block to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys.  <a href="a00991.html#gabf2b29b4d3ae926b63c403d084380dbe">More...</a><br /></td></tr>
<tr class="separator:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga1f5a6bbcf4f840803635fb8951b3a7e2">atcab_write_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either 4 or 32 bytes of data into a device zone.  <a href="a00991.html#ga1f5a6bbcf4f840803635fb8951b3a7e2">More...</a><br /></td></tr>
<tr class="separator:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac395a7e195aa3cf28b48de345755feb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gac395a7e195aa3cf28b48de345755feb0">atcab_write_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset_bytes, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gac395a7e195aa3cf28b48de345755feb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes data into the configuration, otp, or data zones with a given byte offset and length. Offset and length must be multiples of a word (4 bytes).  <a href="a00991.html#gac395a7e195aa3cf28b48de345755feb0">More...</a><br /></td></tr>
<tr class="separator:gac395a7e195aa3cf28b48de345755feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga47cbedeb3c3e9f7cbf2b9433cd60d1aa">atcab_write_pubkey</a> (uint16_t slot, const uint8_t *public_key)</td></tr>
<tr class="memdesc:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the write command to write a public key to a slot in the proper format.  <a href="a00991.html#ga47cbedeb3c3e9f7cbf2b9433cd60d1aa">More...</a><br /></td></tr>
<tr class="separator:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0777a86aa412a97b19cc72a12c171b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga0777a86aa412a97b19cc72a12c171b94">atcab_write_config_zone</a> (const uint8_t *config_data)</td></tr>
<tr class="memdesc:ga0777a86aa412a97b19cc72a12c171b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes the configuration zone.  <a href="a00991.html#ga0777a86aa412a97b19cc72a12c171b94">More...</a><br /></td></tr>
<tr class="separator:ga0777a86aa412a97b19cc72a12c171b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cf75d1be264ac1125087d76ee6344c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga14cf75d1be264ac1125087d76ee6344c">atcab_write_enc</a> (uint16_t key_id, uint8_t block, const uint8_t *data, const uint8_t *enc_key, const uint16_t enc_key_id)</td></tr>
<tr class="memdesc:ga14cf75d1be264ac1125087d76ee6344c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which performs an encrypted write of a 32 byte block into given slot.  <a href="a00991.html#ga14cf75d1be264ac1125087d76ee6344c">More...</a><br /></td></tr>
<tr class="separator:ga14cf75d1be264ac1125087d76ee6344c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25ca44957dff1c2df34607738ca3bf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00173.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#gab25ca44957dff1c2df34607738ca3bf7">atcab_write_config_counter</a> (uint16_t counter_id, uint32_t counter_value)</td></tr>
<tr class="memdesc:gab25ca44957dff1c2df34607738ca3bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize one of the monotonic counters in device with a specific value.  <a href="a00991.html#gab25ca44957dff1c2df34607738ca3bf7">More...</a><br /></td></tr>
<tr class="separator:gab25ca44957dff1c2df34607738ca3bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga692423e9c45adde594c36360756b8882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00988.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00991.html#ga692423e9c45adde594c36360756b8882">_gDevice</a></td></tr>
<tr class="separator:ga692423e9c45adde594c36360756b8882"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CryptoAuthLib Basic API methods - a simple crypto authentication API. These methods manage a global ATCADevice object behind the scenes. They also manage the wake/idle state transitions so callers don't need to. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2015-2018 Microchip Technology Inc. and its subsidiaries. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_f987fb6e7cf85d8e48d70ffe78b3ebc1.html">basic</a></li><li class="navelem"><a class="el" href="a00224.html">atca_basic.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>

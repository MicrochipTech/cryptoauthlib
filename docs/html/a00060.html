<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CryptoAuthLib: atca_basic.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CryptoAuthLib
   </div>
   <div id="projectbrief">Atmel CryptoAuthentication Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00060.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">atca_basic.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CryptoAuthLib Basic API methods. These methods provide a simpler way to access the core crypto methods. Their design center is around the most common modes and functions of each command rather than the complete implementation of each possible feature of the chip. If you need a feature not supplied in the Basic API, you can achieve the feature through the datasheet level command supplied through the ATCADevice and ATCACommand object.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="a00061_source.html">atca_basic.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="a00089_source.html">host/atca_host.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">hw_sha256_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a71478560014bace34a1ebdeab8875365"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html#a71478560014bace34a1ebdeab8875365">MAX_BUSES</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a71478560014bace34a1ebdeab8875365"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto discovery of crypto auth devices  <a href="#a71478560014bace34a1ebdeab8875365">More...</a><br /></td></tr>
<tr class="separator:a71478560014bace34a1ebdeab8875365"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga563f3d7c25ee88ff5b2c988f4eb59bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga563f3d7c25ee88ff5b2c988f4eb59bc3">atcab_version</a> (char *verstr)</td></tr>
<tr class="memdesc:ga563f3d7c25ee88ff5b2c988f4eb59bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a version string for the CryptoAuthLib release. The format of the version string returned is "yyyymmdd"  <a href="a00224.html#ga563f3d7c25ee88ff5b2c988f4eb59bc3">More...</a><br /></td></tr>
<tr class="separator:ga563f3d7c25ee88ff5b2c988f4eb59bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gacdc4fa3d2f2f6d197af8c10ab1f288b8">atcab_init</a> (<a class="el" href="a00046.html">ATCAIfaceCfg</a> *cfg)</td></tr>
<tr class="memdesc:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">atcab_init is called once for the life of the application and creates a global ATCADevice object used by Basic API. This method builds a global ATCADevice instance behinds the scenes that's used for all Basic API operations  <a href="a00224.html#gacdc4fa3d2f2f6d197af8c10ab1f288b8">More...</a><br /></td></tr>
<tr class="separator:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb5f2d8f7796c6d7e93d36a86dc3ce9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga1cb5f2d8f7796c6d7e93d36a86dc3ce9">atcab_init_device</a> (<a class="el" href="a00221.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> cadevice)</td></tr>
<tr class="memdesc:ga1cb5f2d8f7796c6d7e93d36a86dc3ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">atcab_init_device can be used to initialize the global ATCADevice object to point to one of your choosing for use with all the atcab_ basic API.  <a href="a00224.html#ga1cb5f2d8f7796c6d7e93d36a86dc3ce9">More...</a><br /></td></tr>
<tr class="separator:ga1cb5f2d8f7796c6d7e93d36a86dc3ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga3a061c1f96bb641b36fc56b6cb2dd4e4">atcab_release</a> (void)</td></tr>
<tr class="memdesc:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">release (free) the global ATCADevice instance. This must be called in order to release or free up the interface.  <a href="a00224.html#ga3a061c1f96bb641b36fc56b6cb2dd4e4">More...</a><br /></td></tr>
<tr class="separator:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00221.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga4af82005556c549c30e1c4bd35d4f4e4">atcab_get_device</a> (void)</td></tr>
<tr class="memdesc:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a way to get the global device object. Generally for more sophisticated users of atca  <a href="a00224.html#ga4af82005556c549c30e1c4bd35d4f4e4">More...</a><br /></td></tr>
<tr class="separator:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3bc620aedd9322d160eece0d8d20c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gad3bc620aedd9322d160eece0d8d20c82">atcab_wakeup</a> (void)</td></tr>
<tr class="memdesc:gad3bc620aedd9322d160eece0d8d20c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">wakeup the CryptoAuth device  <a href="a00224.html#gad3bc620aedd9322d160eece0d8d20c82">More...</a><br /></td></tr>
<tr class="separator:gad3bc620aedd9322d160eece0d8d20c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaf47433a371b9fcb8d65a4214cd9e4fa0">atcab_idle</a> (void)</td></tr>
<tr class="memdesc:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">idle the CryptoAuth device  <a href="a00224.html#gaf47433a371b9fcb8d65a4214cd9e4fa0">More...</a><br /></td></tr>
<tr class="separator:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9475e032c388144c5a0df45d1df182a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga9475e032c388144c5a0df45d1df182a5">atcab_sleep</a> (void)</td></tr>
<tr class="memdesc:ga9475e032c388144c5a0df45d1df182a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke sleep on the CryptoAuth device  <a href="a00224.html#ga9475e032c388144c5a0df45d1df182a5">More...</a><br /></td></tr>
<tr class="separator:ga9475e032c388144c5a0df45d1df182a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabed2c204c79b094e064385c85f3c1b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gabed2c204c79b094e064385c85f3c1b3d">atcab_cfg_discover</a> (<a class="el" href="a00046.html">ATCAIfaceCfg</a> cfgArray[], int maxIfaces)</td></tr>
<tr class="separator:gabed2c204c79b094e064385c85f3c1b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e19ecd60be4c74665d9ec142e460771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga6e19ecd60be4c74665d9ec142e460771">atcab_info</a> (uint8_t *revision)</td></tr>
<tr class="memdesc:ga6e19ecd60be4c74665d9ec142e460771"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the device revision information  <a href="a00224.html#ga6e19ecd60be4c74665d9ec142e460771">More...</a><br /></td></tr>
<tr class="separator:ga6e19ecd60be4c74665d9ec142e460771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa442396dfbb89e59dfca837b565cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga4fa442396dfbb89e59dfca837b565cec">atcab_random</a> (uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga4fa442396dfbb89e59dfca837b565cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a 32 byte random number from the CryptoAuth device.  <a href="a00224.html#ga4fa442396dfbb89e59dfca837b565cec">More...</a><br /></td></tr>
<tr class="separator:ga4fa442396dfbb89e59dfca837b565cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaa8b6953ad2c7f749e61566fd38fe6903">atcab_genkey_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *other_data, uint8_t *public_key)</td></tr>
<tr class="memdesc:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="mdescLeft">&#160;</td><td class="mdescRight">This command can generate a private key, compute a public key, and/or compute a digest of of a public key.  <a href="a00224.html#gaa8b6953ad2c7f749e61566fd38fe6903">More...</a><br /></td></tr>
<tr class="separator:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga617bdbdce7b5736351d93214d44c5b8f">atcab_genkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga617bdbdce7b5736351d93214d44c5b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new random private key and return the public key.  <a href="a00224.html#ga617bdbdce7b5736351d93214d44c5b8f">More...</a><br /></td></tr>
<tr class="separator:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10c899d3b8cfb1b9ada47f925b8cbce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gab10c899d3b8cfb1b9ada47f925b8cbce">atcab_nonce</a> (const uint8_t *tempkey)</td></tr>
<tr class="memdesc:gab10c899d3b8cfb1b9ada47f925b8cbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a pass-through Nonce command to initialize TempKey to the specified value.  <a href="a00224.html#gab10c899d3b8cfb1b9ada47f925b8cbce">More...</a><br /></td></tr>
<tr class="separator:gab10c899d3b8cfb1b9ada47f925b8cbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf162c6327e0cc2e43fc6b483dbc21a32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaf162c6327e0cc2e43fc6b483dbc21a32">atcab_nonce_rand</a> (const uint8_t *seed, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaf162c6327e0cc2e43fc6b483dbc21a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize TempKey with a random Nonce.  <a href="a00224.html#gaf162c6327e0cc2e43fc6b483dbc21a32">More...</a><br /></td></tr>
<tr class="separator:gaf162c6327e0cc2e43fc6b483dbc21a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b13f56c701eb5564e555923a621ae85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga8b13f56c701eb5564e555923a621ae85">atcab_challenge</a> (const uint8_t *challenge)</td></tr>
<tr class="memdesc:ga8b13f56c701eb5564e555923a621ae85"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a challenge to the device (a pass-through nonce)  <a href="a00224.html#ga8b13f56c701eb5564e555923a621ae85">More...</a><br /></td></tr>
<tr class="separator:ga8b13f56c701eb5564e555923a621ae85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc5691ab3a484d7a07cbbc214e6a8f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga4fc5691ab3a484d7a07cbbc214e6a8f5">atcab_challenge_seed_update</a> (const uint8_t *seed, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga4fc5691ab3a484d7a07cbbc214e6a8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a challenge to the device (a seed update nonce)  <a href="a00224.html#ga4fc5691ab3a484d7a07cbbc214e6a8f5">More...</a><br /></td></tr>
<tr class="separator:ga4fc5691ab3a484d7a07cbbc214e6a8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff392b11a0d00fefa2dff30ec7040fc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaff392b11a0d00fefa2dff30ec7040fc6">atcab_nonce_base</a> (uint8_t mode, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaff392b11a0d00fefa2dff30ec7040fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Nonce command generates a nonce for use by subsequent commands.  <a href="a00224.html#gaff392b11a0d00fefa2dff30ec7040fc6">More...</a><br /></td></tr>
<tr class="separator:gaff392b11a0d00fefa2dff30ec7040fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga96c434878e1f435e2cda5b0b5fec444f">atcab_read_serial_number</a> (uint8_t *serial_number)</td></tr>
<tr class="memdesc:ga96c434878e1f435e2cda5b0b5fec444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the serial number of the device  <a href="a00224.html#ga96c434878e1f435e2cda5b0b5fec444f">More...</a><br /></td></tr>
<tr class="separator:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023ff586b49807c67f5af587f7480a3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga023ff586b49807c67f5af587f7480a3f">atcab_verify</a> (uint8_t mode, uint16_t key_id, const uint8_t *signature, const uint8_t *public_key, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga023ff586b49807c67f5af587f7480a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Verify command takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command.  <a href="a00224.html#ga023ff586b49807c67f5af587f7480a3f">More...</a><br /></td></tr>
<tr class="separator:ga023ff586b49807c67f5af587f7480a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3e18de900ba705192963d08b37f600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga2c3e18de900ba705192963d08b37f600">atcab_verify_extern</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga2c3e18de900ba705192963d08b37f600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. Uses the CryptoAuthentication hardware instead of software.  <a href="a00224.html#ga2c3e18de900ba705192963d08b37f600">More...</a><br /></td></tr>
<tr class="separator:ga2c3e18de900ba705192963d08b37f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8cc7670847805423ad591985eecd832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gae8cc7670847805423ad591985eecd832">atcab_verify_stored</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:gae8cc7670847805423ad591985eecd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify a signature and message (ECDSA verify operation) against a public key stored in a specified slot.  <a href="a00224.html#gae8cc7670847805423ad591985eecd832">More...</a><br /></td></tr>
<tr class="separator:gae8cc7670847805423ad591985eecd832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gacf9a0c7772ebb65b87c4a4788850702b">atcab_verify_validate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:gacf9a0c7772ebb65b87c4a4788850702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a public key stored in a slot.  <a href="a00224.html#gacf9a0c7772ebb65b87c4a4788850702b">More...</a><br /></td></tr>
<tr class="separator:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga9393b545b2fa1fdd539672a0428a30ab">atcab_verify_invalidate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:ga9393b545b2fa1fdd539672a0428a30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate a public key stored in a slot.  <a href="a00224.html#ga9393b545b2fa1fdd539672a0428a30ab">More...</a><br /></td></tr>
<tr class="separator:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9201defb41eaea6eb37df9a20db791ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga9201defb41eaea6eb37df9a20db791ca">atcab_ecdh</a> (uint16_t key_id, const uint8_t *pubkey, uint8_t *pms)</td></tr>
<tr class="memdesc:ga9201defb41eaea6eb37df9a20db791ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with premaster secret returned in the response.  <a href="a00224.html#ga9201defb41eaea6eb37df9a20db791ca">More...</a><br /></td></tr>
<tr class="separator:ga9201defb41eaea6eb37df9a20db791ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c5daaedc57ca6655e5c23bb2b6f2cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gae2c5daaedc57ca6655e5c23bb2b6f2cd">atcab_ecdh_enc</a> (uint16_t key_id, const uint8_t *pubkey, uint8_t *pms, const uint8_t *enckey, uint16_t enckeyid)</td></tr>
<tr class="memdesc:gae2c5daaedc57ca6655e5c23bb2b6f2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with premaster secret read (encrypted) from next slot.  <a href="a00224.html#gae2c5daaedc57ca6655e5c23bb2b6f2cd">More...</a><br /></td></tr>
<tr class="separator:gae2c5daaedc57ca6655e5c23bb2b6f2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gabdfeb1f8d28039e9b30d4e39b8caa33a">atcab_get_addr</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint16_t *addr)</td></tr>
<tr class="memdesc:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the address given the zone, slot, block, and offset.  <a href="a00224.html#gabdfeb1f8d28039e9b30d4e39b8caa33a">More...</a><br /></td></tr>
<tr class="separator:gabdfeb1f8d28039e9b30d4e39b8caa33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga7a823d2a391bf80ff336eb2ccbd37412">atcab_get_zone_size</a> (uint8_t zone, uint16_t slot, size_t *size)</td></tr>
<tr class="memdesc:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified zone in bytes.  <a href="a00224.html#ga7a823d2a391bf80ff336eb2ccbd37412">More...</a><br /></td></tr>
<tr class="separator:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac244d4c7a4bbb4004d30ba680c5136ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gac244d4c7a4bbb4004d30ba680c5136ad">atcab_is_slot_locked</a> (uint8_t slot, bool *is_locked)</td></tr>
<tr class="memdesc:gac244d4c7a4bbb4004d30ba680c5136ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query to see if the specified slot is locked.  <a href="a00224.html#gac244d4c7a4bbb4004d30ba680c5136ad">More...</a><br /></td></tr>
<tr class="separator:gac244d4c7a4bbb4004d30ba680c5136ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefce484222bdbedef37787a9b10d4426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaefce484222bdbedef37787a9b10d4426">atcab_is_locked</a> (uint8_t zone, bool *is_locked)</td></tr>
<tr class="memdesc:gaefce484222bdbedef37787a9b10d4426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query to see if the specified zone is locked.  <a href="a00224.html#gaefce484222bdbedef37787a9b10d4426">More...</a><br /></td></tr>
<tr class="separator:gaefce484222bdbedef37787a9b10d4426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gabf2b29b4d3ae926b63c403d084380dbe">atcab_write</a> (uint8_t zone, uint16_t address, const uint8_t *value, const uint8_t *mac)</td></tr>
<tr class="memdesc:gabf2b29b4d3ae926b63c403d084380dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Write command writes either one four byte word or an 8-word block of 32 bytes to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys.  <a href="a00224.html#gabf2b29b4d3ae926b63c403d084380dbe">More...</a><br /></td></tr>
<tr class="separator:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga1f5a6bbcf4f840803635fb8951b3a7e2">atcab_write_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write either 4 or 32 bytes of data into a device zone.  <a href="a00224.html#ga1f5a6bbcf4f840803635fb8951b3a7e2">More...</a><br /></td></tr>
<tr class="separator:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga3ce01f02f456c08891ca1d67cd3ed0eb">atcab_read_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">read either 4 or 32 bytes of data into given slot  <a href="a00224.html#ga3ce01f02f456c08891ca1d67cd3ed0eb">More...</a><br /></td></tr>
<tr class="separator:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dac8b8c0a82dac68da82724129e278d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga8dac8b8c0a82dac68da82724129e278d">atcab_read_enc</a> (uint16_t key_id, uint8_t block, uint8_t *data, const uint8_t *enckey, const uint16_t enckeyid)</td></tr>
<tr class="memdesc:ga8dac8b8c0a82dac68da82724129e278d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 32 bytes of data from the given slot. The function returns clear text bytes. Encrypted bytes are read over the wire, then subsequently decrypted Data zone must be locked and the slot configuration must be set to encrypted read for the block to be successfully read.  <a href="a00224.html#ga8dac8b8c0a82dac68da82724129e278d">More...</a><br /></td></tr>
<tr class="separator:ga8dac8b8c0a82dac68da82724129e278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf099dc4245d056db33547fe1d49b541b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaf099dc4245d056db33547fe1d49b541b">atcab_write_enc</a> (uint16_t key_id, uint8_t block, const uint8_t *data, const uint8_t *enckey, const uint16_t enckeyid)</td></tr>
<tr class="memdesc:gaf099dc4245d056db33547fe1d49b541b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 32 bytes of data into given slot. The function takes clear text bytes, but encrypts them for writing over the wire Data zone must be locked and the slot configuration must be set to encrypted write for the block to be successfully written.  <a href="a00224.html#gaf099dc4245d056db33547fe1d49b541b">More...</a><br /></td></tr>
<tr class="separator:gaf099dc4245d056db33547fe1d49b541b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga8ef47330eef6bc72ae8f7a8ef026dae3">atcab_read_config_zone</a> (uint8_t *config_data)</td></tr>
<tr class="memdesc:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">given an SHA configuration zone buffer and dev type, read its parts from the device's config zone  <a href="a00224.html#ga8ef47330eef6bc72ae8f7a8ef026dae3">More...</a><br /></td></tr>
<tr class="separator:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0777a86aa412a97b19cc72a12c171b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga0777a86aa412a97b19cc72a12c171b94">atcab_write_config_zone</a> (const uint8_t *config_data)</td></tr>
<tr class="memdesc:ga0777a86aa412a97b19cc72a12c171b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the configuration zone skipping the lock values.  <a href="a00224.html#ga0777a86aa412a97b19cc72a12c171b94">More...</a><br /></td></tr>
<tr class="separator:ga0777a86aa412a97b19cc72a12c171b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gadb91d2c3601b95f0ad413cf84a4dfd87">atcab_cmp_config_zone</a> (uint8_t *config_data, bool *same_config)</td></tr>
<tr class="memdesc:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares all writable bytes in the configuration zone that is passed in to the bytes on the device.  <a href="a00224.html#gadb91d2c3601b95f0ad413cf84a4dfd87">More...</a><br /></td></tr>
<tr class="separator:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d2895192d93c524f5dba92a492cdfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga25d2895192d93c524f5dba92a492cdfb">atcab_lock</a> (uint8_t mode, uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga25d2895192d93c524f5dba92a492cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked.  <a href="a00224.html#ga25d2895192d93c524f5dba92a492cdfb">More...</a><br /></td></tr>
<tr class="separator:ga25d2895192d93c524f5dba92a492cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga7cd67c03c7184ad041e2c0ad4f27db23">atcab_lock_config_zone</a> (void)</td></tr>
<tr class="memdesc:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the config zone.  <a href="a00224.html#ga7cd67c03c7184ad041e2c0ad4f27db23">More...</a><br /></td></tr>
<tr class="separator:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad758b97819383fbee19336bf9f9540aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gad758b97819383fbee19336bf9f9540aa">atcab_lock_config_zone_crc</a> (uint16_t crc)</td></tr>
<tr class="memdesc:gad758b97819383fbee19336bf9f9540aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the config zone with summary CRC.  <a href="a00224.html#gad758b97819383fbee19336bf9f9540aa">More...</a><br /></td></tr>
<tr class="separator:gad758b97819383fbee19336bf9f9540aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga8020aa89a5bed09ad35320b78e0fb890">atcab_lock_data_zone</a> (void)</td></tr>
<tr class="memdesc:ga8020aa89a5bed09ad35320b78e0fb890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the data zone (slots and OTP).  <a href="a00224.html#ga8020aa89a5bed09ad35320b78e0fb890">More...</a><br /></td></tr>
<tr class="separator:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d94968da77056acf8098ef47b8fd53e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga2d94968da77056acf8098ef47b8fd53e">atcab_lock_data_zone_crc</a> (uint16_t crc)</td></tr>
<tr class="memdesc:ga2d94968da77056acf8098ef47b8fd53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the data zone (slots and OTP) with summary CRC.  <a href="a00224.html#ga2d94968da77056acf8098ef47b8fd53e">More...</a><br /></td></tr>
<tr class="separator:ga2d94968da77056acf8098ef47b8fd53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb1cbc186d12e50b9d86dd8e0100604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga7fb1cbc186d12e50b9d86dd8e0100604">atcab_lock_data_slot</a> (uint8_t slot)</td></tr>
<tr class="memdesc:ga7fb1cbc186d12e50b9d86dd8e0100604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1).  <a href="a00224.html#ga7fb1cbc186d12e50b9d86dd8e0100604">More...</a><br /></td></tr>
<tr class="separator:ga7fb1cbc186d12e50b9d86dd8e0100604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga5c1e598bf3d4d25b522f42d6038a4268">atcab_sign_base</a> (uint8_t mode, uint16_t key_id, uint8_t *signature)</td></tr>
<tr class="memdesc:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Sign command generates a signature using the ECDSA algorithm.  <a href="a00224.html#ga5c1e598bf3d4d25b522f42d6038a4268">More...</a><br /></td></tr>
<tr class="separator:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga69b8282d1b1e0c54b9a7d286fed503b8">atcab_sign</a> (uint16_t key_id, const uint8_t *msg, uint8_t *signature)</td></tr>
<tr class="memdesc:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign a 32-byte message using the private key in the specified slot.  <a href="a00224.html#ga69b8282d1b1e0c54b9a7d286fed503b8">More...</a><br /></td></tr>
<tr class="separator:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga559add3e8b4f85a9d91fc0ed86aefa29">atcab_sign_internal</a> (uint16_t key_id, bool is_invalidate, bool is_full_sn, uint8_t *signature)</td></tr>
<tr class="memdesc:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sign an internally generated message.  <a href="a00224.html#ga559add3e8b4f85a9d91fc0ed86aefa29">More...</a><br /></td></tr>
<tr class="separator:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga70751ea87f2cf913986bc7bca2cc661f">atcab_gendig</a> (uint8_t zone, uint16_t key_id, const uint8_t *other_data, uint8_t other_data_size)</td></tr>
<tr class="memdesc:ga70751ea87f2cf913986bc7bca2cc661f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to.  <a href="a00224.html#ga70751ea87f2cf913986bc7bca2cc661f">More...</a><br /></td></tr>
<tr class="separator:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddea9705cb35400bf64c43f8ef3ec368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaddea9705cb35400bf64c43f8ef3ec368">atcab_read_sig</a> (uint8_t slot8toF, uint8_t *sig)</td></tr>
<tr class="memdesc:gaddea9705cb35400bf64c43f8ef3ec368"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads a signature found in one of slots 8 through F.  <a href="a00224.html#gaddea9705cb35400bf64c43f8ef3ec368">More...</a><br /></td></tr>
<tr class="separator:gaddea9705cb35400bf64c43f8ef3ec368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2096a4618dd37c48ed48847fe63d844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gad2096a4618dd37c48ed48847fe63d844">atcab_get_pubkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:gad2096a4618dd37c48ed48847fe63d844"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a public key found in a designated slot. The slot must be configured as a slot with a private key. This method will use GenKey to generate the corresponding public key from the private key in the given slot.  <a href="a00224.html#gad2096a4618dd37c48ed48847fe63d844">More...</a><br /></td></tr>
<tr class="separator:gad2096a4618dd37c48ed48847fe63d844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1aabfb0aa6876304c7c096a27902a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gade1aabfb0aa6876304c7c096a27902a5">atcab_priv_write</a> (uint16_t key_id, const uint8_t priv_key[36], uint8_t write_key_slot, const uint8_t write_key[32])</td></tr>
<tr class="memdesc:gade1aabfb0aa6876304c7c096a27902a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write a P256 private key in given slot using mac computation  <a href="a00224.html#gade1aabfb0aa6876304c7c096a27902a5">More...</a><br /></td></tr>
<tr class="separator:gade1aabfb0aa6876304c7c096a27902a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09f2d9d7d0bfa4badfcea82b9b02f151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga09f2d9d7d0bfa4badfcea82b9b02f151">atcab_write_pubkey</a> (uint16_t slot8toF, const uint8_t *pubkey)</td></tr>
<tr class="memdesc:ga09f2d9d7d0bfa4badfcea82b9b02f151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a pub key from to a data slot.  <a href="a00224.html#ga09f2d9d7d0bfa4badfcea82b9b02f151">More...</a><br /></td></tr>
<tr class="separator:ga09f2d9d7d0bfa4badfcea82b9b02f151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe236622ac65a2ccbf313d4a1971c258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gabe236622ac65a2ccbf313d4a1971c258">atcab_read_pubkey</a> (uint16_t slot8toF, uint8_t *pubkey)</td></tr>
<tr class="memdesc:gabe236622ac65a2ccbf313d4a1971c258"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads a pub key from a readable data slot versus atcab_get_pubkey which generates a pubkey from a private key slot  <a href="a00224.html#gabe236622ac65a2ccbf313d4a1971c258">More...</a><br /></td></tr>
<tr class="separator:gabe236622ac65a2ccbf313d4a1971c258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac395a7e195aa3cf28b48de345755feb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gac395a7e195aa3cf28b48de345755feb0">atcab_write_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset_bytes, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gac395a7e195aa3cf28b48de345755feb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into config, otp, or data zone with a given byte offset and length. Offset and length must be multiples of a word (4 bytes).  <a href="a00224.html#gac395a7e195aa3cf28b48de345755feb0">More...</a><br /></td></tr>
<tr class="separator:gac395a7e195aa3cf28b48de345755feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef5ecc82d845eaebdf50a58ac489e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gafef5ecc82d845eaebdf50a58ac489e66">atcab_read_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset_bytes, uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gafef5ecc82d845eaebdf50a58ac489e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from config, otp, or data zone with a given byte offset and length.  <a href="a00224.html#gafef5ecc82d845eaebdf50a58ac489e66">More...</a><br /></td></tr>
<tr class="separator:gafef5ecc82d845eaebdf50a58ac489e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga98cb802fbb5d78cd552bb05c21d6c791">atcab_mac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, uint8_t *digest)</td></tr>
<tr class="memdesc:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a 32 byte MAC from the CryptoAuth device given a key ID and a challenge.  <a href="a00224.html#ga98cb802fbb5d78cd552bb05c21d6c791">More...</a><br /></td></tr>
<tr class="separator:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga5ba49c05f7b3fb5acaf55df993ccd3ee">atcab_checkmac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, const uint8_t *response, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a MAC response with input values.  <a href="a00224.html#ga5ba49c05f7b3fb5acaf55df993ccd3ee">More...</a><br /></td></tr>
<tr class="separator:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga45f1d09a51f7a1f68916536ab5125b9d">atcab_hmac</a> (uint8_t mode, uint16_t key_id, uint8_t *digest)</td></tr>
<tr class="memdesc:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HMAC command computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device. The output of this command is the output of the HMAC algorithm computed over this key and message. If the message includes the serial number of the device, the response is said to be "diversified".  <a href="a00224.html#ga45f1d09a51f7a1f68916536ab5125b9d">More...</a><br /></td></tr>
<tr class="separator:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd8da6a78188668976dcce54f54bbc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gaebd8da6a78188668976dcce54f54bbc9">atcab_derivekey</a> (uint8_t mode, uint16_t target_key, uint8_t *mac)</td></tr>
<tr class="memdesc:gaebd8da6a78188668976dcce54f54bbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a DeriveKey Command to the device.  <a href="a00224.html#gaebd8da6a78188668976dcce54f54bbc9">More...</a><br /></td></tr>
<tr class="separator:gaebd8da6a78188668976dcce54f54bbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98100897f317f28b768a484080056e7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga98100897f317f28b768a484080056e7d">atcab_sha_base</a> (uint8_t mode, uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga98100897f317f28b768a484080056e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SHA command computes a SHA-256 digest for general purpose use by the system. Any message length can be accommodated. The system is responsible for sending the pad and length bytes with the last block for ATSHA devices.  <a href="a00224.html#ga98100897f317f28b768a484080056e7d">More...</a><br /></td></tr>
<tr class="separator:ga98100897f317f28b768a484080056e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gae0a7ef89fce4cbd0ee1c76759cd93b9a">atcab_sha_start</a> (void)</td></tr>
<tr class="memdesc:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize SHA-256 calculation engine.  <a href="a00224.html#gae0a7ef89fce4cbd0ee1c76759cd93b9a">More...</a><br /></td></tr>
<tr class="separator:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga39bd70baa7a4c7f4849fcf8b94d4d949">atcab_sha_update</a> (const uint8_t *message)</td></tr>
<tr class="memdesc:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the message to be digested.  <a href="a00224.html#ga39bd70baa7a4c7f4849fcf8b94d4d949">More...</a><br /></td></tr>
<tr class="separator:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db86704035048066a370815b657234d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga1db86704035048066a370815b657234d">atcab_sha_end</a> (uint8_t *digest, uint16_t length, const uint8_t *message)</td></tr>
<tr class="memdesc:ga1db86704035048066a370815b657234d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SHA-256 calculation is complete.  <a href="a00224.html#ga1db86704035048066a370815b657234d">More...</a><br /></td></tr>
<tr class="separator:ga1db86704035048066a370815b657234d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d269ccdafd08519a899a8aebf53df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga31d269ccdafd08519a899a8aebf53df1">atcab_sha</a> (uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga31d269ccdafd08519a899a8aebf53df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a SHA-256 digest.  <a href="a00224.html#ga31d269ccdafd08519a899a8aebf53df1">More...</a><br /></td></tr>
<tr class="separator:ga31d269ccdafd08519a899a8aebf53df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade49e7746864105730fa7d531645ff62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#gade49e7746864105730fa7d531645ff62">atcab_hw_sha2_256_init</a> (<a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx)</td></tr>
<tr class="separator:gade49e7746864105730fa7d531645ff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga67f2ce6224651d9cc65e9915e35558bd">atcab_hw_sha2_256_update</a> (<a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="separator:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a374d0ed07002b4c20eb49592641c95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga0a374d0ed07002b4c20eb49592641c95">atcab_hw_sha2_256_finish</a> (<a class="el" href="a00224.html#ga530ccce9f617be7dbf3661e19a4c0546">atca_sha256_ctx_t</a> *ctx, uint8_t digest[<a class="el" href="a00225.html#ga86364f6d07b86740f3170d9d1ca60641">ATCA_SHA2_256_DIGEST_SIZE</a>])</td></tr>
<tr class="separator:ga0a374d0ed07002b4c20eb49592641c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f26091b8754321ab55440a9e6b01ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga89f26091b8754321ab55440a9e6b01ae">atcab_hw_sha2_256</a> (const uint8_t *data, size_t data_size, uint8_t digest[<a class="el" href="a00225.html#ga86364f6d07b86740f3170d9d1ca60641">ATCA_SHA2_256_DIGEST_SIZE</a>])</td></tr>
<tr class="separator:ga89f26091b8754321ab55440a9e6b01ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00094.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html#ga416e4aeacf3acc35b1d5b76028c6947d">atcab_updateextra</a> (uint8_t mode, uint16_t new_value)</td></tr>
<tr class="memdesc:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UpdateExtra command is used to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85).  <a href="a00224.html#ga416e4aeacf3acc35b1d5b76028c6947d">More...</a><br /></td></tr>
<tr class="separator:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a41b849746a2e5b6a21f42e9e47c52e4a"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html#a41b849746a2e5b6a21f42e9e47c52e4a">atca_version</a> [] = { &quot;20170701&quot; }</td></tr>
<tr class="separator:a41b849746a2e5b6a21f42e9e47c52e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692423e9c45adde594c36360756b8882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00221.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html#a692423e9c45adde594c36360756b8882">_gDevice</a> = NULL</td></tr>
<tr class="memdesc:a692423e9c45adde594c36360756b8882"><td class="mdescLeft">&#160;</td><td class="mdescRight">basic API methods are all prefixed with atcab_ (Atmel CryptoAuth Basic) the fundamental premise of the basic API is it is based on a single interface instance and that instance is global, so all basic API commands assume that one global device is the one to operate on.  <a href="#a692423e9c45adde594c36360756b8882">More...</a><br /></td></tr>
<tr class="separator:a692423e9c45adde594c36360756b8882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1391bdc8a0f521bef17b5fa3c6d66fd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00068.html#aebeafc249bfe2b00b6809d5c328841d9">ATCACommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html#a1391bdc8a0f521bef17b5fa3c6d66fd9">_gCommandObj</a> = NULL</td></tr>
<tr class="separator:a1391bdc8a0f521bef17b5fa3c6d66fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62938ec29051aa795e582b228dc333bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00222.html#ga75c11126f3fe81df3d6c27f5bb393303">ATCAIface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html#a62938ec29051aa795e582b228dc333bb">_gIface</a> = NULL</td></tr>
<tr class="separator:a62938ec29051aa795e582b228dc333bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CryptoAuthLib Basic API methods. These methods provide a simpler way to access the core crypto methods. Their design center is around the most common modes and functions of each command rather than the complete implementation of each possible feature of the chip. If you need a feature not supplied in the Basic API, you can achieve the feature through the datasheet level command supplied through the ATCADevice and ATCACommand object. </p>
<p>One primary assumption to all atcab_ routines is that the caller manages the wake/sleep/idle bracket so prior to calling the atcab_ routine, the chip should be awake; the routine will manage wake/sleep/idle within the function and leave the chip awake upon return.</p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2017 Microchip Technology Inc. and its subsidiaries (Microchip). All rights reserved. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a71478560014bace34a1ebdeab8875365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_BUSES&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>auto discovery of crypto auth devices </p>
<p>Calls interface discovery functions and fills in cfgArray up to the maximum number of configurations either found or the size of the array. The cfgArray can have a mixture of interface types (ie: some I2C, some SWI or UART) depending upon which interfaces you've enabled</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cfgArray,ptr</td><td>to an array of interface configs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max,maximum</td><td>size of cfgArray </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_STATUS </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a1391bdc8a0f521bef17b5fa3c6d66fd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00068.html#aebeafc249bfe2b00b6809d5c328841d9">ATCACommand</a> _gCommandObj = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a692423e9c45adde594c36360756b8882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00221.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> _gDevice = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>basic API methods are all prefixed with atcab_ (Atmel CryptoAuth Basic) the fundamental premise of the basic API is it is based on a single interface instance and that instance is global, so all basic API commands assume that one global device is the one to operate on. </p>

</div>
</div>
<a class="anchor" id="a62938ec29051aa795e582b228dc333bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00222.html#ga75c11126f3fe81df3d6c27f5bb393303">ATCAIface</a> _gIface = NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a41b849746a2e5b6a21f42e9e47c52e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char atca_version[] = { &quot;20170701&quot; }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_f987fb6e7cf85d8e48d70ffe78b3ebc1.html">basic</a></li><li class="navelem"><a class="el" href="a00060.html">atca_basic.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>

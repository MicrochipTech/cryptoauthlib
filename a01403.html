<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CryptoAuthLib: Basic Crypto API methods (atcab_)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="microchip.png"/></td>
  <td id="projectalign">
   <div id="projectname">CryptoAuthLib<span id="projectnumber">&#160;v3.7.4</span>
   </div>
   <div id="projectbrief">Microchip CryptoAuthentication Library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a01403.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Basic Crypto API methods (atcab_)</div></div>
</div><!--header-->
<div class="contents">

<p>These methods provide the most convenient, simple API to CryptoAuth chips.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga55663492574ac6d6b6cb5ad39c632031"><td class="memItemLeft" align="right" valign="top"><a id="ga55663492574ac6d6b6cb5ad39c632031" name="ga55663492574ac6d6b6cb5ad39c632031"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_get_addr</b>(...)&#160;&#160;&#160;<a class="el" href="a01408.html#gae51a67781e9e4618e669db1c999e6ec2">calib_get_addr</a>(__VA_ARGS__)</td></tr>
<tr class="separator:ga55663492574ac6d6b6cb5ad39c632031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7f8ac7b0159edf31a623dbaac0ae97"><td class="memItemLeft" align="right" valign="top"><a id="gadf7f8ac7b0159edf31a623dbaac0ae97" name="gadf7f8ac7b0159edf31a623dbaac0ae97"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>atca_execute_command</b>(...)&#160;&#160;&#160;<a class="el" href="a00377.html#a19fc558e09f03a2f8f5ee89b1e396b2e">calib_execute_command</a>(__VA_ARGS__)</td></tr>
<tr class="separator:gadf7f8ac7b0159edf31a623dbaac0ae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d37a5da1c43d44e49c4e6614d133c7e"><td class="memItemLeft" align="right" valign="top"><a id="ga3d37a5da1c43d44e49c4e6614d133c7e" name="ga3d37a5da1c43d44e49c4e6614d133c7e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SHA_CONTEXT_MAX_SIZE</b>&#160;&#160;&#160;(109)</td></tr>
<tr class="separator:ga3d37a5da1c43d44e49c4e6614d133c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaff701132013eaac5600dd9fd6253505d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaff701132013eaac5600dd9fd6253505d">atcab_version</a> (char *ver_str)</td></tr>
<tr class="memdesc:gaff701132013eaac5600dd9fd6253505d"><td class="mdescLeft">&#160;</td><td class="mdescRight">basic API methods are all prefixed with atcab_ (CryptoAuthLib Basic) the fundamental premise of the basic API is it is based on a single interface instance and that instance is global, so all basic API commands assume that one global device is the one to operate on.  <br /></td></tr>
<tr class="separator:gaff701132013eaac5600dd9fd6253505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d392a2b2ae7a51907cb724f0465741"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaa1d392a2b2ae7a51907cb724f0465741">atcab_init_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> *device, <a class="el" href="a01480.html">ATCAIfaceCfg</a> *cfg)</td></tr>
<tr class="memdesc:gaa1d392a2b2ae7a51907cb724f0465741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a ATCADevice context.  <br /></td></tr>
<tr class="separator:gaa1d392a2b2ae7a51907cb724f0465741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gacdc4fa3d2f2f6d197af8c10ab1f288b8">atcab_init</a> (<a class="el" href="a01480.html">ATCAIfaceCfg</a> *cfg)</td></tr>
<tr class="memdesc:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a global ATCADevice object used by Basic API.  <br /></td></tr>
<tr class="separator:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gab22d2a32e6c32c14c4e58ce794ff3ec4">atcab_init_device</a> (<a class="el" href="a01472.html">ATCADevice</a> ca_device)</td></tr>
<tr class="memdesc:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the global ATCADevice object to point to one of your choosing for use with all the atcab_ basic API.  <br /></td></tr>
<tr class="separator:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga147803646532319e585a0fe7a6c028ef"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga147803646532319e585a0fe7a6c028ef">atcab_release_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> *device)</td></tr>
<tr class="memdesc:ga147803646532319e585a0fe7a6c028ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">release (free) the an ATCADevice instance.  <br /></td></tr>
<tr class="separator:ga147803646532319e585a0fe7a6c028ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga3a061c1f96bb641b36fc56b6cb2dd4e4">atcab_release</a> (void)</td></tr>
<tr class="memdesc:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">release (free) the global ATCADevice instance. This must be called in order to release or free up the interface.  <br /></td></tr>
<tr class="separator:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga4af82005556c549c30e1c4bd35d4f4e4">atcab_get_device</a> (void)</td></tr>
<tr class="memdesc:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global device object.  <br /></td></tr>
<tr class="separator:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4882d4c30f1af2d1aab24a0c465f181d"><td class="memItemLeft" align="right" valign="top">ATCADeviceType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga4882d4c30f1af2d1aab24a0c465f181d">atcab_get_device_type_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device)</td></tr>
<tr class="memdesc:ga4882d4c30f1af2d1aab24a0c465f181d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the selected device type of rthe device context.  <br /></td></tr>
<tr class="separator:ga4882d4c30f1af2d1aab24a0c465f181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b02163fab87313b81dd7f51345d3eb6"><td class="memItemLeft" align="right" valign="top">ATCADeviceType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga2b02163fab87313b81dd7f51345d3eb6">atcab_get_device_type</a> (void)</td></tr>
<tr class="memdesc:ga2b02163fab87313b81dd7f51345d3eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current device type configured for the global ATCADevice.  <br /></td></tr>
<tr class="separator:ga2b02163fab87313b81dd7f51345d3eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga775bea13de8cc26e61a34ada48358568"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga775bea13de8cc26e61a34ada48358568">atcab_get_device_address</a> (<a class="el" href="a01472.html">ATCADevice</a> device)</td></tr>
<tr class="memdesc:ga775bea13de8cc26e61a34ada48358568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current device address based on the configured device and interface.  <br /></td></tr>
<tr class="separator:ga775bea13de8cc26e61a34ada48358568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e74da1e2ef3168e48bbc89c44b16d2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga6e74da1e2ef3168e48bbc89c44b16d2f">atcab_is_ca_device</a> (ATCADeviceType dev_type)</td></tr>
<tr class="memdesc:ga6e74da1e2ef3168e48bbc89c44b16d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the device is cryptoauth device.  <br /></td></tr>
<tr class="separator:ga6e74da1e2ef3168e48bbc89c44b16d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973437347c3261df0b116fec9ee9c378"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga973437347c3261df0b116fec9ee9c378">atcab_is_ca2_device</a> (ATCADeviceType dev_type)</td></tr>
<tr class="memdesc:ga973437347c3261df0b116fec9ee9c378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the device is cryptoauth device.  <br /></td></tr>
<tr class="separator:ga973437347c3261df0b116fec9ee9c378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4e462d88600ee2d36c3c5bf699fde3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gadd4e462d88600ee2d36c3c5bf699fde3">atcab_is_ta_device</a> (ATCADeviceType dev_type)</td></tr>
<tr class="memdesc:gadd4e462d88600ee2d36c3c5bf699fde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the device is Trust Anchor device.  <br /></td></tr>
<tr class="separator:gadd4e462d88600ee2d36c3c5bf699fde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf944ef6828e73f64cd0c327aa5a5e0e"><td class="memItemLeft" align="right" valign="top"><a id="gacf944ef6828e73f64cd0c327aa5a5e0e" name="gacf944ef6828e73f64cd0c327aa5a5e0e"></a>
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_pbkdf2_sha256_ext</b> (<a class="el" href="a01472.html">ATCADevice</a> device, const uint32_t iter, const uint16_t slot, const uint8_t *salt, const size_t salt_len, uint8_t *result, size_t result_len)</td></tr>
<tr class="separator:gacf944ef6828e73f64cd0c327aa5a5e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffacce78575dc87106d402d74178da95"><td class="memItemLeft" align="right" valign="top"><a id="gaffacce78575dc87106d402d74178da95" name="gaffacce78575dc87106d402d74178da95"></a>
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_pbkdf2_sha256</b> (const uint32_t iter, const uint16_t slot, const uint8_t *salt, const size_t salt_len, uint8_t *result, size_t result_len)</td></tr>
<tr class="separator:gaffacce78575dc87106d402d74178da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3bc620aedd9322d160eece0d8d20c82"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gad3bc620aedd9322d160eece0d8d20c82">atcab_wakeup</a> (void)</td></tr>
<tr class="memdesc:gad3bc620aedd9322d160eece0d8d20c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">wakeup the CryptoAuth device  <br /></td></tr>
<tr class="separator:gad3bc620aedd9322d160eece0d8d20c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaf47433a371b9fcb8d65a4214cd9e4fa0">atcab_idle</a> (void)</td></tr>
<tr class="memdesc:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">idle the CryptoAuth device  <br /></td></tr>
<tr class="separator:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9475e032c388144c5a0df45d1df182a5"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga9475e032c388144c5a0df45d1df182a5">atcab_sleep</a> (void)</td></tr>
<tr class="memdesc:ga9475e032c388144c5a0df45d1df182a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke sleep on the CryptoAuth device  <br /></td></tr>
<tr class="separator:ga9475e032c388144c5a0df45d1df182a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga7a823d2a391bf80ff336eb2ccbd37412">atcab_get_zone_size</a> (uint8_t zone, uint16_t slot, size_t *size)</td></tr>
<tr class="memdesc:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified zone in bytes.  <br /></td></tr>
<tr class="separator:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65cf773e03aed93e2a1437f13511a91"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gad65cf773e03aed93e2a1437f13511a91">atcab_get_zone_size_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint8_t zone, uint16_t slot, size_t *size)</td></tr>
<tr class="memdesc:gad65cf773e03aed93e2a1437f13511a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified zone in bytes.  <br /></td></tr>
<tr class="separator:gad65cf773e03aed93e2a1437f13511a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad115ce255664a48b80e90ea19c156b79"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gad115ce255664a48b80e90ea19c156b79">atcab_aes</a> (uint8_t mode, uint16_t key_id, const uint8_t *aes_in, uint8_t *aes_out)</td></tr>
<tr class="memdesc:gad115ce255664a48b80e90ea19c156b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the AES-128 encrypt, decrypt, or GFM calculation.  <br /></td></tr>
<tr class="separator:gad115ce255664a48b80e90ea19c156b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gacc9a58dc49f91674213f34fa7bbd05e1">atcab_aes_encrypt</a> (uint16_t key_id, uint8_t key_block, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 encrypt operation with a key in the device.  <br /></td></tr>
<tr class="separator:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5c5cba4f9be5bc0e4b1c5691f60e4ba"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaa5c5cba4f9be5bc0e4b1c5691f60e4ba">atcab_aes_encrypt_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint16_t key_id, uint8_t key_block, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gaa5c5cba4f9be5bc0e4b1c5691f60e4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 encrypt operation with a key in the device.  <br /></td></tr>
<tr class="separator:gaa5c5cba4f9be5bc0e4b1c5691f60e4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9658e84055727e6357cf7ef636b4e398"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga9658e84055727e6357cf7ef636b4e398">atcab_aes_decrypt</a> (uint16_t key_id, uint8_t key_block, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:ga9658e84055727e6357cf7ef636b4e398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 decrypt operation with a key in the device.  <br /></td></tr>
<tr class="separator:ga9658e84055727e6357cf7ef636b4e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebaf49a3412181fa47ba3a761c5a2d5b"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaebaf49a3412181fa47ba3a761c5a2d5b">atcab_aes_decrypt_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint16_t key_id, uint8_t key_block, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:gaebaf49a3412181fa47ba3a761c5a2d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 decrypt operation with a key in the device.  <br /></td></tr>
<tr class="separator:gaebaf49a3412181fa47ba3a761c5a2d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5554940ed4c7c7e28652ce6923cf9314"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga5554940ed4c7c7e28652ce6923cf9314">atcab_aes_gfm</a> (const uint8_t *h, const uint8_t *input, uint8_t *output)</td></tr>
<tr class="memdesc:ga5554940ed4c7c7e28652ce6923cf9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a Galois Field Multiply (GFM) operation.  <br /></td></tr>
<tr class="separator:ga5554940ed4c7c7e28652ce6923cf9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4805112b62e86b5465e24648504dc374"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374">atcab_aes_gcm_init</a> (atca_aes_gcm_ctx_t *ctx, uint16_t key_id, uint8_t key_block, const uint8_t *iv, size_t iv_size)</td></tr>
<tr class="memdesc:ga4805112b62e86b5465e24648504dc374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt operation.  <br /></td></tr>
<tr class="separator:ga4805112b62e86b5465e24648504dc374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8742a7be77a2350c069c5c380ac4c635"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga8742a7be77a2350c069c5c380ac4c635">atcab_aes_gcm_init_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, uint16_t key_id, uint8_t key_block, const uint8_t *iv, size_t iv_size)</td></tr>
<tr class="memdesc:ga8742a7be77a2350c069c5c380ac4c635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt operation.  <br /></td></tr>
<tr class="separator:ga8742a7be77a2350c069c5c380ac4c635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad71a5720ceaddf2c76476aead5f0c3e6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6">atcab_aes_gcm_init_rand</a> (atca_aes_gcm_ctx_t *ctx, uint16_t key_id, uint8_t key_block, size_t rand_size, const uint8_t *free_field, size_t free_field_size, uint8_t *iv)</td></tr>
<tr class="memdesc:gad71a5720ceaddf2c76476aead5f0c3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) field, which is common when starting an encrypt operation.  <br /></td></tr>
<tr class="separator:gad71a5720ceaddf2c76476aead5f0c3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d6fd831a8125a366504a0ab77b62da8"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga1d6fd831a8125a366504a0ab77b62da8">atcab_aes_gcm_aad_update</a> (atca_aes_gcm_ctx_t *ctx, const uint8_t *aad, uint32_t aad_size)</td></tr>
<tr class="memdesc:ga1d6fd831a8125a366504a0ab77b62da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process Additional Authenticated Data (AAD) using GCM mode and a key within the ATECC608 device.  <br /></td></tr>
<tr class="separator:ga1d6fd831a8125a366504a0ab77b62da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c6666c7b4d077fb058adc4971da2160"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga1c6666c7b4d077fb058adc4971da2160">atcab_aes_gcm_aad_update_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, const uint8_t *aad, uint32_t aad_size)</td></tr>
<tr class="memdesc:ga1c6666c7b4d077fb058adc4971da2160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process Additional Authenticated Data (AAD) using GCM mode and a key within the ATECC608 device.  <br /></td></tr>
<tr class="separator:ga1c6666c7b4d077fb058adc4971da2160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3fda8219d17d1b7bc50b1040399a47d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gab3fda8219d17d1b7bc50b1040399a47d">atcab_aes_gcm_encrypt_update</a> (atca_aes_gcm_ctx_t *ctx, const uint8_t *plaintext, uint32_t plaintext_size, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gab3fda8219d17d1b7bc50b1040399a47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function.  <br /></td></tr>
<tr class="separator:gab3fda8219d17d1b7bc50b1040399a47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac8b8555b03b50a118b70cb8387c24ae"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaac8b8555b03b50a118b70cb8387c24ae">atcab_aes_gcm_encrypt_update_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, const uint8_t *plaintext, uint32_t plaintext_size, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gaac8b8555b03b50a118b70cb8387c24ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function.  <br /></td></tr>
<tr class="separator:gaac8b8555b03b50a118b70cb8387c24ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2d38835826587970de3868ca48eaa4"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gada2d38835826587970de3868ca48eaa4">atcab_aes_gcm_encrypt_finish</a> (atca_aes_gcm_ctx_t *ctx, uint8_t *tag, size_t tag_size)</td></tr>
<tr class="memdesc:gada2d38835826587970de3868ca48eaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a GCM encrypt operation returning the authentication tag.  <br /></td></tr>
<tr class="separator:gada2d38835826587970de3868ca48eaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813fb67193a7c39d02ce7ad8d2d12123"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga813fb67193a7c39d02ce7ad8d2d12123">atcab_aes_gcm_encrypt_finish_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, uint8_t *tag, size_t tag_size)</td></tr>
<tr class="memdesc:ga813fb67193a7c39d02ce7ad8d2d12123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a GCM encrypt operation returning the authentication tag.  <br /></td></tr>
<tr class="separator:ga813fb67193a7c39d02ce7ad8d2d12123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad3270d8bebf6172dc02d0c7d9fb738"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga2ad3270d8bebf6172dc02d0c7d9fb738">atcab_aes_gcm_decrypt_update</a> (atca_aes_gcm_ctx_t *ctx, const uint8_t *ciphertext, uint32_t ciphertext_size, uint8_t *plaintext)</td></tr>
<tr class="memdesc:ga2ad3270d8bebf6172dc02d0c7d9fb738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function.  <br /></td></tr>
<tr class="separator:ga2ad3270d8bebf6172dc02d0c7d9fb738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac55fcbd824ffc9a30c6a5bbafb93aad2"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gac55fcbd824ffc9a30c6a5bbafb93aad2">atcab_aes_gcm_decrypt_update_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, const uint8_t *ciphertext, uint32_t ciphertext_size, uint8_t *plaintext)</td></tr>
<tr class="memdesc:gac55fcbd824ffc9a30c6a5bbafb93aad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function.  <br /></td></tr>
<tr class="separator:gac55fcbd824ffc9a30c6a5bbafb93aad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa86508958ff3d81f9bd8e79344537218"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaa86508958ff3d81f9bd8e79344537218">atcab_aes_gcm_decrypt_finish</a> (atca_aes_gcm_ctx_t *ctx, const uint8_t *tag, size_t tag_size, bool *is_verified)</td></tr>
<tr class="memdesc:gaa86508958ff3d81f9bd8e79344537218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a GCM decrypt operation verifying the authentication tag.  <br /></td></tr>
<tr class="separator:gaa86508958ff3d81f9bd8e79344537218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c5173c7529f898f251814133169ba1d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga9c5173c7529f898f251814133169ba1d">atcab_aes_gcm_decrypt_finish_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, const uint8_t *tag, size_t tag_size, bool *is_verified)</td></tr>
<tr class="memdesc:ga9c5173c7529f898f251814133169ba1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a GCM decrypt operation verifying the authentication tag.  <br /></td></tr>
<tr class="separator:ga9c5173c7529f898f251814133169ba1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga5ba49c05f7b3fb5acaf55df993ccd3ee">atcab_checkmac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, const uint8_t *response, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a MAC response with input values.  <br /></td></tr>
<tr class="separator:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad50eab1ee1abb18515e914a294668907"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gad50eab1ee1abb18515e914a294668907">atcab_checkmac_with_response_mac</a> (uint8_t mode, const uint8_t *challenge, const uint8_t *response, const uint8_t *other_data, uint8_t *mac)</td></tr>
<tr class="memdesc:gad50eab1ee1abb18515e914a294668907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a MAC response with input values.SHA105 device can generate optional mac Output response mac mode only supports in SHA105 device.  <br /></td></tr>
<tr class="separator:gad50eab1ee1abb18515e914a294668907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaaaef242649206029e1c10ac6d1fb7d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gabaaaef242649206029e1c10ac6d1fb7d">atcab_counter</a> (uint8_t mode, uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:gabaaaef242649206029e1c10ac6d1fb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Counter functions.  <br /></td></tr>
<tr class="separator:gabaaaef242649206029e1c10ac6d1fb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e510e056ea16a0a34b405b7ca378f16"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga6e510e056ea16a0a34b405b7ca378f16">atcab_counter_increment</a> (uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:ga6e510e056ea16a0a34b405b7ca378f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments one of the device's monotonic counters.  <br /></td></tr>
<tr class="separator:ga6e510e056ea16a0a34b405b7ca378f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee666028a097659af69cc828a6bd68b"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaeee666028a097659af69cc828a6bd68b">atcab_counter_read</a> (uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:gaeee666028a097659af69cc828a6bd68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one of the device's monotonic counters.  <br /></td></tr>
<tr class="separator:gaeee666028a097659af69cc828a6bd68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b7b6d46868f0d63d195216ef9939b1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga34b7b6d46868f0d63d195216ef9939b1">atcab_derivekey</a> (uint8_t mode, uint16_t key_id, const uint8_t *mac)</td></tr>
<tr class="memdesc:ga34b7b6d46868f0d63d195216ef9939b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key.  <br /></td></tr>
<tr class="separator:ga34b7b6d46868f0d63d195216ef9939b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5b5206bd54f7e7513a0c21a3ffbe31"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gabd5b5206bd54f7e7513a0c21a3ffbe31">atcab_derivekey_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint8_t mode, uint16_t key_id, const uint8_t *mac)</td></tr>
<tr class="memdesc:gabd5b5206bd54f7e7513a0c21a3ffbe31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key.  <br /></td></tr>
<tr class="separator:gabd5b5206bd54f7e7513a0c21a3ffbe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga211c9405bb5049dd4a5da92d25c83f3c">atcab_ecdh_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *public_key, uint8_t *pms, uint8_t *out_nonce)</td></tr>
<tr class="memdesc:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base function for generating premaster secret key using ECDH.  <br /></td></tr>
<tr class="separator:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc480ad2824df6309f4f370ffad15f9"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga6fc480ad2824df6309f4f370ffad15f9">atcab_ecdh</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms)</td></tr>
<tr class="memdesc:ga6fc480ad2824df6309f4f370ffad15f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is returned in the clear.  <br /></td></tr>
<tr class="separator:ga6fc480ad2824df6309f4f370ffad15f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e3ae10f0596d473f646074650904e6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga51e3ae10f0596d473f646074650904e6">atcab_ecdh_enc</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms, const uint8_t *read_key, uint16_t read_key_id, const uint8_t num_in[(20)])</td></tr>
<tr class="memdesc:ga51e3ae10f0596d473f646074650904e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is read from the next slot.  <br /></td></tr>
<tr class="separator:ga51e3ae10f0596d473f646074650904e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975f7303086190d3b6f76c367583d622"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga975f7303086190d3b6f76c367583d622">atcab_ecdh_ioenc</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms, const uint8_t *io_key)</td></tr>
<tr class="memdesc:ga975f7303086190d3b6f76c367583d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is returned encrypted using the IO protection key.  <br /></td></tr>
<tr class="separator:ga975f7303086190d3b6f76c367583d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac244b83b061ffd8ae3d59b5f973baa53"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gac244b83b061ffd8ae3d59b5f973baa53">atcab_ecdh_tempkey</a> (const uint8_t *public_key, uint8_t *pms)</td></tr>
<tr class="memdesc:gac244b83b061ffd8ae3d59b5f973baa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in TempKey and the premaster secret is returned in the clear.  <br /></td></tr>
<tr class="separator:gac244b83b061ffd8ae3d59b5f973baa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaccb0c9d12154b0c5b917f89f233721"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gafaccb0c9d12154b0c5b917f89f233721">atcab_ecdh_tempkey_ioenc</a> (const uint8_t *public_key, uint8_t *pms, const uint8_t *io_key)</td></tr>
<tr class="memdesc:gafaccb0c9d12154b0c5b917f89f233721"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in TempKey and the premaster secret is returned encrypted using the IO protection key.  <br /></td></tr>
<tr class="separator:gafaccb0c9d12154b0c5b917f89f233721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga70751ea87f2cf913986bc7bca2cc661f">atcab_gendig</a> (uint8_t zone, uint16_t key_id, const uint8_t *other_data, uint8_t other_data_size)</td></tr>
<tr class="memdesc:ga70751ea87f2cf913986bc7bca2cc661f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to.  <br /></td></tr>
<tr class="separator:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f7953865c6091f266e727714e6f91dd"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga3f7953865c6091f266e727714e6f91dd">atcab_gendivkey</a> (const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga3f7953865c6091f266e727714e6f91dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a GenDivKey command to generate the equivalent diversified key as that programmed into the client side device.  <br /></td></tr>
<tr class="separator:ga3f7953865c6091f266e727714e6f91dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaa8b6953ad2c7f749e61566fd38fe6903">atcab_genkey_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *other_data, uint8_t *public_key)</td></tr>
<tr class="memdesc:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which can generate a private key, compute a public key, nd/or compute a digest of a public key.  <br /></td></tr>
<tr class="separator:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga617bdbdce7b5736351d93214d44c5b8f">atcab_genkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga617bdbdce7b5736351d93214d44c5b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which generates a new random private key in slot/handle and returns the public key.  <br /></td></tr>
<tr class="separator:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301d5e57486fefc1bd19da3cddc5bc0c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga301d5e57486fefc1bd19da3cddc5bc0c">atcab_genkey_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga301d5e57486fefc1bd19da3cddc5bc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which generates a new random private key in slot/handle and returns the public key.  <br /></td></tr>
<tr class="separator:ga301d5e57486fefc1bd19da3cddc5bc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2096a4618dd37c48ed48847fe63d844"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gad2096a4618dd37c48ed48847fe63d844">atcab_get_pubkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:gad2096a4618dd37c48ed48847fe63d844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses GenKey command to calculate the public key from an existing private key in a slot.  <br /></td></tr>
<tr class="separator:gad2096a4618dd37c48ed48847fe63d844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cbb1989eff2c66935040f41a593bf6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gae2cbb1989eff2c66935040f41a593bf6">atcab_get_pubkey_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:gae2cbb1989eff2c66935040f41a593bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses GenKey command to calculate the public key from an existing private key in a slot.  <br /></td></tr>
<tr class="separator:gae2cbb1989eff2c66935040f41a593bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga45f1d09a51f7a1f68916536ab5125b9d">atcab_hmac</a> (uint8_t mode, uint16_t key_id, uint8_t *digest)</td></tr>
<tr class="memdesc:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a HMAC command, which computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device.  <br /></td></tr>
<tr class="separator:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806d07982fda5c30755af6b5b4ef9314"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga806d07982fda5c30755af6b5b4ef9314">atcab_info_base</a> (uint8_t mode, uint16_t param2, uint8_t *out_data)</td></tr>
<tr class="memdesc:ga806d07982fda5c30755af6b5b4ef9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues an Info command, which return internal device information and can control GPIO and the persistent latch.  <br /></td></tr>
<tr class="separator:ga806d07982fda5c30755af6b5b4ef9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e19ecd60be4c74665d9ec142e460771"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga6e19ecd60be4c74665d9ec142e460771">atcab_info</a> (uint8_t *revision)</td></tr>
<tr class="memdesc:ga6e19ecd60be4c74665d9ec142e460771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the device revision (DevRev).  <br /></td></tr>
<tr class="separator:ga6e19ecd60be4c74665d9ec142e460771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd308bac927905d5c59f526b40c63d76"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gacd308bac927905d5c59f526b40c63d76">atcab_info_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint8_t *revision)</td></tr>
<tr class="memdesc:gacd308bac927905d5c59f526b40c63d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the device revision (DevRev).  <br /></td></tr>
<tr class="separator:gacd308bac927905d5c59f526b40c63d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d11f96c8d4b30c7cfb12a106fed7d35"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga0d11f96c8d4b30c7cfb12a106fed7d35">atcab_info_lock_status</a> (uint16_t param2, uint8_t *is_locked)</td></tr>
<tr class="memdesc:ga0d11f96c8d4b30c7cfb12a106fed7d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the lock status.  <br /></td></tr>
<tr class="separator:ga0d11f96c8d4b30c7cfb12a106fed7d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a2f89236943bcd0ed7f6616ccbb043"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaa7a2f89236943bcd0ed7f6616ccbb043">atcab_info_chip_status</a> (uint8_t *chip_status)</td></tr>
<tr class="memdesc:gaa7a2f89236943bcd0ed7f6616ccbb043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the chip status.  <br /></td></tr>
<tr class="separator:gaa7a2f89236943bcd0ed7f6616ccbb043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2649126606db8a0b64ae8e19d09f6600"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga2649126606db8a0b64ae8e19d09f6600">atcab_info_set_latch</a> (bool state)</td></tr>
<tr class="memdesc:ga2649126606db8a0b64ae8e19d09f6600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to set the persistent latch state for an ATECC608 device.  <br /></td></tr>
<tr class="separator:ga2649126606db8a0b64ae8e19d09f6600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga376b6ae92f14c60fba4ca5c6461e0b48">atcab_info_get_latch</a> (bool *state)</td></tr>
<tr class="memdesc:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the persistent latch current state for an ATECC608 device.  <br /></td></tr>
<tr class="separator:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a6c01492a76366f9402302b527c4e1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga40a6c01492a76366f9402302b527c4e1">atcab_kdf</a> (uint8_t mode, uint16_t key_id, const uint32_t details, const uint8_t *message, uint8_t *out_data, uint8_t *out_nonce)</td></tr>
<tr class="memdesc:ga40a6c01492a76366f9402302b527c4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the KDF command, which derives a new key in PRF, AES, or HKDF modes.  <br /></td></tr>
<tr class="separator:ga40a6c01492a76366f9402302b527c4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d2895192d93c524f5dba92a492cdfb"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga25d2895192d93c524f5dba92a492cdfb">atcab_lock</a> (uint8_t mode, uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga25d2895192d93c524f5dba92a492cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked.  <br /></td></tr>
<tr class="separator:ga25d2895192d93c524f5dba92a492cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga7cd67c03c7184ad041e2c0ad4f27db23">atcab_lock_config_zone</a> (void)</td></tr>
<tr class="memdesc:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the config zone.  <br /></td></tr>
<tr class="separator:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5059df8d40a5f9f0f5e2004039de424"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaf5059df8d40a5f9f0f5e2004039de424">atcab_lock_config_zone_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device)</td></tr>
<tr class="memdesc:gaf5059df8d40a5f9f0f5e2004039de424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the config zone.  <br /></td></tr>
<tr class="separator:gaf5059df8d40a5f9f0f5e2004039de424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0698e0c55ad700fe57498321e842cb38"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga0698e0c55ad700fe57498321e842cb38">atcab_lock_config_zone_crc</a> (uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga0698e0c55ad700fe57498321e842cb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the config zone with summary CRC.  <br /></td></tr>
<tr class="separator:ga0698e0c55ad700fe57498321e842cb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga8020aa89a5bed09ad35320b78e0fb890">atcab_lock_data_zone</a> (void)</td></tr>
<tr class="memdesc:ga8020aa89a5bed09ad35320b78e0fb890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the data zone (slots and OTP). for CryptoAuth devices and lock the setup for Trust Anchor device.  <br /></td></tr>
<tr class="separator:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8105d79d3dd914cf643121ff243b00a3"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga8105d79d3dd914cf643121ff243b00a3">atcab_lock_data_zone_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device)</td></tr>
<tr class="memdesc:ga8105d79d3dd914cf643121ff243b00a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the data zone (slots and OTP). for CryptoAuth devices and lock the setup for Trust Anchor device.  <br /></td></tr>
<tr class="separator:ga8105d79d3dd914cf643121ff243b00a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaf29e398e2aca927ab4606aa1ec0308c6">atcab_lock_data_zone_crc</a> (uint16_t summary_crc)</td></tr>
<tr class="memdesc:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the data zone (slots and OTP) with summary CRC.  <br /></td></tr>
<tr class="separator:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958190a9182d1b54f82fbca8216406ea"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga958190a9182d1b54f82fbca8216406ea">atcab_lock_data_slot</a> (uint16_t slot)</td></tr>
<tr class="memdesc:ga958190a9182d1b54f82fbca8216406ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1) (for cryptoauth devices) or Lock an individual handle in shared data element on an Trust Anchor device (for Trust Anchor devices).  <br /></td></tr>
<tr class="separator:ga958190a9182d1b54f82fbca8216406ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d91be168c4b3714cc0177632627bfc3"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga0d91be168c4b3714cc0177632627bfc3">atcab_lock_data_slot_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint16_t slot)</td></tr>
<tr class="memdesc:ga0d91be168c4b3714cc0177632627bfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1) (for cryptoauth devices) or Lock an individual handle in shared data element on an Trust Anchor device (for Trust Anchor devices).  <br /></td></tr>
<tr class="separator:ga0d91be168c4b3714cc0177632627bfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga98cb802fbb5d78cd552bb05c21d6c791">atcab_mac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, uint8_t *digest)</td></tr>
<tr class="memdesc:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes MAC command, which computes a SHA-256 digest of a key stored in the device, a challenge, and other information on the device.  <br /></td></tr>
<tr class="separator:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaf8e10791759a8a5e5dcd82774f4895d6">atcab_nonce_base</a> (uint8_t mode, uint16_t zero, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Nonce command, which loads a random or fixed nonce/data into the device for use by subsequent commands.  <br /></td></tr>
<tr class="separator:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2293df1c1c794496790bae25d3844fa5"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga2293df1c1c794496790bae25d3844fa5">atcab_nonce</a> (const uint8_t *num_in)</td></tr>
<tr class="memdesc:ga2293df1c1c794496790bae25d3844fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to initialize TempKey to a specified value.  <br /></td></tr>
<tr class="separator:ga2293df1c1c794496790bae25d3844fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2239ae3a87c341a48aa108bd82a58552"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga2239ae3a87c341a48aa108bd82a58552">atcab_nonce_load</a> (uint8_t target, const uint8_t *num_in, uint16_t num_in_size)</td></tr>
<tr class="memdesc:ga2239ae3a87c341a48aa108bd82a58552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to load one of the device's internal buffers with a fixed value.  <br /></td></tr>
<tr class="separator:ga2239ae3a87c341a48aa108bd82a58552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaed67d447d547c67b7b8be6b958d1fb5c">atcab_nonce_rand</a> (const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number.  <br /></td></tr>
<tr class="separator:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89942894a5a8f82391d74346603aa837"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga89942894a5a8f82391d74346603aa837">atcab_nonce_rand_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga89942894a5a8f82391d74346603aa837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number.  <br /></td></tr>
<tr class="separator:ga89942894a5a8f82391d74346603aa837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114a721517c95d5ba5fcac5b226669d6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga114a721517c95d5ba5fcac5b226669d6">atcab_challenge</a> (const uint8_t *num_in)</td></tr>
<tr class="memdesc:ga114a721517c95d5ba5fcac5b226669d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to initialize TempKey to a specified value.  <br /></td></tr>
<tr class="separator:ga114a721517c95d5ba5fcac5b226669d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadde4309089c569fd87c24a1a2326cd4"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaadde4309089c569fd87c24a1a2326cd4">atcab_challenge_seed_update</a> (const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaadde4309089c569fd87c24a1a2326cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random challenge combining a host nonce (num_in) and a device random number.  <br /></td></tr>
<tr class="separator:gaadde4309089c569fd87c24a1a2326cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead7151af044da249b398dc457fc8e06"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaead7151af044da249b398dc457fc8e06">atcab_priv_write</a> (uint16_t key_id, const uint8_t priv_key[36], uint16_t write_key_id, const uint8_t write_key[32], const uint8_t num_in[(20)])</td></tr>
<tr class="memdesc:gaead7151af044da249b398dc457fc8e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes PrivWrite command, to write externally generated ECC private keys into the device.  <br /></td></tr>
<tr class="separator:gaead7151af044da249b398dc457fc8e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa442396dfbb89e59dfca837b565cec"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga4fa442396dfbb89e59dfca837b565cec">atcab_random</a> (uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga4fa442396dfbb89e59dfca837b565cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Random command, which generates a 32 byte random number from the device.  <br /></td></tr>
<tr class="separator:ga4fa442396dfbb89e59dfca837b565cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103f4596f0f9590971763592c5233ec3"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga103f4596f0f9590971763592c5233ec3">atcab_random_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga103f4596f0f9590971763592c5233ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Random command, which generates a 32 byte random number from the device.  <br /></td></tr>
<tr class="separator:ga103f4596f0f9590971763592c5233ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga3ce01f02f456c08891ca1d67cd3ed0eb">atcab_read_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads either 4 or 32 bytes of data from a given slot, configuration zone, or the OTP zone.  <br /></td></tr>
<tr class="separator:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefce484222bdbedef37787a9b10d4426"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaefce484222bdbedef37787a9b10d4426">atcab_is_locked</a> (uint8_t zone, bool *is_locked)</td></tr>
<tr class="memdesc:gaefce484222bdbedef37787a9b10d4426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the configuration zone to see if the specified zone is locked.  <br /></td></tr>
<tr class="separator:gaefce484222bdbedef37787a9b10d4426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d0626815c3df9dd2b43d72eecd3a36"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga25d0626815c3df9dd2b43d72eecd3a36">atcab_is_config_locked</a> (bool *is_locked)</td></tr>
<tr class="memdesc:ga25d0626815c3df9dd2b43d72eecd3a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether configuration zone is locked or not.  <br /></td></tr>
<tr class="separator:ga25d0626815c3df9dd2b43d72eecd3a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac89d52a30b7a11768cf4c5de8d4d08"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gadac89d52a30b7a11768cf4c5de8d4d08">atcab_is_config_locked_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, bool *is_locked)</td></tr>
<tr class="memdesc:gadac89d52a30b7a11768cf4c5de8d4d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether configuration zone is locked or not.  <br /></td></tr>
<tr class="separator:gadac89d52a30b7a11768cf4c5de8d4d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44aae7e0a28993eb6abf78bb3d42e26d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga44aae7e0a28993eb6abf78bb3d42e26d">atcab_is_data_locked</a> (bool *is_locked)</td></tr>
<tr class="memdesc:ga44aae7e0a28993eb6abf78bb3d42e26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether data/setup zone is locked or not.  <br /></td></tr>
<tr class="separator:ga44aae7e0a28993eb6abf78bb3d42e26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3189411975d835c0115511556302d8"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga7e3189411975d835c0115511556302d8">atcab_is_data_locked_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, bool *is_locked)</td></tr>
<tr class="memdesc:ga7e3189411975d835c0115511556302d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether data/setup zone is locked or not.  <br /></td></tr>
<tr class="separator:ga7e3189411975d835c0115511556302d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802de50265ff91dc30dd7c93d9e026e1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga802de50265ff91dc30dd7c93d9e026e1">atcab_is_slot_locked</a> (uint16_t slot, bool *is_locked)</td></tr>
<tr class="memdesc:ga802de50265ff91dc30dd7c93d9e026e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether slot/handle is locked or not.  <br /></td></tr>
<tr class="separator:ga802de50265ff91dc30dd7c93d9e026e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df72bf98b5f19668dc402c35fd4ef17"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga4df72bf98b5f19668dc402c35fd4ef17">atcab_is_slot_locked_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint16_t slot, bool *is_locked)</td></tr>
<tr class="memdesc:ga4df72bf98b5f19668dc402c35fd4ef17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether slot/handle is locked or not.  <br /></td></tr>
<tr class="separator:ga4df72bf98b5f19668dc402c35fd4ef17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5f4cc263fd729871446e01cb063f141"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gac5f4cc263fd729871446e01cb063f141">atcab_is_private_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint16_t slot, bool *is_private)</td></tr>
<tr class="memdesc:gac5f4cc263fd729871446e01cb063f141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the key is a private key or not.  <br /></td></tr>
<tr class="separator:gac5f4cc263fd729871446e01cb063f141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d916826086a53649672f8abc009f3d"><td class="memItemLeft" align="right" valign="top"><a id="gac0d916826086a53649672f8abc009f3d" name="gac0d916826086a53649672f8abc009f3d"></a>
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_is_private</b> (uint16_t slot, bool *is_private)</td></tr>
<tr class="separator:gac0d916826086a53649672f8abc009f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649af88b2dc1d2c235c6e5a1842340fa"><td class="memItemLeft" align="right" valign="top"><a id="ga649af88b2dc1d2c235c6e5a1842340fa" name="ga649af88b2dc1d2c235c6e5a1842340fa"></a>
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_read_bytes_zone_ext</b> (<a class="el" href="a01472.html">ATCADevice</a> device, uint8_t zone, uint16_t slot, size_t offset, uint8_t *data, size_t length)</td></tr>
<tr class="separator:ga649af88b2dc1d2c235c6e5a1842340fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga750704332198726725a327344f4f7dd5"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga750704332198726725a327344f4f7dd5">atcab_read_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset, uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:ga750704332198726725a327344f4f7dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to read an arbitrary number of bytes from any zone configured for clear reads.  <br /></td></tr>
<tr class="separator:ga750704332198726725a327344f4f7dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga96c434878e1f435e2cda5b0b5fec444f">atcab_read_serial_number</a> (uint8_t *serial_number)</td></tr>
<tr class="memdesc:ga96c434878e1f435e2cda5b0b5fec444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns serial number of the device.  <br /></td></tr>
<tr class="separator:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a741e461c20d2a72493bc6178826eb1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga8a741e461c20d2a72493bc6178826eb1">atcab_read_serial_number_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint8_t *serial_number)</td></tr>
<tr class="memdesc:ga8a741e461c20d2a72493bc6178826eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns serial number of the device.  <br /></td></tr>
<tr class="separator:ga8a741e461c20d2a72493bc6178826eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga782ca1e5b1574b2b6793c841be22b28b"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga782ca1e5b1574b2b6793c841be22b28b">atcab_read_pubkey</a> (uint16_t slot, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga782ca1e5b1574b2b6793c841be22b28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read an ECC P256 public key from a slot configured for clear reads.  <br /></td></tr>
<tr class="separator:ga782ca1e5b1574b2b6793c841be22b28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea51a5aafd900c9bdffeffe82274255"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga2ea51a5aafd900c9bdffeffe82274255">atcab_read_pubkey_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint16_t slot, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga2ea51a5aafd900c9bdffeffe82274255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read an ECC P256 public key from a slot configured for clear reads.  <br /></td></tr>
<tr class="separator:ga2ea51a5aafd900c9bdffeffe82274255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga098c4c2c724b90b7e2f4ecf12b9530b7">atcab_read_sig</a> (uint16_t slot, uint8_t *sig)</td></tr>
<tr class="memdesc:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read a 64 byte ECDSA P256 signature from a slot configured for clear reads.  <br /></td></tr>
<tr class="separator:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga8ef47330eef6bc72ae8f7a8ef026dae3">atcab_read_config_zone</a> (uint8_t *config_data)</td></tr>
<tr class="memdesc:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read the complete device configuration zone.  <br /></td></tr>
<tr class="separator:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee98f13a88710e5234266b4b456b1dc"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga9ee98f13a88710e5234266b4b456b1dc">atcab_read_config_zone_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint8_t *config_data)</td></tr>
<tr class="memdesc:ga9ee98f13a88710e5234266b4b456b1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read the complete device configuration zone.  <br /></td></tr>
<tr class="separator:ga9ee98f13a88710e5234266b4b456b1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gadb91d2c3601b95f0ad413cf84a4dfd87">atcab_cmp_config_zone</a> (uint8_t *config_data, bool *same_config)</td></tr>
<tr class="memdesc:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a specified configuration zone with the configuration zone currently on the device.  <br /></td></tr>
<tr class="separator:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf0048247bb577c85142510225ea960"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga0cf0048247bb577c85142510225ea960">atcab_read_enc</a> (uint16_t key_id, uint8_t block, uint8_t *data, const uint8_t *enc_key, const uint16_t enc_key_id, const uint8_t num_in[(20)])</td></tr>
<tr class="memdesc:ga0cf0048247bb577c85142510225ea960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command on a slot configured for encrypted reads and decrypts the data to return it as plaintext.  <br /></td></tr>
<tr class="separator:ga0cf0048247bb577c85142510225ea960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9506331ea7d454fe3c9b2585128c77aa"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga9506331ea7d454fe3c9b2585128c77aa">atcab_secureboot</a> (uint8_t mode, uint16_t param2, const uint8_t *digest, const uint8_t *signature, uint8_t *mac)</td></tr>
<tr class="memdesc:ga9506331ea7d454fe3c9b2585128c77aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Secure Boot command, which provides support for secure boot of an external MCU or MPU.  <br /></td></tr>
<tr class="separator:ga9506331ea7d454fe3c9b2585128c77aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga5c11f2012a03ec79cb46de8e03ed0534">atcab_secureboot_mac</a> (uint8_t mode, const uint8_t *digest, const uint8_t *signature, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Secure Boot command with encrypted digest and validated MAC response using the IO protection key.  <br /></td></tr>
<tr class="separator:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaeb4a36bc6992612cc3b1f950c0d020b7">atcab_selftest</a> (uint8_t mode, uint16_t param2, uint8_t *result)</td></tr>
<tr class="memdesc:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the SelfTest command, which performs a test of one or more of the cryptographic engines within the ATECC608 chip.  <br /></td></tr>
<tr class="separator:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gab3a32e171ca1c30bd31a216b32c9b5a4">atcab_sha_base</a> (uint8_t mode, uint16_t length, const uint8_t *data_in, uint8_t *data_out, uint16_t *data_out_size)</td></tr>
<tr class="memdesc:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command, which computes a SHA-256 or HMAC/SHA-256 digest for general purpose use by the host system.  <br /></td></tr>
<tr class="separator:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gae0a7ef89fce4cbd0ee1c76759cd93b9a">atcab_sha_start</a> (void)</td></tr>
<tr class="memdesc:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to initialize SHA-256 calculation engine.  <br /></td></tr>
<tr class="separator:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga39bd70baa7a4c7f4849fcf8b94d4d949">atcab_sha_update</a> (const uint8_t *message)</td></tr>
<tr class="memdesc:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to add 64 bytes of message data to the current context.  <br /></td></tr>
<tr class="separator:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db86704035048066a370815b657234d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga1db86704035048066a370815b657234d">atcab_sha_end</a> (uint8_t *digest, uint16_t length, const uint8_t *message)</td></tr>
<tr class="memdesc:ga1db86704035048066a370815b657234d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to complete SHA-256 or HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:ga1db86704035048066a370815b657234d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d1db50562642ce511fa7cbd384c2ab"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga74d1db50562642ce511fa7cbd384c2ab">atcab_sha_read_context</a> (uint8_t *context, uint16_t *context_size)</td></tr>
<tr class="memdesc:ga74d1db50562642ce511fa7cbd384c2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to read the SHA-256 context back. Only for ATECC608 with SHA-256 contexts. HMAC not supported.  <br /></td></tr>
<tr class="separator:ga74d1db50562642ce511fa7cbd384c2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga070fa80ac0d76f6816d9f7affbcfb120">atcab_sha_write_context</a> (const uint8_t *context, uint16_t context_size)</td></tr>
<tr class="memdesc:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to write (restore) a SHA-256 context into the the device. Only supported for ATECC608 with SHA-256 contexts.  <br /></td></tr>
<tr class="separator:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d269ccdafd08519a899a8aebf53df1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga31d269ccdafd08519a899a8aebf53df1">atcab_sha</a> (uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga31d269ccdafd08519a899a8aebf53df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute a SHA-256 digest.  <br /></td></tr>
<tr class="separator:ga31d269ccdafd08519a899a8aebf53df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf8b665fe1712626a480742c2daa16b"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga4bf8b665fe1712626a480742c2daa16b">atcab_hw_sha2_256</a> (const uint8_t *data, size_t data_size, uint8_t *digest)</td></tr>
<tr class="memdesc:ga4bf8b665fe1712626a480742c2daa16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute a SHA-256 digest.  <br /></td></tr>
<tr class="separator:ga4bf8b665fe1712626a480742c2daa16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade49e7746864105730fa7d531645ff62"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gade49e7746864105730fa7d531645ff62">atcab_hw_sha2_256_init</a> (<a class="el" href="a01580.html">atca_sha256_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:gade49e7746864105730fa7d531645ff62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a SHA context for performing a hardware SHA-256 operation on a device. Note that only one SHA operation can be run at a time.  <br /></td></tr>
<tr class="separator:gade49e7746864105730fa7d531645ff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga67f2ce6224651d9cc65e9915e35558bd">atcab_hw_sha2_256_update</a> (<a class="el" href="a01580.html">atca_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:ga67f2ce6224651d9cc65e9915e35558bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add message data to a SHA context for performing a hardware SHA-256 operation on a device.  <br /></td></tr>
<tr class="separator:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga6ed7e645262fcc32b00d8a9facf09e91">atcab_hw_sha2_256_finish</a> (<a class="el" href="a01580.html">atca_sha256_ctx_t</a> *ctx, uint8_t *digest)</td></tr>
<tr class="memdesc:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish SHA-256 digest for a SHA context for performing a hardware SHA-256 operation on a device.  <br /></td></tr>
<tr class="separator:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga310a017cddce9ef05071cb619b4b6db9"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga310a017cddce9ef05071cb619b4b6db9">atcab_sha_hmac_init</a> (<a class="el" href="a01580.html">atca_hmac_sha256_ctx_t</a> *ctx, uint16_t key_slot)</td></tr>
<tr class="memdesc:ga310a017cddce9ef05071cb619b4b6db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to start an HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:ga310a017cddce9ef05071cb619b4b6db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3343c160e80365b7e96bdfdc9b6365c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gae3343c160e80365b7e96bdfdc9b6365c">atcab_sha_hmac_update</a> (<a class="el" href="a01580.html">atca_hmac_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:gae3343c160e80365b7e96bdfdc9b6365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to add an arbitrary amount of message data to a HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:gae3343c160e80365b7e96bdfdc9b6365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4be9972396b7cadb08dd8e2199daf08"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaa4be9972396b7cadb08dd8e2199daf08">atcab_sha_hmac_finish</a> (<a class="el" href="a01580.html">atca_hmac_sha256_ctx_t</a> *ctx, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gaa4be9972396b7cadb08dd8e2199daf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to complete a HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:gaa4be9972396b7cadb08dd8e2199daf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae655ce06583c08169170102fbb0b55c9"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gae655ce06583c08169170102fbb0b55c9">atcab_sha_hmac</a> (const uint8_t *data, size_t data_size, uint16_t key_slot, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gae655ce06583c08169170102fbb0b55c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute an HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:gae655ce06583c08169170102fbb0b55c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede6ae09e6192e452ad261f4e15e1c62"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaede6ae09e6192e452ad261f4e15e1c62">atcab_sha_hmac_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, const uint8_t *data, size_t data_size, uint16_t key_slot, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gaede6ae09e6192e452ad261f4e15e1c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute an HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:gaede6ae09e6192e452ad261f4e15e1c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga5c1e598bf3d4d25b522f42d6038a4268">atcab_sign_base</a> (uint8_t mode, uint16_t key_id, uint8_t *signature)</td></tr>
<tr class="memdesc:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Sign command, which generates a signature using the ECDSA algorithm.  <br /></td></tr>
<tr class="separator:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga69b8282d1b1e0c54b9a7d286fed503b8">atcab_sign</a> (uint16_t key_id, const uint8_t *msg, uint8_t *signature)</td></tr>
<tr class="memdesc:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b76ca12e6f7236d9ef3235b174f48cc"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga4b76ca12e6f7236d9ef3235b174f48cc">atcab_sign_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint16_t key_id, const uint8_t *msg, uint8_t *signature)</td></tr>
<tr class="memdesc:ga4b76ca12e6f7236d9ef3235b174f48cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:ga4b76ca12e6f7236d9ef3235b174f48cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga559add3e8b4f85a9d91fc0ed86aefa29">atcab_sign_internal</a> (uint16_t key_id, bool is_invalidate, bool is_full_sn, uint8_t *signature)</td></tr>
<tr class="memdesc:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command to sign an internally generated message.  <br /></td></tr>
<tr class="separator:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga416e4aeacf3acc35b1d5b76028c6947d">atcab_updateextra</a> (uint8_t mode, uint16_t new_value)</td></tr>
<tr class="memdesc:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes UpdateExtra command to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85).  <br /></td></tr>
<tr class="separator:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694d921c7bc17a0e158ef96e3d476700"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga694d921c7bc17a0e158ef96e3d476700">atcab_verify</a> (uint8_t mode, uint16_t key_id, const uint8_t *signature, const uint8_t *public_key, const uint8_t *other_data, uint8_t *mac)</td></tr>
<tr class="memdesc:ga694d921c7bc17a0e158ef96e3d476700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command.  <br /></td></tr>
<tr class="separator:ga694d921c7bc17a0e158ef96e3d476700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3e18de900ba705192963d08b37f600"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga2c3e18de900ba705192963d08b37f600">atcab_verify_extern</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga2c3e18de900ba705192963d08b37f600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:ga2c3e18de900ba705192963d08b37f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4e2ffada9173db1a775a697bbebf18"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga3a4e2ffada9173db1a775a697bbebf18">atcab_verify_extern_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga3a4e2ffada9173db1a775a697bbebf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:ga3a4e2ffada9173db1a775a697bbebf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga17bf17c4786be097a0bb111a6f9d8ca6">atcab_verify_extern_mac</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. This function is only available on the ATECC608.  <br /></td></tr>
<tr class="separator:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8cc7670847805423ad591985eecd832"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gae8cc7670847805423ad591985eecd832">atcab_verify_stored</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:gae8cc7670847805423ad591985eecd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:gae8cc7670847805423ad591985eecd832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08f6cceac6e8147aeb6f665dc0a2aff"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gad08f6cceac6e8147aeb6f665dc0a2aff">atcab_verify_stored_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, const uint8_t *message, const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:gad08f6cceac6e8147aeb6f665dc0a2aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:gad08f6cceac6e8147aeb6f665dc0a2aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582dc8686f0491ad4292287f6971543c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga582dc8686f0491ad4292287f6971543c">atcab_verify_stored_with_tempkey</a> (const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:ga582dc8686f0491ad4292287f6971543c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. keyConfig.reqrandom bit should be set and the message to be signed should be already loaded into TempKey for all devices.  <br /></td></tr>
<tr class="separator:ga582dc8686f0491ad4292287f6971543c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaa52cdbbfd2f089d8eb42ef2640204ca7">atcab_verify_stored_mac</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with a public key stored in the device. This function is only available on the ATECC608.  <br /></td></tr>
<tr class="separator:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gacf9a0c7772ebb65b87c4a4788850702b">atcab_verify_validate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:gacf9a0c7772ebb65b87c4a4788850702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command in Validate mode to validate a public key stored in a slot.  <br /></td></tr>
<tr class="separator:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga9393b545b2fa1fdd539672a0428a30ab">atcab_verify_invalidate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:ga9393b545b2fa1fdd539672a0428a30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command in Invalidate mode which invalidates a previously validated public key stored in a slot.  <br /></td></tr>
<tr class="separator:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gabf2b29b4d3ae926b63c403d084380dbe">atcab_write</a> (uint8_t zone, uint16_t <a class="el" href="a00263.html#af3f726014b044194def151079f1f2d89">address</a>, const uint8_t *value, const uint8_t *mac)</td></tr>
<tr class="memdesc:gabf2b29b4d3ae926b63c403d084380dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either one four byte word or a 32-byte block to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys.  <br /></td></tr>
<tr class="separator:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga1f5a6bbcf4f840803635fb8951b3a7e2">atcab_write_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either 4 or 32 bytes of data into a device zone.  <br /></td></tr>
<tr class="separator:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03eaf30d3d776260ad57ff05c2d6aa1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gad03eaf30d3d776260ad57ff05c2d6aa1">atcab_write_zone_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:gad03eaf30d3d776260ad57ff05c2d6aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either 4 or 32 bytes of data into a device zone.  <br /></td></tr>
<tr class="separator:gad03eaf30d3d776260ad57ff05c2d6aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1442f24118397b11eb46a0cbe1601016"><td class="memItemLeft" align="right" valign="top"><a id="ga1442f24118397b11eb46a0cbe1601016" name="ga1442f24118397b11eb46a0cbe1601016"></a>
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_write_bytes_zone_ext</b> (<a class="el" href="a01472.html">ATCADevice</a> device, uint8_t zone, uint16_t slot, size_t offset_bytes, const uint8_t *data, size_t length)</td></tr>
<tr class="separator:ga1442f24118397b11eb46a0cbe1601016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac395a7e195aa3cf28b48de345755feb0"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gac395a7e195aa3cf28b48de345755feb0">atcab_write_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset_bytes, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gac395a7e195aa3cf28b48de345755feb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes data into the configuration, otp, or data zones with a given byte offset and length. Offset and length must be multiples of a word (4 bytes).  <br /></td></tr>
<tr class="separator:gac395a7e195aa3cf28b48de345755feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga47cbedeb3c3e9f7cbf2b9433cd60d1aa">atcab_write_pubkey</a> (uint16_t slot, const uint8_t *public_key)</td></tr>
<tr class="memdesc:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the write command to write a public key to a slot in the proper format.  <br /></td></tr>
<tr class="separator:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80d6c193374d363649236778289f2ea"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaa80d6c193374d363649236778289f2ea">atcab_write_pubkey_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, uint16_t slot, const uint8_t *public_key)</td></tr>
<tr class="memdesc:gaa80d6c193374d363649236778289f2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the write command to write a public key to a slot in the proper format.  <br /></td></tr>
<tr class="separator:gaa80d6c193374d363649236778289f2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0777a86aa412a97b19cc72a12c171b94"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga0777a86aa412a97b19cc72a12c171b94">atcab_write_config_zone</a> (const uint8_t *config_data)</td></tr>
<tr class="memdesc:ga0777a86aa412a97b19cc72a12c171b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes the configuration zone.  <br /></td></tr>
<tr class="separator:ga0777a86aa412a97b19cc72a12c171b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d651c637007f8c3672c3313767c0e7"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga92d651c637007f8c3672c3313767c0e7">atcab_write_config_zone_ext</a> (<a class="el" href="a01472.html">ATCADevice</a> device, const uint8_t *config_data)</td></tr>
<tr class="memdesc:ga92d651c637007f8c3672c3313767c0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes the configuration zone.  <br /></td></tr>
<tr class="separator:ga92d651c637007f8c3672c3313767c0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a5394997ea31b125cd57d07aa73636"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga78a5394997ea31b125cd57d07aa73636">atcab_write_enc</a> (uint16_t key_id, uint8_t block, const uint8_t *data, const uint8_t *enc_key, const uint16_t enc_key_id, const uint8_t num_in[(20)])</td></tr>
<tr class="memdesc:ga78a5394997ea31b125cd57d07aa73636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which performs an encrypted write of a 32 byte block into given slot.  <br /></td></tr>
<tr class="separator:ga78a5394997ea31b125cd57d07aa73636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25ca44957dff1c2df34607738ca3bf7"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gab25ca44957dff1c2df34607738ca3bf7">atcab_write_config_counter</a> (uint16_t counter_id, uint32_t counter_value)</td></tr>
<tr class="memdesc:gab25ca44957dff1c2df34607738ca3bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize one of the monotonic counters in device with a specific value.  <br /></td></tr>
<tr class="separator:gab25ca44957dff1c2df34607738ca3bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga04ab61dc670ca87600f9f71380b9b198"><td class="memItemLeft" align="right" valign="top"><a id="ga04ab61dc670ca87600f9f71380b9b198" name="ga04ab61dc670ca87600f9f71380b9b198"></a>
<a class="el" href="a01472.html">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_atcab_device_ptr</b></td></tr>
<tr class="separator:ga04ab61dc670ca87600f9f71380b9b198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31a9fd8e9deca79aa5fef0292fe5272"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gae31a9fd8e9deca79aa5fef0292fe5272">atcab_bin2hex</a> (const uint8_t *bin, size_t bin_size, char *hex, size_t *hex_size)</td></tr>
<tr class="memdesc:gae31a9fd8e9deca79aa5fef0292fe5272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a binary buffer to a hex string for easy reading.  <br /></td></tr>
<tr class="separator:gae31a9fd8e9deca79aa5fef0292fe5272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b70cfab865fa4fd9a5e7a29ca59d38"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga40b70cfab865fa4fd9a5e7a29ca59d38">atcab_bin2hex_</a> (const uint8_t *bin, size_t bin_size, char *hex, size_t *hex_size, bool is_pretty, bool is_space, bool is_upper)</td></tr>
<tr class="memdesc:ga40b70cfab865fa4fd9a5e7a29ca59d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that converts a binary buffer to a hex string suitable for easy reading.  <br /></td></tr>
<tr class="separator:ga40b70cfab865fa4fd9a5e7a29ca59d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481179181349c801c16fc1ab698f2f24"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga481179181349c801c16fc1ab698f2f24">atcab_hex2bin</a> (const char *ascii_hex, size_t ascii_hex_len, uint8_t *binary, size_t *bin_len)</td></tr>
<tr class="memdesc:ga481179181349c801c16fc1ab698f2f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that converts a hex string to binary buffer.  <br /></td></tr>
<tr class="separator:ga481179181349c801c16fc1ab698f2f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef30ca351b13623043917b5ed86cbb8"><td class="memItemLeft" align="right" valign="top"><a id="ga4ef30ca351b13623043917b5ed86cbb8" name="ga4ef30ca351b13623043917b5ed86cbb8"></a>
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_hex2bin_</b> (const char *hex, size_t hex_size, uint8_t *bin, size_t *bin_size, bool is_space)</td></tr>
<tr class="separator:ga4ef30ca351b13623043917b5ed86cbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad017ae33af5a7ea062cea7d54de675a8"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gad017ae33af5a7ea062cea7d54de675a8">packHex</a> (const char *ascii_hex, size_t ascii_hex_len, char *packed_hex, size_t *packed_len)</td></tr>
<tr class="memdesc:gad017ae33af5a7ea062cea7d54de675a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove spaces from a ASCII hex string.  <br /></td></tr>
<tr class="separator:gad017ae33af5a7ea062cea7d54de675a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a929bf65cbc777bab7e533a2755cfad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga7a929bf65cbc777bab7e533a2755cfad">isDigit</a> (char c)</td></tr>
<tr class="memdesc:ga7a929bf65cbc777bab7e533a2755cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is an ASCII representation of a digit ((c ge '0') and (c le '9'))  <br /></td></tr>
<tr class="separator:ga7a929bf65cbc777bab7e533a2755cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04fefe2ff5a7d2e937b2634acd22982a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga04fefe2ff5a7d2e937b2634acd22982a">isBlankSpace</a> (char c)</td></tr>
<tr class="memdesc:ga04fefe2ff5a7d2e937b2634acd22982a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is blank space.  <br /></td></tr>
<tr class="separator:ga04fefe2ff5a7d2e937b2634acd22982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592c23e94097ad5e212beb6390aa88c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga592c23e94097ad5e212beb6390aa88c6">isAlpha</a> (char c)</td></tr>
<tr class="memdesc:ga592c23e94097ad5e212beb6390aa88c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f'))  <br /></td></tr>
<tr class="separator:ga592c23e94097ad5e212beb6390aa88c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78abefc293c0a04d8ef649c94c8a1057"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga78abefc293c0a04d8ef649c94c8a1057">isHexAlpha</a> (char c)</td></tr>
<tr class="memdesc:ga78abefc293c0a04d8ef649c94c8a1057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f'))  <br /></td></tr>
<tr class="separator:ga78abefc293c0a04d8ef649c94c8a1057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ca9ee391118aafe6f3cf7df4fa5de3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gab7ca9ee391118aafe6f3cf7df4fa5de3">isHex</a> (char c)</td></tr>
<tr class="memdesc:gab7ca9ee391118aafe6f3cf7df4fa5de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid hex character or if this is blankspace (The character can be included in a valid hexstring).  <br /></td></tr>
<tr class="separator:gab7ca9ee391118aafe6f3cf7df4fa5de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39003da4dc8a0b8999f1325c2f96f641"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga39003da4dc8a0b8999f1325c2f96f641">isHexDigit</a> (char c)</td></tr>
<tr class="memdesc:ga39003da4dc8a0b8999f1325c2f96f641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid hex character.  <br /></td></tr>
<tr class="separator:ga39003da4dc8a0b8999f1325c2f96f641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac873a37c53fdd922d5b36efd737e3ec3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gac873a37c53fdd922d5b36efd737e3ec3">isBase64</a> (char c, const uint8_t *rules)</td></tr>
<tr class="memdesc:gac873a37c53fdd922d5b36efd737e3ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid base 64 character or if this is space (A character can be included in a valid base 64 string).  <br /></td></tr>
<tr class="separator:gac873a37c53fdd922d5b36efd737e3ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10d15454308230fbef54bdd43001ed2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gad10d15454308230fbef54bdd43001ed2">isBase64Digit</a> (char c, const uint8_t *rules)</td></tr>
<tr class="memdesc:gad10d15454308230fbef54bdd43001ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this character is a valid base 64 character.  <br /></td></tr>
<tr class="separator:gad10d15454308230fbef54bdd43001ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63df1707f387c7d8cd9b5cc630585451"><td class="memItemLeft" align="right" valign="top"><a id="ga63df1707f387c7d8cd9b5cc630585451" name="ga63df1707f387c7d8cd9b5cc630585451"></a>
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_b64rules_default</b> (void)</td></tr>
<tr class="separator:ga63df1707f387c7d8cd9b5cc630585451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2788ca7af14f8ddf1de38b6c3b295fc7"><td class="memItemLeft" align="right" valign="top"><a id="ga2788ca7af14f8ddf1de38b6c3b295fc7" name="ga2788ca7af14f8ddf1de38b6c3b295fc7"></a>
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_b64rules_mime</b> (void)</td></tr>
<tr class="separator:ga2788ca7af14f8ddf1de38b6c3b295fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf3840c83fd2df68907173f95bdece7e"><td class="memItemLeft" align="right" valign="top"><a id="gabf3840c83fd2df68907173f95bdece7e" name="gabf3840c83fd2df68907173f95bdece7e"></a>
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_b64rules_urlsafe</b> (void)</td></tr>
<tr class="separator:gabf3840c83fd2df68907173f95bdece7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ba8a1787f69d44d6e40db041fbd786"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga55ba8a1787f69d44d6e40db041fbd786">atcab_base64decode_</a> (const char *encoded, size_t encoded_size, uint8_t *data, size_t *data_size, const uint8_t *rules)</td></tr>
<tr class="memdesc:ga55ba8a1787f69d44d6e40db041fbd786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode base64 string to data with ruleset option.  <br /></td></tr>
<tr class="separator:ga55ba8a1787f69d44d6e40db041fbd786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa141525a1141f1a290e2a996da0c9c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga3aa141525a1141f1a290e2a996da0c9c">atcab_base64encode</a> (const uint8_t *byte_array, size_t array_len, char *encoded, size_t *encoded_len)</td></tr>
<tr class="memdesc:ga3aa141525a1141f1a290e2a996da0c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode data as base64 string.  <br /></td></tr>
<tr class="separator:ga3aa141525a1141f1a290e2a996da0c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeff0177acf29e6e7b134a14d7119d69"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#gaeeff0177acf29e6e7b134a14d7119d69">atcab_base64encode_</a> (const uint8_t *data, size_t data_size, char *encoded, size_t *encoded_size, const uint8_t *rules)</td></tr>
<tr class="memdesc:gaeeff0177acf29e6e7b134a14d7119d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode data as base64 string with ruleset option.  <br /></td></tr>
<tr class="separator:gaeeff0177acf29e6e7b134a14d7119d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6073c5a05e0ad2e738f460e727014553"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga6073c5a05e0ad2e738f460e727014553">atcab_base64decode</a> (const char *encoded, size_t encoded_len, uint8_t *byte_array, size_t *array_len)</td></tr>
<tr class="memdesc:ga6073c5a05e0ad2e738f460e727014553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode base64 string to data.  <br /></td></tr>
<tr class="separator:ga6073c5a05e0ad2e738f460e727014553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7371f490659b6fd68739d2b1fee50696"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html#ga7371f490659b6fd68739d2b1fee50696">atcab_reversal</a> (const uint8_t *bin, size_t bin_size, uint8_t *dest, size_t *dest_size)</td></tr>
<tr class="memdesc:ga7371f490659b6fd68739d2b1fee50696"><td class="mdescLeft">&#160;</td><td class="mdescRight">To reverse the input data.  <br /></td></tr>
<tr class="separator:ga7371f490659b6fd68739d2b1fee50696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac37b319dabc5b9492a422f6d3d4e118b"><td class="memItemLeft" align="right" valign="top"><a id="gac37b319dabc5b9492a422f6d3d4e118b" name="gac37b319dabc5b9492a422f6d3d4e118b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_memset_s</b> (void *dest, size_t destsz, int ch, size_t count)</td></tr>
<tr class="memdesc:gac37b319dabc5b9492a422f6d3d4e118b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guaranteed to perform memory writes regardless of optimization level. Matches memset_s signature. <br /></td></tr>
<tr class="separator:gac37b319dabc5b9492a422f6d3d4e118b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72f385a8eafc464a05acfa54561fed63"><td class="memItemLeft" align="right" valign="top"><a id="ga72f385a8eafc464a05acfa54561fed63" name="ga72f385a8eafc464a05acfa54561fed63"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_pointer_delta</b> (const void *start, const void *end)</td></tr>
<tr class="memdesc:ga72f385a8eafc464a05acfa54561fed63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the number of bytes between two pointers. <br /></td></tr>
<tr class="separator:ga72f385a8eafc464a05acfa54561fed63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13a4675d782c861977b653e3c2b354ba"><td class="memItemLeft" align="right" valign="top"><a id="ga13a4675d782c861977b653e3c2b354ba" name="ga13a4675d782c861977b653e3c2b354ba"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>lib_toupper</b> (char c)</td></tr>
<tr class="memdesc:ga13a4675d782c861977b653e3c2b354ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a character to uppercase. <br /></td></tr>
<tr class="separator:ga13a4675d782c861977b653e3c2b354ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada3308b30b1b1e40abb806dbc5476648"><td class="memItemLeft" align="right" valign="top"><a id="gada3308b30b1b1e40abb806dbc5476648" name="gada3308b30b1b1e40abb806dbc5476648"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>lib_tolower</b> (char c)</td></tr>
<tr class="memdesc:gada3308b30b1b1e40abb806dbc5476648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a character to lowercase. <br /></td></tr>
<tr class="separator:gada3308b30b1b1e40abb806dbc5476648"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These methods provide the most convenient, simple API to CryptoAuth chips. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad115ce255664a48b80e90ea19c156b79" name="gad115ce255664a48b80e90ea19c156b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad115ce255664a48b80e90ea19c156b79">&#9670;&#160;</a></span>atcab_aes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>aes_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aes_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the AES-128 encrypt, decrypt, or GFM calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode for the AES command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aes_in</td><td>Input data to the AES command (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aes_out</td><td>Output data from the AES command is returned here (16 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga9658e84055727e6357cf7ef636b4e398" name="ga9658e84055727e6357cf7ef636b4e398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9658e84055727e6357cf7ef636b4e398">&#9670;&#160;</a></span>atcab_aes_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_decrypt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an AES-128 decrypt operation with a key in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ciphertext</td><td>Input ciphertext to be decrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plaintext</td><td>Output plaintext is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaebaf49a3412181fa47ba3a761c5a2d5b" name="gaebaf49a3412181fa47ba3a761c5a2d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebaf49a3412181fa47ba3a761c5a2d5b">&#9670;&#160;</a></span>atcab_aes_decrypt_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_decrypt_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an AES-128 decrypt operation with a key in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ciphertext</td><td>Input ciphertext to be decrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plaintext</td><td>Output plaintext is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gacc9a58dc49f91674213f34fa7bbd05e1" name="gacc9a58dc49f91674213f34fa7bbd05e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9a58dc49f91674213f34fa7bbd05e1">&#9670;&#160;</a></span>atcab_aes_encrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_encrypt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an AES-128 encrypt operation with a key in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plaintext</td><td>Input plaintext to be encrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ciphertext</td><td>Output ciphertext is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaa5c5cba4f9be5bc0e4b1c5691f60e4ba" name="gaa5c5cba4f9be5bc0e4b1c5691f60e4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5c5cba4f9be5bc0e4b1c5691f60e4ba">&#9670;&#160;</a></span>atcab_aes_encrypt_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_encrypt_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an AES-128 encrypt operation with a key in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plaintext</td><td>Input plaintext to be encrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ciphertext</td><td>Output ciphertext is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga1d6fd831a8125a366504a0ab77b62da8" name="ga1d6fd831a8125a366504a0ab77b62da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d6fd831a8125a366504a0ab77b62da8">&#9670;&#160;</a></span>atcab_aes_gcm_aad_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_aad_update </td>
          <td>(</td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>aad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aad_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process Additional Authenticated Data (AAD) using GCM mode and a key within the ATECC608 device. </p>
<p>This can be called multiple times. <a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function. When there is AAD to include, this should be called before <a class="el" href="a01403.html#gab3fda8219d17d1b7bc50b1040399a47d" title="Encrypt data using GCM mode and a key within the ATECC608 device. atcab_aes_gcm_init() or atcab_aes_g...">atcab_aes_gcm_encrypt_update()</a> or <a class="el" href="a01403.html#ga2ad3270d8bebf6172dc02d0c7d9fb738" title="Decrypt data using GCM mode and a key within the ATECC608 device. atcab_aes_gcm_init() or atcab_aes_g...">atcab_aes_gcm_decrypt_update()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aad</td><td>Additional authenticated data to be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aad_size</td><td>Size of aad in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga1c6666c7b4d077fb058adc4971da2160" name="ga1c6666c7b4d077fb058adc4971da2160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c6666c7b4d077fb058adc4971da2160">&#9670;&#160;</a></span>atcab_aes_gcm_aad_update_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_aad_update_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>aad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>aad_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process Additional Authenticated Data (AAD) using GCM mode and a key within the ATECC608 device. </p>
<p>This can be called multiple times. <a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function. When there is AAD to include, this should be called before <a class="el" href="a01403.html#gab3fda8219d17d1b7bc50b1040399a47d" title="Encrypt data using GCM mode and a key within the ATECC608 device. atcab_aes_gcm_init() or atcab_aes_g...">atcab_aes_gcm_encrypt_update()</a> or <a class="el" href="a01403.html#ga2ad3270d8bebf6172dc02d0c7d9fb738" title="Decrypt data using GCM mode and a key within the ATECC608 device. atcab_aes_gcm_init() or atcab_aes_g...">atcab_aes_gcm_decrypt_update()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aad</td><td>Additional authenticated data to be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aad_size</td><td>Size of aad in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaa86508958ff3d81f9bd8e79344537218" name="gaa86508958ff3d81f9bd8e79344537218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa86508958ff3d81f9bd8e79344537218">&#9670;&#160;</a></span>atcab_aes_gcm_decrypt_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_decrypt_finish </td>
          <td>(</td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete a GCM decrypt operation verifying the authentication tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Expected authentication tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_size</td><td>Size of tag in bytes (12 to 16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Returns whether or not the tag verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga9c5173c7529f898f251814133169ba1d" name="ga9c5173c7529f898f251814133169ba1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c5173c7529f898f251814133169ba1d">&#9670;&#160;</a></span>atcab_aes_gcm_decrypt_finish_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_decrypt_finish_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete a GCM decrypt operation verifying the authentication tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Expected authentication tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_size</td><td>Size of tag in bytes (12 to 16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Returns whether or not the tag verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2ad3270d8bebf6172dc02d0c7d9fb738" name="ga2ad3270d8bebf6172dc02d0c7d9fb738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ad3270d8bebf6172dc02d0c7d9fb738">&#9670;&#160;</a></span>atcab_aes_gcm_decrypt_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_decrypt_update </td>
          <td>(</td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ciphertext_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ciphertext</td><td>Ciphertext to be decrypted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ciphertext_size</td><td>Size of ciphertext in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plaintext</td><td>Decrypted data is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gac55fcbd824ffc9a30c6a5bbafb93aad2" name="gac55fcbd824ffc9a30c6a5bbafb93aad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac55fcbd824ffc9a30c6a5bbafb93aad2">&#9670;&#160;</a></span>atcab_aes_gcm_decrypt_update_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_decrypt_update_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ciphertext_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ciphertext</td><td>Ciphertext to be decrypted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ciphertext_size</td><td>Size of ciphertext in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plaintext</td><td>Decrypted data is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gada2d38835826587970de3868ca48eaa4" name="gada2d38835826587970de3868ca48eaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada2d38835826587970de3868ca48eaa4">&#9670;&#160;</a></span>atcab_aes_gcm_encrypt_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_encrypt_finish </td>
          <td>(</td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete a GCM encrypt operation returning the authentication tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tag</td><td>Authentication tag is returned here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_size</td><td>Tag size in bytes (12 to 16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga813fb67193a7c39d02ce7ad8d2d12123" name="ga813fb67193a7c39d02ce7ad8d2d12123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga813fb67193a7c39d02ce7ad8d2d12123">&#9670;&#160;</a></span>atcab_aes_gcm_encrypt_finish_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_encrypt_finish_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete a GCM encrypt operation returning the authentication tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tag</td><td>Authentication tag is returned here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_size</td><td>Tag size in bytes (12 to 16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab3fda8219d17d1b7bc50b1040399a47d" name="gab3fda8219d17d1b7bc50b1040399a47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3fda8219d17d1b7bc50b1040399a47d">&#9670;&#160;</a></span>atcab_aes_gcm_encrypt_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_encrypt_update </td>
          <td>(</td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>plaintext_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plaintext</td><td>Plaintext to be encrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plaintext_size</td><td>Size of plaintext in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ciphertext</td><td>Encrypted data is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaac8b8555b03b50a118b70cb8387c24ae" name="gaac8b8555b03b50a118b70cb8387c24ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac8b8555b03b50a118b70cb8387c24ae">&#9670;&#160;</a></span>atcab_aes_gcm_encrypt_update_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_encrypt_update_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>plaintext_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01403.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01403.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plaintext</td><td>Plaintext to be encrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plaintext_size</td><td>Size of plaintext in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ciphertext</td><td>Encrypted data is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4805112b62e86b5465e24648504dc374" name="ga4805112b62e86b5465e24648504dc374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4805112b62e86b5465e24648504dc374">&#9670;&#160;</a></span>atcab_aes_gcm_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_init </td>
          <td>(</td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iv_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Initialization vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv_size</td><td>Size of IV in bytes. Standard is 12 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga8742a7be77a2350c069c5c380ac4c635" name="ga8742a7be77a2350c069c5c380ac4c635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8742a7be77a2350c069c5c380ac4c635">&#9670;&#160;</a></span>atcab_aes_gcm_init_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_init_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iv_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES GCM context to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv</td><td>Initialization vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iv_size</td><td>Size of IV in bytes. Standard is 12 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad71a5720ceaddf2c76476aead5f0c3e6" name="gad71a5720ceaddf2c76476aead5f0c3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad71a5720ceaddf2c76476aead5f0c3e6">&#9670;&#160;</a></span>atcab_aes_gcm_init_rand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gcm_init_rand </td>
          <td>(</td>
          <td class="paramtype">atca_aes_gcm_ctx_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rand_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>free_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>free_field_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>iv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) field, which is common when starting an encrypt operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>AES CTR context to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rand_size</td><td>Size of the random field in bytes. Minimum and recommended size is 12 bytes. Max is 32 bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_field</td><td>Fixed data to include in the IV after the random field. Can be NULL if not used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_field_size</td><td>Size of the free field in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iv</td><td>Initialization vector is returned here. Its size will be rand_size and free_field_size combined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga5554940ed4c7c7e28652ce6923cf9314" name="ga5554940ed4c7c7e28652ce6923cf9314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5554940ed4c7c7e28652ce6923cf9314">&#9670;&#160;</a></span>atcab_aes_gfm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_aes_gfm </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a Galois Field Multiply (GFM) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>First input value (16 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Second input value (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>GFM result is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga6073c5a05e0ad2e738f460e727014553" name="ga6073c5a05e0ad2e738f460e727014553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6073c5a05e0ad2e738f460e727014553">&#9670;&#160;</a></span>atcab_base64decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_base64decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encoded_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>array_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode base64 string to data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded</td><td>Base64 string to be decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded_len</td><td>Size of the base64 string in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">byte_array</td><td>Decoded data will be returned here. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">array_len</td><td>As input, the size of the byte_array buffer. As output, the length of the decoded data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga55ba8a1787f69d44d6e40db041fbd786" name="ga55ba8a1787f69d44d6e40db041fbd786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55ba8a1787f69d44d6e40db041fbd786">&#9670;&#160;</a></span>atcab_base64decode_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_base64decode_ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>encoded_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode base64 string to data with ruleset option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded</td><td>Base64 string to be decoded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded_size</td><td>Size of the base64 string in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Decoded data will be returned here. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_size</td><td>As input, the size of the byte_array buffer. As output, the length of the decoded data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules</td><td>base64 ruleset to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3aa141525a1141f1a290e2a996da0c9c" name="ga3aa141525a1141f1a290e2a996da0c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aa141525a1141f1a290e2a996da0c9c">&#9670;&#160;</a></span>atcab_base64encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_base64encode </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>byte_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>encoded_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode data as base64 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">byte_array</td><td>Data to be encode in base64. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array_len</td><td>Size of byte_array in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded</td><td>Base64 output is returned here. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">encoded_len</td><td>As input, the size of the encoded buffer. As output, the length of the encoded base64 character string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaeeff0177acf29e6e7b134a14d7119d69" name="gaeeff0177acf29e6e7b134a14d7119d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeff0177acf29e6e7b134a14d7119d69">&#9670;&#160;</a></span>atcab_base64encode_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_base64encode_ </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>encoded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>encoded_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode data as base64 string with ruleset option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The input byte array that will be converted to base 64 encoded characters</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>The length of the byte array</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoded</td><td>The output converted to base 64 encoded characters.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">encoded_size</td><td>Input: The size of the encoded buffer, Output: The length of the encoded base 64 character string</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules</td><td>ruleset to use during encoding </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae31a9fd8e9deca79aa5fef0292fe5272" name="gae31a9fd8e9deca79aa5fef0292fe5272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae31a9fd8e9deca79aa5fef0292fe5272">&#9670;&#160;</a></span>atcab_bin2hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_bin2hex </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hex_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a binary buffer to a hex string for easy reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>Input data to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bin_size</td><td>Size of data to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hex</td><td>Buffer that receives hex string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hex_size</td><td>As input, the size of the hex buffer. As output, the size of the output hex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga40b70cfab865fa4fd9a5e7a29ca59d38" name="ga40b70cfab865fa4fd9a5e7a29ca59d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40b70cfab865fa4fd9a5e7a29ca59d38">&#9670;&#160;</a></span>atcab_bin2hex_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_bin2hex_ </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>hex_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_pretty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that converts a binary buffer to a hex string suitable for easy reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>Input data to convert. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bin_size</td><td>Size of data to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hex</td><td>Buffer that receives hex string. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hex_size</td><td>As input, the size of the hex buffer. As output, the size of the output hex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_pretty</td><td>Indicates whether new lines should be added for pretty printing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_space</td><td>Convert the output hex with space between it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_upper</td><td>Convert the output hex to upper case.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga114a721517c95d5ba5fcac5b226669d6" name="ga114a721517c95d5ba5fcac5b226669d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga114a721517c95d5ba5fcac5b226669d6">&#9670;&#160;</a></span>atcab_challenge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_challenge </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command in pass-through mode to initialize TempKey to a specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Data to be loaded into TempKey (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaadde4309089c569fd87c24a1a2326cd4" name="gaadde4309089c569fd87c24a1a2326cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadde4309089c569fd87c24a1a2326cd4">&#9670;&#160;</a></span>atcab_challenge_seed_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_challenge_seed_update </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command to generate a random challenge combining a host nonce (num_in) and a device random number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Host nonce to be combined with the device random number (20 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>Internally generated 32-byte random number that was used in the nonce/challenge calculation is returned here. Can be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga5ba49c05f7b3fb5acaf55df993ccd3ee" name="ga5ba49c05f7b3fb5acaf55df993ccd3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ba49c05f7b3fb5acaf55df993ccd3ee">&#9670;&#160;</a></span>atcab_checkmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_checkmac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>challenge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a MAC response with input values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location in the CryptoAuth device to use for the MAC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">challenge</td><td>Challenge data (32 bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">response</td><td>MAC response data (32 bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>OtherData parameter (13 bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad50eab1ee1abb18515e914a294668907" name="gad50eab1ee1abb18515e914a294668907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad50eab1ee1abb18515e914a294668907">&#9670;&#160;</a></span>atcab_checkmac_with_response_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_checkmac_with_response_mac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>challenge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a MAC response with input values.SHA105 device can generate optional mac Output response mac mode only supports in SHA105 device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">challenge</td><td>Challenge data (32 bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">response</td><td>MAC response data (32 bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>OtherData parameter (13 bytes) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac</td><td>MAC response (32 bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gadb91d2c3601b95f0ad413cf84a4dfd87" name="gadb91d2c3601b95f0ad413cf84a4dfd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb91d2c3601b95f0ad413cf84a4dfd87">&#9670;&#160;</a></span>atcab_cmp_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_cmp_config_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>same_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a specified configuration zone with the configuration zone currently on the device. </p>
<p>This only compares the static portions of the configuration zone and skips those that are unique per device (first 16 bytes) and areas that can change after the configuration zone has been locked (e.g. LastKeyUse).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config_data</td><td>Full configuration data to compare the device against. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">same_config</td><td>Result is returned here. True if the static portions on the configuration zones are the same.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gabaaaef242649206029e1c10ac6d1fb7d" name="gabaaaef242649206029e1c10ac6d1fb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaaaef242649206029e1c10ac6d1fb7d">&#9670;&#160;</a></span>atcab_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_counter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Counter functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>the mode used for the counter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>The counter to be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_value</td><td>pointer to the counter value returned from device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga6e510e056ea16a0a34b405b7ca378f16" name="ga6e510e056ea16a0a34b405b7ca378f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e510e056ea16a0a34b405b7ca378f16">&#9670;&#160;</a></span>atcab_counter_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_counter_increment </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments one of the device's monotonic counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>Counter to be incremented </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_value</td><td>New value of the counter is returned here. Can be NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaeee666028a097659af69cc828a6bd68b" name="gaeee666028a097659af69cc828a6bd68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeee666028a097659af69cc828a6bd68b">&#9670;&#160;</a></span>atcab_counter_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_counter_read </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one of the device's monotonic counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>Counter to be read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_value</td><td>Counter value is returned here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga34b7b6d46868f0d63d195216ef9939b1" name="ga34b7b6d46868f0d63d195216ef9939b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34b7b6d46868f0d63d195216ef9939b1">&#9670;&#160;</a></span>atcab_derivekey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_derivekey </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Bit 2 must match the value in TempKey.SourceFlag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key slot to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>Optional 32 byte MAC used to validate operation. NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gabd5b5206bd54f7e7513a0c21a3ffbe31" name="gabd5b5206bd54f7e7513a0c21a3ffbe31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd5b5206bd54f7e7513a0c21a3ffbe31">&#9670;&#160;</a></span>atcab_derivekey_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_derivekey_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Bit 2 must match the value in TempKey.SourceFlag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key slot to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>Optional 32 byte MAC used to validate operation. NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga6fc480ad2824df6309f4f370ffad15f9" name="ga6fc480ad2824df6309f4f370ffad15f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fc480ad2824df6309f4f370ffad15f9">&#9670;&#160;</a></span>atcab_ecdh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_ecdh </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in a slot and the premaster secret is returned in the clear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of private key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here. 32 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a id="ga211c9405bb5049dd4a5da92d25c83f3c" name="ga211c9405bb5049dd4a5da92d25c83f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga211c9405bb5049dd4a5da92d25c83f3c">&#9670;&#160;</a></span>atcab_ecdh_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_ecdh_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_nonce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base function for generating premaster secret key using ECDH. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode to be used for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH pre-master secret is returned here (32 bytes) if returned directly. Otherwise NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_nonce</td><td>Nonce used to encrypt pre-master secret. NULL if output encryption not used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga51e3ae10f0596d473f646074650904e6" name="ga51e3ae10f0596d473f646074650904e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51e3ae10f0596d473f646074650904e6">&#9670;&#160;</a></span>atcab_ecdh_enc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_ecdh_enc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>read_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>read_key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>num_in</em>[(20)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in a slot and the premaster secret is read from the next slot. </p>
<p>This function only works for even numbered slots with the proper configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_key</td><td>Read key for the premaster secret slot (key_id|1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_key_id</td><td>Read key slot for read_key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>20 byte host nonce to inject into Nonce calculation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga975f7303086190d3b6f76c367583d622" name="ga975f7303086190d3b6f76c367583d622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga975f7303086190d3b6f76c367583d622">&#9670;&#160;</a></span>atcab_ecdh_ioenc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_ecdh_ioenc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in a slot and the premaster secret is returned encrypted using the IO protection key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gac244b83b061ffd8ae3d59b5f973baa53" name="gac244b83b061ffd8ae3d59b5f973baa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac244b83b061ffd8ae3d59b5f973baa53">&#9670;&#160;</a></span>atcab_ecdh_tempkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_ecdh_tempkey </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in TempKey and the premaster secret is returned in the clear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gafaccb0c9d12154b0c5b917f89f233721" name="gafaccb0c9d12154b0c5b917f89f233721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaccb0c9d12154b0c5b917f89f233721">&#9670;&#160;</a></span>atcab_ecdh_tempkey_ioenc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_ecdh_tempkey_ioenc </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in TempKey and the premaster secret is returned encrypted using the IO protection key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga70751ea87f2cf913986bc7bca2cc661f" name="ga70751ea87f2cf913986bc7bca2cc661f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70751ea87f2cf913986bc7bca2cc661f">&#9670;&#160;</a></span>atcab_gendig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_gendig </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>other_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Designates the source of the data to hash with TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Indicates the key, OTP block, or message order for shared nonce mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>Four bytes of data for SHA calculation when using a NoMac key, 32 bytes for "Shared Nonce" mode, otherwise ignored (can be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data_size</td><td>Size of other_data in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga3f7953865c6091f266e727714e6f91dd" name="ga3f7953865c6091f266e727714e6f91dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f7953865c6091f266e727714e6f91dd">&#9670;&#160;</a></span>atcab_gendivkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_gendivkey </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a GenDivKey command to generate the equivalent diversified key as that programmed into the client side device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>Must match data used when generating the diversified key in the client device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga617bdbdce7b5736351d93214d44c5b8f" name="ga617bdbdce7b5736351d93214d44c5b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga617bdbdce7b5736351d93214d44c5b8f">&#9670;&#160;</a></span>atcab_genkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_genkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues GenKey command, which generates a new random private key in slot/handle and returns the public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot number where an ECC private key is configured. Can also be ATCA_TEMPKEY_KEYID to generate a private key in TempKey. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaa8b6953ad2c7f749e61566fd38fe6903" name="gaa8b6953ad2c7f749e61566fd38fe6903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b6953ad2c7f749e61566fd38fe6903">&#9670;&#160;</a></span>atcab_genkey_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_genkey_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues GenKey command, which can generate a private key, compute a public key, nd/or compute a digest of a public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the GenKey command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot to perform the GenKey command on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>OtherData for PubKey digest calculation. Can be set to NULL otherwise. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>If the mode indicates a public key will be calculated, it will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga301d5e57486fefc1bd19da3cddc5bc0c" name="ga301d5e57486fefc1bd19da3cddc5bc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga301d5e57486fefc1bd19da3cddc5bc0c">&#9670;&#160;</a></span>atcab_genkey_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_genkey_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues GenKey command, which generates a new random private key in slot/handle and returns the public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot number where an ECC private key is configured. Can also be ATCA_TEMPKEY_KEYID to generate a private key in TempKey. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4af82005556c549c30e1c4bd35d4f4e4" name="ga4af82005556c549c30e1c4bd35d4f4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4af82005556c549c30e1c4bd35d4f4e4">&#9670;&#160;</a></span>atcab_get_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01472.html">ATCADevice</a> atcab_get_device </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the global device object. </p>
<dl class="section return"><dt>Returns</dt><dd>instance of global ATCADevice </dd></dl>

</div>
</div>
<a id="ga775bea13de8cc26e61a34ada48358568" name="ga775bea13de8cc26e61a34ada48358568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga775bea13de8cc26e61a34ada48358568">&#9670;&#160;</a></span>atcab_get_device_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t atcab_get_device_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current device address based on the configured device and interface. </p>
<dl class="section return"><dt>Returns</dt><dd>the device address if applicable else 0xFF </dd></dl>

</div>
</div>
<a id="ga2b02163fab87313b81dd7f51345d3eb6" name="ga2b02163fab87313b81dd7f51345d3eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b02163fab87313b81dd7f51345d3eb6">&#9670;&#160;</a></span>atcab_get_device_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCADeviceType atcab_get_device_type </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current device type configured for the global ATCADevice. </p>
<dl class="section return"><dt>Returns</dt><dd>Device type if basic api is initialized or ATCA_DEV_UNKNOWN. </dd></dl>

</div>
</div>
<a id="ga4882d4c30f1af2d1aab24a0c465f181d" name="ga4882d4c30f1af2d1aab24a0c465f181d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4882d4c30f1af2d1aab24a0c465f181d">&#9670;&#160;</a></span>atcab_get_device_type_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCADeviceType atcab_get_device_type_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the selected device type of rthe device context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device type if basic api is initialized or ATCA_DEV_UNKNOWN. </dd></dl>

</div>
</div>
<a id="gad2096a4618dd37c48ed48847fe63d844" name="gad2096a4618dd37c48ed48847fe63d844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2096a4618dd37c48ed48847fe63d844">&#9670;&#160;</a></span>atcab_get_pubkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_get_pubkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses GenKey command to calculate the public key from an existing private key in a slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot number of the private key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae2cbb1989eff2c66935040f41a593bf6" name="gae2cbb1989eff2c66935040f41a593bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2cbb1989eff2c66935040f41a593bf6">&#9670;&#160;</a></span>atcab_get_pubkey_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_get_pubkey_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses GenKey command to calculate the public key from an existing private key in a slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot number of the private key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga7a823d2a391bf80ff336eb2ccbd37412" name="ga7a823d2a391bf80ff336eb2ccbd37412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a823d2a391bf80ff336eb2ccbd37412">&#9670;&#160;</a></span>atcab_get_zone_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_get_zone_size </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the specified zone in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to get size information from. Config(0), OTP(1), or Data(2) which requires a slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If zone is Data(2), the slot to query for size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Zone size is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad65cf773e03aed93e2a1437f13511a91" name="gad65cf773e03aed93e2a1437f13511a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65cf773e03aed93e2a1437f13511a91">&#9670;&#160;</a></span>atcab_get_zone_size_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_get_zone_size_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the specified zone in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to get size information from. Config(0), OTP(1), or Data(2) which requires a slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If zone is Data(2), the slot to query for size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Zone size is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga481179181349c801c16fc1ab698f2f24" name="ga481179181349c801c16fc1ab698f2f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga481179181349c801c16fc1ab698f2f24">&#9670;&#160;</a></span>atcab_hex2bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_hex2bin </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ascii_hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ascii_hex_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bin_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that converts a hex string to binary buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ascii_hex</td><td>Input buffer to convert</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ascii_hex_len</td><td>Length of buffer to convert</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">binary</td><td>Buffer that receives binary</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bin_len</td><td>As input, the size of the bin buffer. As output, the size of the bin data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45f1d09a51f7a1f68916536ab5125b9d" name="ga45f1d09a51f7a1f68916536ab5125b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45f1d09a51f7a1f68916536ab5125b9d">&#9670;&#160;</a></span>atcab_hmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_hmac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a HMAC command, which computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Which key is to be used to generate the response. Bits 0:3 only are used to select a slot but all 16 bits are used in the HMAC message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>HMAC digest is returned in this buffer (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4bf8b665fe1712626a480742c2daa16b" name="ga4bf8b665fe1712626a480742c2daa16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bf8b665fe1712626a480742c2daa16b">&#9670;&#160;</a></span>atcab_hw_sha2_256()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_hw_sha2_256 </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the SHA command to compute a SHA-256 digest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga6ed7e645262fcc32b00d8a9facf09e91" name="ga6ed7e645262fcc32b00d8a9facf09e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ed7e645262fcc32b00d8a9facf09e91">&#9670;&#160;</a></span>atcab_hw_sha2_256_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_hw_sha2_256_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01580.html">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish SHA-256 digest for a SHA context for performing a hardware SHA-256 operation on a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>SHA256 context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>SHA256 digest is returned here (32 bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gade49e7746864105730fa7d531645ff62" name="gade49e7746864105730fa7d531645ff62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade49e7746864105730fa7d531645ff62">&#9670;&#160;</a></span>atcab_hw_sha2_256_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_hw_sha2_256_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01580.html">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a SHA context for performing a hardware SHA-256 operation on a device. Note that only one SHA operation can be run at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>SHA256 context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga67f2ce6224651d9cc65e9915e35558bd" name="ga67f2ce6224651d9cc65e9915e35558bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67f2ce6224651d9cc65e9915e35558bd">&#9670;&#160;</a></span>atcab_hw_sha2_256_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_hw_sha2_256_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01580.html">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add message data to a SHA context for performing a hardware SHA-256 operation on a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>SHA256 context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to be added to hash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf47433a371b9fcb8d65a4214cd9e4fa0" name="gaf47433a371b9fcb8d65a4214cd9e4fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf47433a371b9fcb8d65a4214cd9e4fa0">&#9670;&#160;</a></span>atcab_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_idle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>idle the CryptoAuth device </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga6e19ecd60be4c74665d9ec142e460771" name="ga6e19ecd60be4c74665d9ec142e460771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e19ecd60be4c74665d9ec142e460771">&#9670;&#160;</a></span>atcab_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_info </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>revision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to get the device revision (DevRev). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">revision</td><td>Device revision is returned here (4 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga806d07982fda5c30755af6b5b4ef9314" name="ga806d07982fda5c30755af6b5b4ef9314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga806d07982fda5c30755af6b5b4ef9314">&#9670;&#160;</a></span>atcab_info_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_info_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues an Info command, which return internal device information and can control GPIO and the persistent latch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Selects which mode to be used for info command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2</td><td>Selects the particular fields for the mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_data</td><td>Response from info command (4 bytes). Can be set to NULL if not required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaa7a2f89236943bcd0ed7f6616ccbb043" name="gaa7a2f89236943bcd0ed7f6616ccbb043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7a2f89236943bcd0ed7f6616ccbb043">&#9670;&#160;</a></span>atcab_info_chip_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_info_chip_status </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>chip_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to get the chip status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">chip_status</td><td>returns chip status here</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gacd308bac927905d5c59f526b40c63d76" name="gacd308bac927905d5c59f526b40c63d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd308bac927905d5c59f526b40c63d76">&#9670;&#160;</a></span>atcab_info_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_info_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>revision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to get the device revision (DevRev). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">revision</td><td>Device revision is returned here (4 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga376b6ae92f14c60fba4ca5c6461e0b48" name="ga376b6ae92f14c60fba4ca5c6461e0b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga376b6ae92f14c60fba4ca5c6461e0b48">&#9670;&#160;</a></span>atcab_info_get_latch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_info_get_latch </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to get the persistent latch current state for an ATECC608 device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>The state is returned here. Set (true) or Cler (false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0d11f96c8d4b30c7cfb12a106fed7d35" name="ga0d11f96c8d4b30c7cfb12a106fed7d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d11f96c8d4b30c7cfb12a106fed7d35">&#9670;&#160;</a></span>atcab_info_lock_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_info_lock_status </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to get the lock status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param2</td><td>selects the zone and slot </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>returns lock status here</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2649126606db8a0b64ae8e19d09f6600" name="ga2649126606db8a0b64ae8e19d09f6600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2649126606db8a0b64ae8e19d09f6600">&#9670;&#160;</a></span>atcab_info_set_latch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_info_set_latch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to set the persistent latch state for an ATECC608 device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>Persistent latch state. Set (true) or clear (false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gacdc4fa3d2f2f6d197af8c10ab1f288b8" name="gacdc4fa3d2f2f6d197af8c10ab1f288b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdc4fa3d2f2f6d197af8c10ab1f288b8">&#9670;&#160;</a></span>atcab_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01480.html">ATCAIfaceCfg</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a global ATCADevice object used by Basic API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>Logical interface configuration. Some predefined configurations can be found in <a class="el" href="a00227.html" title="a set of default configurations for various ATCA devices and interfaces">atca_cfgs.h</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab22d2a32e6c32c14c4e58ce794ff3ec4" name="gab22d2a32e6c32c14c4e58ce794ff3ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab22d2a32e6c32c14c4e58ce794ff3ec4">&#9670;&#160;</a></span>atcab_init_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_init_device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>ca_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the global ATCADevice object to point to one of your choosing for use with all the atcab_ basic API. </p>
<dl class="deprecated"><dt><b><a class="el" href="a01400.html#_deprecated000001">Deprecated:</a></b></dt><dd>This function is not recommended for use generally. Use of _ext is recommended instead. You can use atcab_init_ext to obtain an initialized instance and associated it with the global structure - but this shouldn't be a required process except in extremely unusual circumstances.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ca_device</td><td>ATCADevice instance to use as the global Basic API crypto device instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaa1d392a2b2ae7a51907cb724f0465741" name="gaa1d392a2b2ae7a51907cb724f0465741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d392a2b2ae7a51907cb724f0465741">&#9670;&#160;</a></span>atcab_init_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_init_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01480.html">ATCAIfaceCfg</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and initializes a ATCADevice context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">device</td><td>Pointer to the device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfg</td><td>Logical interface configuration. Some predefined configurations can be found in <a class="el" href="a00227.html" title="a set of default configurations for various ATCA devices and interfaces">atca_cfgs.h</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga973437347c3261df0b116fec9ee9c378" name="ga973437347c3261df0b116fec9ee9c378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga973437347c3261df0b116fec9ee9c378">&#9670;&#160;</a></span>atcab_is_ca2_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atcab_is_ca2_device </td>
          <td>(</td>
          <td class="paramtype">ATCADeviceType&#160;</td>
          <td class="paramname"><em>dev_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the device is cryptoauth device. </p>
<dl class="section return"><dt>Returns</dt><dd>True if device is cryptoauth device or False. </dd></dl>

</div>
</div>
<a id="ga6e74da1e2ef3168e48bbc89c44b16d2f" name="ga6e74da1e2ef3168e48bbc89c44b16d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e74da1e2ef3168e48bbc89c44b16d2f">&#9670;&#160;</a></span>atcab_is_ca_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atcab_is_ca_device </td>
          <td>(</td>
          <td class="paramtype">ATCADeviceType&#160;</td>
          <td class="paramname"><em>dev_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the device is cryptoauth device. </p>
<dl class="section return"><dt>Returns</dt><dd>True if device is cryptoauth device or False. </dd></dl>

</div>
</div>
<a id="ga25d0626815c3df9dd2b43d72eecd3a36" name="ga25d0626815c3df9dd2b43d72eecd3a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d0626815c3df9dd2b43d72eecd3a36">&#9670;&#160;</a></span>atcab_is_config_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_is_config_locked </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function check whether configuration zone is locked or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gadac89d52a30b7a11768cf4c5de8d4d08" name="gadac89d52a30b7a11768cf4c5de8d4d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadac89d52a30b7a11768cf4c5de8d4d08">&#9670;&#160;</a></span>atcab_is_config_locked_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_is_config_locked_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function check whether configuration zone is locked or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga44aae7e0a28993eb6abf78bb3d42e26d" name="ga44aae7e0a28993eb6abf78bb3d42e26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44aae7e0a28993eb6abf78bb3d42e26d">&#9670;&#160;</a></span>atcab_is_data_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_is_data_locked </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function check whether data/setup zone is locked or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga7e3189411975d835c0115511556302d8" name="ga7e3189411975d835c0115511556302d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e3189411975d835c0115511556302d8">&#9670;&#160;</a></span>atcab_is_data_locked_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_is_data_locked_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function check whether data/setup zone is locked or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaefce484222bdbedef37787a9b10d4426" name="gaefce484222bdbedef37787a9b10d4426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefce484222bdbedef37787a9b10d4426">&#9670;&#160;</a></span>atcab_is_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_is_locked </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command, which reads the configuration zone to see if the specified zone is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>The zone to query for locked (use LOCK_ZONE_CONFIG or LOCK_ZONE_DATA). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gac5f4cc263fd729871446e01cb063f141" name="gac5f4cc263fd729871446e01cb063f141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5f4cc263fd729871446e01cb063f141">&#9670;&#160;</a></span>atcab_is_private_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_is_private_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_private</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if the key is a private key or not. </p>
<p>This function will issue the Read command as many times as is required to read the requested data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from if zone is ATCA_ZONE_DATA(2). Ignored for all other zones. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_private</td><td>Returned valud if successful. True if key is private.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga802de50265ff91dc30dd7c93d9e026e1" name="ga802de50265ff91dc30dd7c93d9e026e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga802de50265ff91dc30dd7c93d9e026e1">&#9670;&#160;</a></span>atcab_is_slot_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_is_slot_locked </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function check whether slot/handle is locked or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot to query for locked </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4df72bf98b5f19668dc402c35fd4ef17" name="ga4df72bf98b5f19668dc402c35fd4ef17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df72bf98b5f19668dc402c35fd4ef17">&#9670;&#160;</a></span>atcab_is_slot_locked_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_is_slot_locked_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function check whether slot/handle is locked or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot to query for locked </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gadd4e462d88600ee2d36c3c5bf699fde3" name="gadd4e462d88600ee2d36c3c5bf699fde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd4e462d88600ee2d36c3c5bf699fde3">&#9670;&#160;</a></span>atcab_is_ta_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool atcab_is_ta_device </td>
          <td>(</td>
          <td class="paramtype">ATCADeviceType&#160;</td>
          <td class="paramname"><em>dev_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the device is Trust Anchor device. </p>
<dl class="section return"><dt>Returns</dt><dd>True if device is Trust Anchor device or False. </dd></dl>

</div>
</div>
<a id="ga40a6c01492a76366f9402302b527c4e1" name="ga40a6c01492a76366f9402302b527c4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40a6c01492a76366f9402302b527c4e1">&#9670;&#160;</a></span>atcab_kdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_kdf </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>details</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_nonce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the KDF command, which derives a new key in PRF, AES, or HKDF modes. </p>
<p>Generally this function combines a source key with an input string and creates a result key/digest/array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines KDF algorithm (PRF,AES,HKDF), source key location, and target key locations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Source and target key slots if locations are in the EEPROM. Source key slot is the LSB and target key slot is the MSB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">details</td><td>Further information about the computation, depending on the algorithm (4 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Input value from system (up to 128 bytes). Actual size of message is 16 bytes for AES algorithm or is encoded in the MSB of the details parameter for other algorithms. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_data</td><td>Output of the KDF function is returned here. If the result remains in the device, this can be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_nonce</td><td>If the output is encrypted, a 32 byte random nonce generated by the device is returned here. If output encryption is not used, this can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga25d2895192d93c524f5dba92a492cdfb" name="ga25d2895192d93c524f5dba92a492cdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d2895192d93c524f5dba92a492cdfb">&#9670;&#160;</a></span>atcab_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_lock </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>summary_crc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Zone, and/or slot, and summary check (bit 7). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">summary_crc</td><td>CRC of the config or data zones. Ignored for slot locks or when mode bit 7 is set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga7cd67c03c7184ad041e2c0ad4f27db23" name="ga7cd67c03c7184ad041e2c0ad4f27db23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cd67c03c7184ad041e2c0ad4f27db23">&#9670;&#160;</a></span>atcab_lock_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_lock_config_zone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally (no CRC required) lock the config zone. </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0698e0c55ad700fe57498321e842cb38" name="ga0698e0c55ad700fe57498321e842cb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0698e0c55ad700fe57498321e842cb38">&#9670;&#160;</a></span>atcab_lock_config_zone_crc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_lock_config_zone_crc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>summary_crc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the config zone with summary CRC. </p>
<p>The CRC is calculated over the entire config zone contents. 48 bytes for TA100, 88 bytes for ATSHA devices, 128 bytes for ATECC devices. Lock will fail if the provided CRC doesn't match the internally calculated one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">summary_crc</td><td>Expected CRC over the config zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf5059df8d40a5f9f0f5e2004039de424" name="gaf5059df8d40a5f9f0f5e2004039de424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5059df8d40a5f9f0f5e2004039de424">&#9670;&#160;</a></span>atcab_lock_config_zone_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_lock_config_zone_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally (no CRC required) lock the config zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga958190a9182d1b54f82fbca8216406ea" name="ga958190a9182d1b54f82fbca8216406ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga958190a9182d1b54f82fbca8216406ea">&#9670;&#160;</a></span>atcab_lock_data_slot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_lock_data_slot </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1) (for cryptoauth devices) or Lock an individual handle in shared data element on an Trust Anchor device (for Trust Anchor devices). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot to be locked in data zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0d91be168c4b3714cc0177632627bfc3" name="ga0d91be168c4b3714cc0177632627bfc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d91be168c4b3714cc0177632627bfc3">&#9670;&#160;</a></span>atcab_lock_data_slot_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_lock_data_slot_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1) (for cryptoauth devices) or Lock an individual handle in shared data element on an Trust Anchor device (for Trust Anchor devices). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot to be locked in data zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga8020aa89a5bed09ad35320b78e0fb890" name="ga8020aa89a5bed09ad35320b78e0fb890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8020aa89a5bed09ad35320b78e0fb890">&#9670;&#160;</a></span>atcab_lock_data_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_lock_data_zone </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally (no CRC required) lock the data zone (slots and OTP). for CryptoAuth devices and lock the setup for Trust Anchor device. </p>
<p>ConfigZone must be locked and DataZone must be unlocked for the zone to be successfully locked.</p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf29e398e2aca927ab4606aa1ec0308c6" name="gaf29e398e2aca927ab4606aa1ec0308c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf29e398e2aca927ab4606aa1ec0308c6">&#9670;&#160;</a></span>atcab_lock_data_zone_crc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_lock_data_zone_crc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>summary_crc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the data zone (slots and OTP) with summary CRC. </p>
<p>The CRC is calculated over the concatenated contents of all the slots and OTP at the end. Private keys (KeyConfig.Private=1) are skipped. Lock will fail if the provided CRC doesn't match the internally calculated one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">summary_crc</td><td>Expected CRC over the data zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga8105d79d3dd914cf643121ff243b00a3" name="ga8105d79d3dd914cf643121ff243b00a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8105d79d3dd914cf643121ff243b00a3">&#9670;&#160;</a></span>atcab_lock_data_zone_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_lock_data_zone_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally (no CRC required) lock the data zone (slots and OTP). for CryptoAuth devices and lock the setup for Trust Anchor device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context ConfigZone must be locked and DataZone must be unlocked for the zone to be successfully locked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga98cb802fbb5d78cd552bb05c21d6c791" name="ga98cb802fbb5d78cd552bb05c21d6c791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98cb802fbb5d78cd552bb05c21d6c791">&#9670;&#160;</a></span>atcab_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_mac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>challenge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes MAC command, which computes a SHA-256 digest of a key stored in the device, a challenge, and other information on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key in the CryptoAuth device to use for the MAC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">challenge</td><td>Challenge message (32 bytes). May be NULL if mode indicates a challenge isn't required. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>MAC response is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2293df1c1c794496790bae25d3844fa5" name="ga2293df1c1c794496790bae25d3844fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2293df1c1c794496790bae25d3844fa5">&#9670;&#160;</a></span>atcab_nonce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_nonce </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command in pass-through mode to initialize TempKey to a specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Data to be loaded into TempKey (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf8e10791759a8a5e5dcd82774f4895d6" name="gaf8e10791759a8a5e5dcd82774f4895d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8e10791759a8a5e5dcd82774f4895d6">&#9670;&#160;</a></span>atcab_nonce_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_nonce_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Nonce command, which loads a random or fixed nonce/data into the device for use by subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls the mechanism of the internal RNG or fixed write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero</td><td>Param2, normally 0, but can be used to indicate a nonce calculation mode (bit 15). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Input value to either be included in the nonce calculation in random modes (20 bytes) or to be written directly (32 bytes or 64 bytes(ATECC608)) in pass-through mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>If using a random mode, the internally generated 32-byte random number that was used in the nonce calculation is returned here. Can be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2239ae3a87c341a48aa108bd82a58552" name="ga2239ae3a87c341a48aa108bd82a58552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2239ae3a87c341a48aa108bd82a58552">&#9670;&#160;</a></span>atcab_nonce_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_nonce_load </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_in_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command in pass-through mode to load one of the device's internal buffers with a fixed value. </p>
<p>For the ATECC608, available targets are TempKey (32 or 64 bytes), Message Digest Buffer (32 or 64 bytes), or the Alternate Key Buffer (32 bytes). For all other devices, only TempKey (32 bytes) is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Target device buffer to load. Can be NONCE_MODE_TARGET_TEMPKEY, NONCE_MODE_TARGET_MSGDIGBUF, or NONCE_MODE_TARGET_ALTKEYBUF. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Data to load into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in_size</td><td>Size of num_in in bytes. Can be 32 or 64 bytes depending on device and target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaed67d447d547c67b7b8be6b958d1fb5c" name="gaed67d447d547c67b7b8be6b958d1fb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed67d447d547c67b7b8be6b958d1fb5c">&#9670;&#160;</a></span>atcab_nonce_rand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_nonce_rand </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Host nonce to be combined with the device random number (20 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>Internally generated 32-byte random number that was used in the nonce/challenge calculation is returned here. Can be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga89942894a5a8f82391d74346603aa837" name="ga89942894a5a8f82391d74346603aa837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89942894a5a8f82391d74346603aa837">&#9670;&#160;</a></span>atcab_nonce_rand_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_nonce_rand_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Host nonce to be combined with the device random number (20 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>Internally generated 32-byte random number that was used in the nonce/challenge calculation is returned here. Can be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaead7151af044da249b398dc457fc8e06" name="gaead7151af044da249b398dc457fc8e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead7151af044da249b398dc457fc8e06">&#9670;&#160;</a></span>atcab_priv_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_priv_write </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>priv_key</em>[36], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>write_key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>write_key</em>[32], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>num_in</em>[(20)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes PrivWrite command, to write externally generated ECC private keys into the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot to write the external private key into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priv_key</td><td>External private key (36 bytes) to be written. The first 4 bytes should be zero for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_key_id</td><td>Write key slot. Ignored if write_key is NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">write_key</td><td>Write key (32 bytes). If NULL, perform an unencrypted PrivWrite, which is only available when the data zone is unlocked. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>20 byte host nonce to inject into Nonce calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4fa442396dfbb89e59dfca837b565cec" name="ga4fa442396dfbb89e59dfca837b565cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fa442396dfbb89e59dfca837b565cec">&#9670;&#160;</a></span>atcab_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_random </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Random command, which generates a 32 byte random number from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>32 bytes of random data is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga103f4596f0f9590971763592c5233ec3" name="ga103f4596f0f9590971763592c5233ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga103f4596f0f9590971763592c5233ec3">&#9670;&#160;</a></span>atcab_random_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_random_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Random command, which generates a 32 byte random number from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>32 bytes of random data is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga750704332198726725a327344f4f7dd5" name="ga750704332198726725a327344f4f7dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga750704332198726725a327344f4f7dd5">&#9670;&#160;</a></span>atcab_read_bytes_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_read_bytes_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to read an arbitrary number of bytes from any zone configured for clear reads. </p>
<p>This function will issue the Read command as many times as is required to read the requested data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to read data from. Option are ATCA_ZONE_CONFIG(0), ATCA_ZONE_OTP(1), or ATCA_ZONE_DATA(2). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from if zone is ATCA_ZONE_DATA(2). Ignored for all other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Byte offset within the zone to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Read data is returned here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to read starting from the offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga8ef47330eef6bc72ae8f7a8ef026dae3" name="ga8ef47330eef6bc72ae8f7a8ef026dae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ef47330eef6bc72ae8f7a8ef026dae3">&#9670;&#160;</a></span>atcab_read_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_read_config_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read the complete device configuration zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">config_data</td><td>Configuration zone data is returned here. 88 bytes for ATSHA devices, 128 bytes for ATECC devices and 48 bytes for Trust Anchor devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga9ee98f13a88710e5234266b4b456b1dc" name="ga9ee98f13a88710e5234266b4b456b1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee98f13a88710e5234266b4b456b1dc">&#9670;&#160;</a></span>atcab_read_config_zone_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_read_config_zone_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read the complete device configuration zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>device context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">config_data</td><td>Configuration zone data is returned here. 88 bytes for ATSHA devices, 128 bytes for ATECC devices and 48 bytes for Trust Anchor devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0cf0048247bb577c85142510225ea960" name="ga0cf0048247bb577c85142510225ea960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cf0048247bb577c85142510225ea960">&#9670;&#160;</a></span>atcab_read_enc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_read_enc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>enc_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>enc_key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>num_in</em>[(20)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command on a slot configured for encrypted reads and decrypts the data to return it as plaintext. </p>
<p>Data zone must be locked for this command to succeed. Can only read 32 byte blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>The slot ID to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index of the 32 byte block within the slot to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Decrypted (plaintext) data from the read is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enc_key</td><td>32 byte ReadKey for the slot being read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enc_key_id</td><td>KeyID of the ReadKey being used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>20 byte host nonce to inject into Nonce calculation</td></tr>
  </table>
  </dd>
</dl>
<p>returns ATCA_SUCCESS on success, otherwise an error code. </p>

</div>
</div>
<a id="ga782ca1e5b1574b2b6793c841be22b28b" name="ga782ca1e5b1574b2b6793c841be22b28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga782ca1e5b1574b2b6793c841be22b28b">&#9670;&#160;</a></span>atcab_read_pubkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_read_pubkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read an ECC P256 public key from a slot configured for clear reads. </p>
<p>This function assumes the public key is stored using the ECC public key format specified in the datasheet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from. Only slots 8 to 15 are large enough for a public key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key is returned here (64 bytes). Format will be the 32 byte X and Y big-endian integers concatenated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2ea51a5aafd900c9bdffeffe82274255" name="ga2ea51a5aafd900c9bdffeffe82274255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ea51a5aafd900c9bdffeffe82274255">&#9670;&#160;</a></span>atcab_read_pubkey_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_read_pubkey_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read an ECC P256 public key from a slot configured for clear reads. </p>
<p>This function assumes the public key is stored using the ECC public key format specified in the datasheet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from. Only slots 8 to 15 are large enough for a public key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key is returned here (64 bytes). Format will be the 32 byte X and Y big-endian integers concatenated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga96c434878e1f435e2cda5b0b5fec444f" name="ga96c434878e1f435e2cda5b0b5fec444f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96c434878e1f435e2cda5b0b5fec444f">&#9670;&#160;</a></span>atcab_read_serial_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_read_serial_number </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>serial_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns serial number of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">serial_number</td><td>9 byte serial number is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga8a741e461c20d2a72493bc6178826eb1" name="ga8a741e461c20d2a72493bc6178826eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a741e461c20d2a72493bc6178826eb1">&#9670;&#160;</a></span>atcab_read_serial_number_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_read_serial_number_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>serial_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns serial number of the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serial_number</td><td>9 byte serial number is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga098c4c2c724b90b7e2f4ecf12b9530b7" name="ga098c4c2c724b90b7e2f4ecf12b9530b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga098c4c2c724b90b7e2f4ecf12b9530b7">&#9670;&#160;</a></span>atcab_read_sig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_read_sig </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read a 64 byte ECDSA P256 signature from a slot configured for clear reads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from. Only slots 8 to 15 are large enough for a signature. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sig</td><td>Signature will be returned here (64 bytes). Format will be the 32 byte R and S big-endian integers concatenated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga3ce01f02f456c08891ca1d67cd3ed0eb" name="ga3ce01f02f456c08891ca1d67cd3ed0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ce01f02f456c08891ca1d67cd3ed0eb">&#9670;&#160;</a></span>atcab_read_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_read_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command, which reads either 4 or 32 bytes of data from a given slot, configuration zone, or the OTP zone. </p>
<p>When reading a slot or OTP, data zone must be locked and the slot configuration must not be secret for a slot to be successfully read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to be read from device. Options are ATCA_ZONE_CONFIG, ATCA_ZONE_OTP, or ATCA_ZONE_DATA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number for data zone and ignored for other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>32 byte block index within the zone. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>4 byte work index within the block. Ignored for 32 byte reads. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Read data is returned here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data to be read. Must be either 4 or 32.</td></tr>
  </table>
  </dd>
</dl>
<p>returns ATCA_SUCCESS on success, otherwise an error code. </p>

</div>
</div>
<a id="ga3a061c1f96bb641b36fc56b6cb2dd4e4" name="ga3a061c1f96bb641b36fc56b6cb2dd4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a061c1f96bb641b36fc56b6cb2dd4e4">&#9670;&#160;</a></span>atcab_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_release </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release (free) the global ATCADevice instance. This must be called in order to release or free up the interface. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns ATCA_SUCCESS . </dd></dl>

</div>
</div>
<a id="ga147803646532319e585a0fe7a6c028ef" name="ga147803646532319e585a0fe7a6c028ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga147803646532319e585a0fe7a6c028ef">&#9670;&#160;</a></span>atcab_release_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_release_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>release (free) the an ATCADevice instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to the device context pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns ATCA_SUCCESS . </dd></dl>

</div>
</div>
<a id="ga7371f490659b6fd68739d2b1fee50696" name="ga7371f490659b6fd68739d2b1fee50696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7371f490659b6fd68739d2b1fee50696">&#9670;&#160;</a></span>atcab_reversal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_reversal </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To reverse the input data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bin</td><td>Input data to reverse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bin_size</td><td>Size of data to reverse. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>Buffer to store reversed binary data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_size</td><td>The size of the dest buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga9506331ea7d454fe3c9b2585128c77aa" name="ga9506331ea7d454fe3c9b2585128c77aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9506331ea7d454fe3c9b2585128c77aa">&#9670;&#160;</a></span>atcab_secureboot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_secureboot </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Secure Boot command, which provides support for secure boot of an external MCU or MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the SecureBoot command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2</td><td>Not used, must be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">digest</td><td>Digest of the code to be verified (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature of the code to be verified (64 bytes). Can be NULL when using the FullStore mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac</td><td>Validating MAC will be returned here (32 bytes). Can be NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga5c11f2012a03ec79cb46de8e03ed0534" name="ga5c11f2012a03ec79cb46de8e03ed0534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c11f2012a03ec79cb46de8e03ed0534">&#9670;&#160;</a></span>atcab_secureboot_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_secureboot_mac </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Secure Boot command with encrypted digest and validated MAC response using the IO protection key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the SecureBoot command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">digest</td><td>Digest of the code to be verified (32 bytes). This is the plaintext digest (not encrypted). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature of the code to be verified (64 bytes). Can be NULL when using the FullStore mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Host nonce (20 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key (32 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Verify result is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaeb4a36bc6992612cc3b1f950c0d020b7" name="gaeb4a36bc6992612cc3b1f950c0d020b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb4a36bc6992612cc3b1f950c0d020b7">&#9670;&#160;</a></span>atcab_selftest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_selftest </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the SelfTest command, which performs a test of one or more of the cryptographic engines within the ATECC608 chip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Functions to test. Can be a bit field combining any of the following: SELFTEST_MODE_RNG, SELFTEST_MODE_ECDSA_VERIFY, SELFTEST_MODE_ECDSA_SIGN, SELFTEST_MODE_ECDH, SELFTEST_MODE_AES, SELFTEST_MODE_SHA, SELFTEST_MODE_ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2</td><td>Currently unused, should be 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Results are returned here as a bit field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga31d269ccdafd08519a899a8aebf53df1" name="ga31d269ccdafd08519a899a8aebf53df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d269ccdafd08519a899a8aebf53df1">&#9670;&#160;</a></span>atcab_sha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the SHA command to compute a SHA-256 digest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Size of message parameter in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message data to be hashed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab3a32e171ca1c30bd31a216b32c9b5a4" name="gab3a32e171ca1c30bd31a216b32c9b5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a32e171ca1c30bd31a216b32c9b5a4">&#9670;&#160;</a></span>atcab_sha_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data_out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command, which computes a SHA-256 or HMAC/SHA-256 digest for general purpose use by the host system. </p>
<p>Only the Start(0) and Compute(1) modes are available for ATSHA devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>SHA command mode Start(0), Update/Compute(1), End(2), Public(3), HMACstart(4), HMACend(5), Read_Context(6), or Write_Context(7). Also message digest target location for the ATECC608. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes in the message parameter or KeySlot for the HMAC key if Mode is HMACstart(4) or Public(3). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_in</td><td>Message bytes to be hashed or Write_Context if restoring a context on the ATECC608. Can be NULL if not required by the mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_out</td><td>Data returned by the command (digest or context). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_out_size</td><td>As input, the size of the data_out buffer. As output, the number of bytes returned in data_out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga1db86704035048066a370815b657234d" name="ga1db86704035048066a370815b657234d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1db86704035048066a370815b657234d">&#9670;&#160;</a></span>atcab_sha_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_end </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to complete SHA-256 or HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest from SHA-256 or HMAC/SHA-256 will be returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of any remaining data to include in hash. Max 64 bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Remaining data to include in hash. NULL if length is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae655ce06583c08169170102fbb0b55c9" name="gae655ce06583c08169170102fbb0b55c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae655ce06583c08169170102fbb0b55c9">&#9670;&#160;</a></span>atcab_sha_hmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_hmac </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the SHA command to compute an HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_slot</td><td>Slot key id to use for the HMAC calculation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Where to save the digest internal to the device. For ATECC608, can be SHA_MODE_TARGET_TEMPKEY, SHA_MODE_TARGET_MSGDIGBUF, or SHA_MODE_TARGET_OUT_ONLY. For all other devices, SHA_MODE_TARGET_TEMPKEY is the only option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaede6ae09e6192e452ad261f4e15e1c62" name="gaede6ae09e6192e452ad261f4e15e1c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaede6ae09e6192e452ad261f4e15e1c62">&#9670;&#160;</a></span>atcab_sha_hmac_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_hmac_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the SHA command to compute an HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_slot</td><td>Slot key id to use for the HMAC calculation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Where to save the digest internal to the device. For ATECC608, can be SHA_MODE_TARGET_TEMPKEY, SHA_MODE_TARGET_MSGDIGBUF, or SHA_MODE_TARGET_OUT_ONLY. For all other devices, SHA_MODE_TARGET_TEMPKEY is the only option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaa4be9972396b7cadb08dd8e2199daf08" name="gaa4be9972396b7cadb08dd8e2199daf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4be9972396b7cadb08dd8e2199daf08">&#9670;&#160;</a></span>atcab_sha_hmac_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_hmac_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01580.html">atca_hmac_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to complete a HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>HMAC/SHA-256 context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>HMAC/SHA-256 result is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Where to save the digest internal to the device. For ATECC608, can be SHA_MODE_TARGET_TEMPKEY, SHA_MODE_TARGET_MSGDIGBUF, or SHA_MODE_TARGET_OUT_ONLY. For all other devices, SHA_MODE_TARGET_TEMPKEY is the only option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga310a017cddce9ef05071cb619b4b6db9" name="ga310a017cddce9ef05071cb619b4b6db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga310a017cddce9ef05071cb619b4b6db9">&#9670;&#160;</a></span>atcab_sha_hmac_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_hmac_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01580.html">atca_hmac_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to start an HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>HMAC/SHA-256 context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_slot</td><td>Slot key id to use for the HMAC calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae3343c160e80365b7e96bdfdc9b6365c" name="gae3343c160e80365b7e96bdfdc9b6365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3343c160e80365b7e96bdfdc9b6365c">&#9670;&#160;</a></span>atcab_sha_hmac_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_hmac_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01580.html">atca_hmac_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to add an arbitrary amount of message data to a HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>HMAC/SHA-256 context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of message data in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga74d1db50562642ce511fa7cbd384c2ab" name="ga74d1db50562642ce511fa7cbd384c2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74d1db50562642ce511fa7cbd384c2ab">&#9670;&#160;</a></span>atcab_sha_read_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_read_context </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>context_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to read the SHA-256 context back. Only for ATECC608 with SHA-256 contexts. HMAC not supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>Context data is returned here. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context_size</td><td>As input, the size of the context buffer in bytes. As output, the size of the returned context data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae0a7ef89fce4cbd0ee1c76759cd93b9a" name="gae0a7ef89fce4cbd0ee1c76759cd93b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a7ef89fce4cbd0ee1c76759cd93b9a">&#9670;&#160;</a></span>atcab_sha_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to initialize SHA-256 calculation engine. </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga39bd70baa7a4c7f4849fcf8b94d4d949" name="ga39bd70baa7a4c7f4849fcf8b94d4d949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39bd70baa7a4c7f4849fcf8b94d4d949">&#9670;&#160;</a></span>atcab_sha_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_update </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to add 64 bytes of message data to the current context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>64 bytes of message data to add to add to operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga070fa80ac0d76f6816d9f7affbcfb120" name="ga070fa80ac0d76f6816d9f7affbcfb120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga070fa80ac0d76f6816d9f7affbcfb120">&#9670;&#160;</a></span>atcab_sha_write_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sha_write_context </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>context_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to write (restore) a SHA-256 context into the the device. Only supported for ATECC608 with SHA-256 contexts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context data to be restored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_size</td><td>Size of the context data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga69b8282d1b1e0c54b9a7d286fed503b8" name="ga69b8282d1b1e0c54b9a7d286fed503b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69b8282d1b1e0c54b9a7d286fed503b8">&#9670;&#160;</a></span>atcab_sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sign </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of the private key to be used to sign the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>32-byte message to be signed. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature will be returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga5c1e598bf3d4d25b522f42d6038a4268" name="ga5c1e598bf3d4d25b522f42d6038a4268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1e598bf3d4d25b522f42d6038a4268">&#9670;&#160;</a></span>atcab_sign_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sign_base </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Sign command, which generates a signature using the ECDSA algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what the source of the message to be signed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Private key slot used to sign the message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature is returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4b76ca12e6f7236d9ef3235b174f48cc" name="ga4b76ca12e6f7236d9ef3235b174f48cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b76ca12e6f7236d9ef3235b174f48cc">&#9670;&#160;</a></span>atcab_sign_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sign_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of the private key to be used to sign the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>32-byte message to be signed. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature will be returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga559add3e8b4f85a9d91fc0ed86aefa29" name="ga559add3e8b4f85a9d91fc0ed86aefa29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga559add3e8b4f85a9d91fc0ed86aefa29">&#9670;&#160;</a></span>atcab_sign_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sign_internal </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_invalidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_full_sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Sign command to sign an internally generated message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of the private key to be used to sign the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_invalidate</td><td>Set to true if the signature will be used with the Verify(Invalidate) command. false for all other cases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_full_sn</td><td>Set to true if the message should incorporate the device's full serial number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature is returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga9475e032c388144c5a0df45d1df182a5" name="ga9475e032c388144c5a0df45d1df182a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9475e032c388144c5a0df45d1df182a5">&#9670;&#160;</a></span>atcab_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>invoke sleep on the CryptoAuth device </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga416e4aeacf3acc35b1d5b76028c6947d" name="ga416e4aeacf3acc35b1d5b76028c6947d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga416e4aeacf3acc35b1d5b76028c6947d">&#9670;&#160;</a></span>atcab_updateextra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_updateextra </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes UpdateExtra command to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85). </p>
<p>Can also be used to decrement the limited use counter associated with the key in slot NewValue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the UpdateExtra command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_value</td><td>Value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga694d921c7bc17a0e158ef96e3d476700" name="ga694d921c7bc17a0e158ef96e3d476700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga694d921c7bc17a0e158ef96e3d476700">&#9670;&#160;</a></span>atcab_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_verify </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command. </p>
<p>For the Stored, External, and ValidateExternal Modes, the contents of TempKey (or Message Digest Buffer in some cases for the ATECC608) should contain the 32 byte message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Verify command mode and options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Stored mode, the slot containing the public key to be used for the verification. ValidateExternal mode, the slot containing the public key to be validated. External mode, KeyID contains the curve type to be used to Verify the signature. Validate or Invalidate mode, the slot containing the public key to be (in)validated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>If mode is External, the public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. NULL for all other modes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>If mode is Validate, the bytes used to generate the message for the validation (19 bytes). NULL for all other modes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac</td><td>If mode indicates a validating MAC, then the MAC will will be returned here. Can be NULL otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2c3e18de900ba705192963d08b37f600" name="ga2c3e18de900ba705192963d08b37f600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c3e18de900ba705192963d08b37f600">&#9670;&#160;</a></span>atcab_verify_extern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_verify_extern </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="ga3a4e2ffada9173db1a775a697bbebf18" name="ga3a4e2ffada9173db1a775a697bbebf18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a4e2ffada9173db1a775a697bbebf18">&#9670;&#160;</a></span>atcab_verify_extern_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_verify_extern_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="ga17bf17c4786be097a0bb111a6f9d8ca6" name="ga17bf17c4786be097a0bb111a6f9d8ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17bf17c4786be097a0bb111a6f9d8ca6">&#9670;&#160;</a></span>atcab_verify_extern_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_verify_extern_mac </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. This function is only available on the ATECC608. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>System nonce (32 byte) used for the verification MAC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key for verifying the validation MAC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="ga9393b545b2fa1fdd539672a0428a30ab" name="ga9393b545b2fa1fdd539672a0428a30ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9393b545b2fa1fdd539672a0428a30ab">&#9670;&#160;</a></span>atcab_verify_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_verify_invalidate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command in Invalidate mode which invalidates a previously validated public key stored in a slot. </p>
<p>This command can only be run after GenKey has been used to create a PubKey digest of the public key to be invalidated in TempKey (mode=0x10).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be invalidated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>19 bytes of data used to build the verification message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, validation public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gae8cc7670847805423ad591985eecd832" name="gae8cc7670847805423ad591985eecd832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8cc7670847805423ad591985eecd832">&#9670;&#160;</a></span>atcab_verify_stored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_verify_stored </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be used in the verification. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gad08f6cceac6e8147aeb6f665dc0a2aff" name="gad08f6cceac6e8147aeb6f665dc0a2aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad08f6cceac6e8147aeb6f665dc0a2aff">&#9670;&#160;</a></span>atcab_verify_stored_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_verify_stored_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be used in the verification. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gaa52cdbbfd2f089d8eb42ef2640204ca7" name="gaa52cdbbfd2f089d8eb42ef2640204ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52cdbbfd2f089d8eb42ef2640204ca7">&#9670;&#160;</a></span>atcab_verify_stored_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_verify_stored_mac </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with a public key stored in the device. This function is only available on the ATECC608. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be used in the verification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>System nonce (32 byte) used for the verification MAC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key for verifying the validation MAC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="ga582dc8686f0491ad4292287f6971543c" name="ga582dc8686f0491ad4292287f6971543c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga582dc8686f0491ad4292287f6971543c">&#9670;&#160;</a></span>atcab_verify_stored_with_tempkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_verify_stored_with_tempkey </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. keyConfig.reqrandom bit should be set and the message to be signed should be already loaded into TempKey for all devices. </p>
<p>Please refer to TEST(atca_cmd_basic_test, verify_stored_on_reqrandom_set) in atca_tests_verify.c for proper use of this api</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be used in the verification. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gacf9a0c7772ebb65b87c4a4788850702b" name="gacf9a0c7772ebb65b87c4a4788850702b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9a0c7772ebb65b87c4a4788850702b">&#9670;&#160;</a></span>atcab_verify_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_verify_validate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command in Validate mode to validate a public key stored in a slot. </p>
<p>This command can only be run after GenKey has been used to create a PubKey digest of the public key to be validated in TempKey (mode=0x10).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be validated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>19 bytes of data used to build the verification message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, validation public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gaff701132013eaac5600dd9fd6253505d" name="gaff701132013eaac5600dd9fd6253505d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff701132013eaac5600dd9fd6253505d">&#9670;&#160;</a></span>atcab_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_version </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ver_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>basic API methods are all prefixed with atcab_ (CryptoAuthLib Basic) the fundamental premise of the basic API is it is based on a single interface instance and that instance is global, so all basic API commands assume that one global device is the one to operate on. </p>
<p>returns a version string for the CryptoAuthLib release. The format of the version string returned is "yyyymmdd" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ver_str</td><td>ptr to space to receive version string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad3bc620aedd9322d160eece0d8d20c82" name="gad3bc620aedd9322d160eece0d8d20c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3bc620aedd9322d160eece0d8d20c82">&#9670;&#160;</a></span>atcab_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_wakeup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wakeup the CryptoAuth device </p>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gabf2b29b4d3ae926b63c403d084380dbe" name="gabf2b29b4d3ae926b63c403d084380dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf2b29b4d3ae926b63c403d084380dbe">&#9670;&#160;</a></span>atcab_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes either one four byte word or a 32-byte block to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone/Param1 for the write command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address/Param2 for the write command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Plain-text data to be written or cipher-text for encrypted writes. 32 or 4 bytes depending on bit 7 in the zone. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>MAC required for encrypted writes (32 bytes). Set to NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gac395a7e195aa3cf28b48de345755feb0" name="gac395a7e195aa3cf28b48de345755feb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac395a7e195aa3cf28b48de345755feb0">&#9670;&#160;</a></span>atcab_write_bytes_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_write_bytes_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes data into the configuration, otp, or data zones with a given byte offset and length. Offset and length must be multiples of a word (4 bytes). </p>
<p>Config zone must be unlocked for writes to that zone. If data zone is unlocked, only 32-byte writes are allowed to slots and OTP and the offset and length must be multiples of 32 or the write will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to write data to: ATCA_ZONE_CONFIG(0), ATCA_ZONE_OTP(1), or ATCA_ZONE_DATA(2). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If zone is ATCA_ZONE_DATA(2), the slot number to write to. Ignored for all other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_bytes</td><td>Byte offset within the zone to write to. Must be a multiple of a word (4 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to be written. Must be a multiple of a word (4 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab25ca44957dff1c2df34607738ca3bf7" name="gab25ca44957dff1c2df34607738ca3bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab25ca44957dff1c2df34607738ca3bf7">&#9670;&#160;</a></span>atcab_write_config_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_write_config_counter </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize one of the monotonic counters in device with a specific value. </p>
<p>The monotonic counters are stored in the configuration zone using a special format. This encodes a binary count value into the 8 byte encoded value required. Can only be set while the configuration zone is unlocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>Counter to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_value</td><td>Counter value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0777a86aa412a97b19cc72a12c171b94" name="ga0777a86aa412a97b19cc72a12c171b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0777a86aa412a97b19cc72a12c171b94">&#9670;&#160;</a></span>atcab_write_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_write_config_zone </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes the configuration zone. </p>
<p>First 16 bytes are skipped as they are not writable. LockValue and LockConfig are also skipped and can only be changed via the Lock command.</p>
<p>This command may fail if UserExtra and/or Selector bytes have already been set to non-zero values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config_data</td><td>Data to the config zone data. This should be 88 bytes for SHA devices and 128 bytes for ECC devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga92d651c637007f8c3672c3313767c0e7" name="ga92d651c637007f8c3672c3313767c0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d651c637007f8c3672c3313767c0e7">&#9670;&#160;</a></span>atcab_write_config_zone_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_write_config_zone_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes the configuration zone. </p>
<p>First 16 bytes are skipped as they are not writable. LockValue and LockConfig are also skipped and can only be changed via the Lock command.</p>
<p>This command may fail if UserExtra and/or Selector bytes have already been set to non-zero values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config_data</td><td>Data to the config zone data. This should be 88 bytes for SHA devices and 128 bytes for ECC devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga78a5394997ea31b125cd57d07aa73636" name="ga78a5394997ea31b125cd57d07aa73636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78a5394997ea31b125cd57d07aa73636">&#9670;&#160;</a></span>atcab_write_enc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_write_enc </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>enc_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>enc_key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>num_in</em>[(20)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which performs an encrypted write of a 32 byte block into given slot. </p>
<p>The function takes clear text bytes and encrypts them for writing over the wire. Data zone must be locked and the slot configuration must be set to encrypted write for the block to be successfully written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot ID to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index of the 32 byte block to write in the slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>32 bytes of clear text data to be written to the slot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enc_key</td><td>WriteKey to encrypt with for writing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enc_key_id</td><td>The KeyID of the WriteKey </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>20 byte host nonce to inject into Nonce calculation</td></tr>
  </table>
  </dd>
</dl>
<p>returns ATCA_SUCCESS on success, otherwise an error code. </p>

</div>
</div>
<a id="ga47cbedeb3c3e9f7cbf2b9433cd60d1aa" name="ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47cbedeb3c3e9f7cbf2b9433cd60d1aa">&#9670;&#160;</a></span>atcab_write_pubkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_write_pubkey </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the write command to write a public key to a slot in the proper format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to write. Only slots 8 to 15 are large enough to store a public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key to write into the slot specified. X and Y integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaa80d6c193374d363649236778289f2ea" name="gaa80d6c193374d363649236778289f2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80d6c193374d363649236778289f2ea">&#9670;&#160;</a></span>atcab_write_pubkey_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_write_pubkey_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the write command to write a public key to a slot in the proper format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to write. Only slots 8 to 15 are large enough to store a public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key to write into the slot specified. X and Y integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga1f5a6bbcf4f840803635fb8951b3a7e2" name="ga1f5a6bbcf4f840803635fb8951b3a7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f5a6bbcf4f840803635fb8951b3a7e2">&#9670;&#160;</a></span>atcab_write_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_write_zone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes either 4 or 32 bytes of data into a device zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Device zone to write to (0=config, 1=OTP, 2=data). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If writing to the data zone, it is the slot to write to, otherwise it should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>32-byte block to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>4-byte word within the specified block to write to. If performing a 32-byte write, this should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to be written. Must be either 4 or 32.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad03eaf30d3d776260ad57ff05c2d6aa1" name="gad03eaf30d3d776260ad57ff05c2d6aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad03eaf30d3d776260ad57ff05c2d6aa1">&#9670;&#160;</a></span>atcab_write_zone_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS atcab_write_zone_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01472.html">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes either 4 or 32 bytes of data into a device zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Device zone to write to (0=config, 1=OTP, 2=data). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If writing to the data zone, it is the slot to write to, otherwise it should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>32-byte block to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>4-byte word within the specified block to write to. If performing a 32-byte write, this should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to be written. Must be either 4 or 32.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga592c23e94097ad5e212beb6390aa88c6" name="ga592c23e94097ad5e212beb6390aa88c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga592c23e94097ad5e212beb6390aa88c6">&#9670;&#160;</a></span>isAlpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isAlpha </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f')) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a hex </dd></dl>

</div>
</div>
<a id="gac873a37c53fdd922d5b36efd737e3ec3" name="gac873a37c53fdd922d5b36efd737e3ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac873a37c53fdd922d5b36efd737e3ec3">&#9670;&#160;</a></span>isBase64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isBase64 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid base 64 character or if this is space (A character can be included in a valid base 64 string). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules</td><td>base64 ruleset to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid base 64 string </dd></dl>

</div>
</div>
<a id="gad10d15454308230fbef54bdd43001ed2" name="gad10d15454308230fbef54bdd43001ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad10d15454308230fbef54bdd43001ed2">&#9670;&#160;</a></span>isBase64Digit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isBase64Digit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid base 64 character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rules</td><td>base64 ruleset to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid base 64 string </dd></dl>

</div>
</div>
<a id="ga04fefe2ff5a7d2e937b2634acd22982a" name="ga04fefe2ff5a7d2e937b2634acd22982a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04fefe2ff5a7d2e937b2634acd22982a">&#9670;&#160;</a></span>isBlankSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isBlankSpace </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is blank space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is blankspace </dd></dl>

</div>
</div>
<a id="ga7a929bf65cbc777bab7e533a2755cfad" name="ga7a929bf65cbc777bab7e533a2755cfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a929bf65cbc777bab7e533a2755cfad">&#9670;&#160;</a></span>isDigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is an ASCII representation of a digit ((c ge '0') and (c le '9')) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a digit </dd></dl>

</div>
</div>
<a id="gab7ca9ee391118aafe6f3cf7df4fa5de3" name="gab7ca9ee391118aafe6f3cf7df4fa5de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ca9ee391118aafe6f3cf7df4fa5de3">&#9670;&#160;</a></span>isHex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isHex </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid hex character or if this is blankspace (The character can be included in a valid hexstring). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid hexstring </dd></dl>

</div>
</div>
<a id="ga78abefc293c0a04d8ef649c94c8a1057" name="ga78abefc293c0a04d8ef649c94c8a1057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78abefc293c0a04d8ef649c94c8a1057">&#9670;&#160;</a></span>isHexAlpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isHexAlpha </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a character is an ASCII representation of hex ((c &gt;= 'A') and (c &lt;= 'F')) || ((c &gt;= 'a') and (c &lt;= 'f')) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character is a hex </dd></dl>

</div>
</div>
<a id="ga39003da4dc8a0b8999f1325c2f96f641" name="ga39003da4dc8a0b8999f1325c2f96f641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39003da4dc8a0b8999f1325c2f96f641">&#9670;&#160;</a></span>isHexDigit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isHexDigit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this character is a valid hex character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the character can be included in a valid hexstring </dd></dl>

</div>
</div>
<a id="gad017ae33af5a7ea062cea7d54de675a8" name="gad017ae33af5a7ea062cea7d54de675a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad017ae33af5a7ea062cea7d54de675a8">&#9670;&#160;</a></span>packHex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ATCA_STATUS packHex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ascii_hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ascii_hex_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>packed_hex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>packed_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove spaces from a ASCII hex string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ascii_hex</td><td>Initial hex string to remove blankspace from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ascii_hex_len</td><td>Length of the initial hex string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packed_hex</td><td>Resulting hex string without blankspace </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packed_len</td><td>In: Size to packed_hex buffer Out: Number of bytes in the packed hex string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>

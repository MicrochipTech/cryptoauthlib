<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CryptoAuthLib: atca_basic.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="microchip.png"/></td>
  <td id="projectalign">
   <div id="projectname">CryptoAuthLib<span id="projectnumber">&#160;v3.7.5</span>
   </div>
   <div id="projectbrief">Microchip CryptoAuthentication Library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a00224.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">atca_basic.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>CryptoAuthLib Basic API methods - a simple crypto authentication API. These methods manage a global ATCADevice object behind the scenes. They also manage the wake/idle state transitions so callers don't need to.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="a00506.html">cryptoauthlib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="a00485.html">crypto/atca_crypto_sw_sha2.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="a00446.html">crypto/atca_crypto_hw_aes.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga55663492574ac6d6b6cb5ad39c632031"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_get_addr</b>(...)&#160;&#160;&#160;<a class="el" href="a01444.html#gae51a67781e9e4618e669db1c999e6ec2">calib_get_addr</a>(__VA_ARGS__)</td></tr>
<tr class="separator:ga55663492574ac6d6b6cb5ad39c632031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7f8ac7b0159edf31a623dbaac0ae97"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>atca_execute_command</b>(...)&#160;&#160;&#160;<a class="el" href="a00371.html#a19fc558e09f03a2f8f5ee89b1e396b2e">calib_execute_command</a>(__VA_ARGS__)</td></tr>
<tr class="separator:gadf7f8ac7b0159edf31a623dbaac0ae97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d37a5da1c43d44e49c4e6614d133c7e"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SHA_CONTEXT_MAX_SIZE</b>&#160;&#160;&#160;(109)</td></tr>
<tr class="separator:ga3d37a5da1c43d44e49c4e6614d133c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaff701132013eaac5600dd9fd6253505d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaff701132013eaac5600dd9fd6253505d">atcab_version</a> (char *ver_str)</td></tr>
<tr class="memdesc:gaff701132013eaac5600dd9fd6253505d"><td class="mdescLeft">&#160;</td><td class="mdescRight">basic API methods are all prefixed with atcab_ (CryptoAuthLib Basic) the fundamental premise of the basic API is it is based on a single interface instance and that instance is global, so all basic API commands assume that one global device is the one to operate on.  <br /></td></tr>
<tr class="separator:gaff701132013eaac5600dd9fd6253505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d392a2b2ae7a51907cb724f0465741"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaa1d392a2b2ae7a51907cb724f0465741">atcab_init_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> *device, <a class="el" href="a01516.html">ATCAIfaceCfg</a> *cfg)</td></tr>
<tr class="memdesc:gaa1d392a2b2ae7a51907cb724f0465741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a ATCADevice context.  <br /></td></tr>
<tr class="separator:gaa1d392a2b2ae7a51907cb724f0465741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gacdc4fa3d2f2f6d197af8c10ab1f288b8">atcab_init</a> (<a class="el" href="a01516.html">ATCAIfaceCfg</a> *cfg)</td></tr>
<tr class="memdesc:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a global ATCADevice object used by Basic API.  <br /></td></tr>
<tr class="separator:gacdc4fa3d2f2f6d197af8c10ab1f288b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gab22d2a32e6c32c14c4e58ce794ff3ec4">atcab_init_device</a> (<a class="el" href="a01508.html">ATCADevice</a> ca_device)</td></tr>
<tr class="memdesc:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the global ATCADevice object to point to one of your choosing for use with all the atcab_ basic API.  <br /></td></tr>
<tr class="separator:gab22d2a32e6c32c14c4e58ce794ff3ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga147803646532319e585a0fe7a6c028ef"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga147803646532319e585a0fe7a6c028ef">atcab_release_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> *device)</td></tr>
<tr class="memdesc:ga147803646532319e585a0fe7a6c028ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">release (free) the an ATCADevice instance.  <br /></td></tr>
<tr class="separator:ga147803646532319e585a0fe7a6c028ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga3a061c1f96bb641b36fc56b6cb2dd4e4">atcab_release</a> (void)</td></tr>
<tr class="memdesc:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">release (free) the global ATCADevice instance. This must be called in order to release or free up the interface.  <br /></td></tr>
<tr class="separator:ga3a061c1f96bb641b36fc56b6cb2dd4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01508.html">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga4af82005556c549c30e1c4bd35d4f4e4">atcab_get_device</a> (void)</td></tr>
<tr class="memdesc:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global device object.  <br /></td></tr>
<tr class="separator:ga4af82005556c549c30e1c4bd35d4f4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4882d4c30f1af2d1aab24a0c465f181d"><td class="memItemLeft" align="right" valign="top">ATCADeviceType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga4882d4c30f1af2d1aab24a0c465f181d">atcab_get_device_type_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device)</td></tr>
<tr class="memdesc:ga4882d4c30f1af2d1aab24a0c465f181d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the selected device type of rthe device context.  <br /></td></tr>
<tr class="separator:ga4882d4c30f1af2d1aab24a0c465f181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b02163fab87313b81dd7f51345d3eb6"><td class="memItemLeft" align="right" valign="top">ATCADeviceType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga2b02163fab87313b81dd7f51345d3eb6">atcab_get_device_type</a> (void)</td></tr>
<tr class="memdesc:ga2b02163fab87313b81dd7f51345d3eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current device type configured for the global ATCADevice.  <br /></td></tr>
<tr class="separator:ga2b02163fab87313b81dd7f51345d3eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga775bea13de8cc26e61a34ada48358568"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga775bea13de8cc26e61a34ada48358568">atcab_get_device_address</a> (<a class="el" href="a01508.html">ATCADevice</a> device)</td></tr>
<tr class="memdesc:ga775bea13de8cc26e61a34ada48358568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current device address based on the configured device and interface.  <br /></td></tr>
<tr class="separator:ga775bea13de8cc26e61a34ada48358568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e74da1e2ef3168e48bbc89c44b16d2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga6e74da1e2ef3168e48bbc89c44b16d2f">atcab_is_ca_device</a> (ATCADeviceType dev_type)</td></tr>
<tr class="memdesc:ga6e74da1e2ef3168e48bbc89c44b16d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the device is cryptoauth device.  <br /></td></tr>
<tr class="separator:ga6e74da1e2ef3168e48bbc89c44b16d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga973437347c3261df0b116fec9ee9c378"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga973437347c3261df0b116fec9ee9c378">atcab_is_ca2_device</a> (ATCADeviceType dev_type)</td></tr>
<tr class="memdesc:ga973437347c3261df0b116fec9ee9c378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the device is cryptoauth device.  <br /></td></tr>
<tr class="separator:ga973437347c3261df0b116fec9ee9c378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4e462d88600ee2d36c3c5bf699fde3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gadd4e462d88600ee2d36c3c5bf699fde3">atcab_is_ta_device</a> (ATCADeviceType dev_type)</td></tr>
<tr class="memdesc:gadd4e462d88600ee2d36c3c5bf699fde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the device is Trust Anchor device.  <br /></td></tr>
<tr class="separator:gadd4e462d88600ee2d36c3c5bf699fde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf944ef6828e73f64cd0c327aa5a5e0e"><td class="memItemLeft" align="right" valign="top">
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_pbkdf2_sha256_ext</b> (<a class="el" href="a01508.html">ATCADevice</a> device, const uint32_t iter, const uint16_t slot, const uint8_t *salt, const size_t salt_len, uint8_t *result, size_t result_len)</td></tr>
<tr class="separator:gacf944ef6828e73f64cd0c327aa5a5e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffacce78575dc87106d402d74178da95"><td class="memItemLeft" align="right" valign="top">
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_pbkdf2_sha256</b> (const uint32_t iter, const uint16_t slot, const uint8_t *salt, const size_t salt_len, uint8_t *result, size_t result_len)</td></tr>
<tr class="separator:gaffacce78575dc87106d402d74178da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3bc620aedd9322d160eece0d8d20c82"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gad3bc620aedd9322d160eece0d8d20c82">atcab_wakeup</a> (void)</td></tr>
<tr class="memdesc:gad3bc620aedd9322d160eece0d8d20c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">wakeup the CryptoAuth device  <br /></td></tr>
<tr class="separator:gad3bc620aedd9322d160eece0d8d20c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaf47433a371b9fcb8d65a4214cd9e4fa0">atcab_idle</a> (void)</td></tr>
<tr class="memdesc:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">idle the CryptoAuth device  <br /></td></tr>
<tr class="separator:gaf47433a371b9fcb8d65a4214cd9e4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9475e032c388144c5a0df45d1df182a5"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga9475e032c388144c5a0df45d1df182a5">atcab_sleep</a> (void)</td></tr>
<tr class="memdesc:ga9475e032c388144c5a0df45d1df182a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke sleep on the CryptoAuth device  <br /></td></tr>
<tr class="separator:ga9475e032c388144c5a0df45d1df182a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga7a823d2a391bf80ff336eb2ccbd37412">atcab_get_zone_size</a> (uint8_t zone, uint16_t slot, size_t *size)</td></tr>
<tr class="memdesc:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified zone in bytes.  <br /></td></tr>
<tr class="separator:ga7a823d2a391bf80ff336eb2ccbd37412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65cf773e03aed93e2a1437f13511a91"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gad65cf773e03aed93e2a1437f13511a91">atcab_get_zone_size_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint8_t zone, uint16_t slot, size_t *size)</td></tr>
<tr class="memdesc:gad65cf773e03aed93e2a1437f13511a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified zone in bytes.  <br /></td></tr>
<tr class="separator:gad65cf773e03aed93e2a1437f13511a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad115ce255664a48b80e90ea19c156b79"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gad115ce255664a48b80e90ea19c156b79">atcab_aes</a> (uint8_t mode, uint16_t key_id, const uint8_t *aes_in, uint8_t *aes_out)</td></tr>
<tr class="memdesc:gad115ce255664a48b80e90ea19c156b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the AES-128 encrypt, decrypt, or GFM calculation.  <br /></td></tr>
<tr class="separator:gad115ce255664a48b80e90ea19c156b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gacc9a58dc49f91674213f34fa7bbd05e1">atcab_aes_encrypt</a> (uint16_t key_id, uint8_t key_block, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 encrypt operation with a key in the device.  <br /></td></tr>
<tr class="separator:gacc9a58dc49f91674213f34fa7bbd05e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5c5cba4f9be5bc0e4b1c5691f60e4ba"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaa5c5cba4f9be5bc0e4b1c5691f60e4ba">atcab_aes_encrypt_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint16_t key_id, uint8_t key_block, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gaa5c5cba4f9be5bc0e4b1c5691f60e4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 encrypt operation with a key in the device.  <br /></td></tr>
<tr class="separator:gaa5c5cba4f9be5bc0e4b1c5691f60e4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9658e84055727e6357cf7ef636b4e398"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga9658e84055727e6357cf7ef636b4e398">atcab_aes_decrypt</a> (uint16_t key_id, uint8_t key_block, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:ga9658e84055727e6357cf7ef636b4e398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 decrypt operation with a key in the device.  <br /></td></tr>
<tr class="separator:ga9658e84055727e6357cf7ef636b4e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebaf49a3412181fa47ba3a761c5a2d5b"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaebaf49a3412181fa47ba3a761c5a2d5b">atcab_aes_decrypt_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint16_t key_id, uint8_t key_block, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:gaebaf49a3412181fa47ba3a761c5a2d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 decrypt operation with a key in the device.  <br /></td></tr>
<tr class="separator:gaebaf49a3412181fa47ba3a761c5a2d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5554940ed4c7c7e28652ce6923cf9314"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga5554940ed4c7c7e28652ce6923cf9314">atcab_aes_gfm</a> (const uint8_t *h, const uint8_t *input, uint8_t *output)</td></tr>
<tr class="memdesc:ga5554940ed4c7c7e28652ce6923cf9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a Galois Field Multiply (GFM) operation.  <br /></td></tr>
<tr class="separator:ga5554940ed4c7c7e28652ce6923cf9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4805112b62e86b5465e24648504dc374"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga4805112b62e86b5465e24648504dc374">atcab_aes_gcm_init</a> (atca_aes_gcm_ctx_t *ctx, uint16_t key_id, uint8_t key_block, const uint8_t *iv, size_t iv_size)</td></tr>
<tr class="memdesc:ga4805112b62e86b5465e24648504dc374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt operation.  <br /></td></tr>
<tr class="separator:ga4805112b62e86b5465e24648504dc374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8742a7be77a2350c069c5c380ac4c635"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga8742a7be77a2350c069c5c380ac4c635">atcab_aes_gcm_init_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, uint16_t key_id, uint8_t key_block, const uint8_t *iv, size_t iv_size)</td></tr>
<tr class="memdesc:ga8742a7be77a2350c069c5c380ac4c635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt operation.  <br /></td></tr>
<tr class="separator:ga8742a7be77a2350c069c5c380ac4c635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad71a5720ceaddf2c76476aead5f0c3e6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gad71a5720ceaddf2c76476aead5f0c3e6">atcab_aes_gcm_init_rand</a> (atca_aes_gcm_ctx_t *ctx, uint16_t key_id, uint8_t key_block, size_t rand_size, const uint8_t *free_field, size_t free_field_size, uint8_t *iv)</td></tr>
<tr class="memdesc:gad71a5720ceaddf2c76476aead5f0c3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) field, which is common when starting an encrypt operation.  <br /></td></tr>
<tr class="separator:gad71a5720ceaddf2c76476aead5f0c3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d6fd831a8125a366504a0ab77b62da8"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga1d6fd831a8125a366504a0ab77b62da8">atcab_aes_gcm_aad_update</a> (atca_aes_gcm_ctx_t *ctx, const uint8_t *aad, uint32_t aad_size)</td></tr>
<tr class="memdesc:ga1d6fd831a8125a366504a0ab77b62da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process Additional Authenticated Data (AAD) using GCM mode and a key within the ATECC608 device.  <br /></td></tr>
<tr class="separator:ga1d6fd831a8125a366504a0ab77b62da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c6666c7b4d077fb058adc4971da2160"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga1c6666c7b4d077fb058adc4971da2160">atcab_aes_gcm_aad_update_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, const uint8_t *aad, uint32_t aad_size)</td></tr>
<tr class="memdesc:ga1c6666c7b4d077fb058adc4971da2160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process Additional Authenticated Data (AAD) using GCM mode and a key within the ATECC608 device.  <br /></td></tr>
<tr class="separator:ga1c6666c7b4d077fb058adc4971da2160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3fda8219d17d1b7bc50b1040399a47d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gab3fda8219d17d1b7bc50b1040399a47d">atcab_aes_gcm_encrypt_update</a> (atca_aes_gcm_ctx_t *ctx, const uint8_t *plaintext, uint32_t plaintext_size, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gab3fda8219d17d1b7bc50b1040399a47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01439.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01439.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function.  <br /></td></tr>
<tr class="separator:gab3fda8219d17d1b7bc50b1040399a47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac8b8555b03b50a118b70cb8387c24ae"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaac8b8555b03b50a118b70cb8387c24ae">atcab_aes_gcm_encrypt_update_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, const uint8_t *plaintext, uint32_t plaintext_size, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gaac8b8555b03b50a118b70cb8387c24ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01439.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01439.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function.  <br /></td></tr>
<tr class="separator:gaac8b8555b03b50a118b70cb8387c24ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2d38835826587970de3868ca48eaa4"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gada2d38835826587970de3868ca48eaa4">atcab_aes_gcm_encrypt_finish</a> (atca_aes_gcm_ctx_t *ctx, uint8_t *tag, size_t tag_size)</td></tr>
<tr class="memdesc:gada2d38835826587970de3868ca48eaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a GCM encrypt operation returning the authentication tag.  <br /></td></tr>
<tr class="separator:gada2d38835826587970de3868ca48eaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga813fb67193a7c39d02ce7ad8d2d12123"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga813fb67193a7c39d02ce7ad8d2d12123">atcab_aes_gcm_encrypt_finish_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, uint8_t *tag, size_t tag_size)</td></tr>
<tr class="memdesc:ga813fb67193a7c39d02ce7ad8d2d12123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a GCM encrypt operation returning the authentication tag.  <br /></td></tr>
<tr class="separator:ga813fb67193a7c39d02ce7ad8d2d12123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad3270d8bebf6172dc02d0c7d9fb738"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga2ad3270d8bebf6172dc02d0c7d9fb738">atcab_aes_gcm_decrypt_update</a> (atca_aes_gcm_ctx_t *ctx, const uint8_t *ciphertext, uint32_t ciphertext_size, uint8_t *plaintext)</td></tr>
<tr class="memdesc:ga2ad3270d8bebf6172dc02d0c7d9fb738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01439.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01439.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function.  <br /></td></tr>
<tr class="separator:ga2ad3270d8bebf6172dc02d0c7d9fb738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac55fcbd824ffc9a30c6a5bbafb93aad2"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gac55fcbd824ffc9a30c6a5bbafb93aad2">atcab_aes_gcm_decrypt_update_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, const uint8_t *ciphertext, uint32_t ciphertext_size, uint8_t *plaintext)</td></tr>
<tr class="memdesc:gac55fcbd824ffc9a30c6a5bbafb93aad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt data using GCM mode and a key within the ATECC608 device. <a class="el" href="a01439.html#ga4805112b62e86b5465e24648504dc374" title="Initialize context for AES GCM operation with an existing IV, which is common when starting a decrypt...">atcab_aes_gcm_init()</a> or <a class="el" href="a01439.html#gad71a5720ceaddf2c76476aead5f0c3e6" title="Initialize context for AES GCM operation with a IV composed of a random and optional fixed(free) fiel...">atcab_aes_gcm_init_rand()</a> should be called before the first use of this function.  <br /></td></tr>
<tr class="separator:gac55fcbd824ffc9a30c6a5bbafb93aad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa86508958ff3d81f9bd8e79344537218"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaa86508958ff3d81f9bd8e79344537218">atcab_aes_gcm_decrypt_finish</a> (atca_aes_gcm_ctx_t *ctx, const uint8_t *tag, size_t tag_size, bool *is_verified)</td></tr>
<tr class="memdesc:gaa86508958ff3d81f9bd8e79344537218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a GCM decrypt operation verifying the authentication tag.  <br /></td></tr>
<tr class="separator:gaa86508958ff3d81f9bd8e79344537218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c5173c7529f898f251814133169ba1d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga9c5173c7529f898f251814133169ba1d">atcab_aes_gcm_decrypt_finish_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, atca_aes_gcm_ctx_t *ctx, const uint8_t *tag, size_t tag_size, bool *is_verified)</td></tr>
<tr class="memdesc:ga9c5173c7529f898f251814133169ba1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete a GCM decrypt operation verifying the authentication tag.  <br /></td></tr>
<tr class="separator:ga9c5173c7529f898f251814133169ba1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga5ba49c05f7b3fb5acaf55df993ccd3ee">atcab_checkmac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, const uint8_t *response, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a MAC response with input values.  <br /></td></tr>
<tr class="separator:ga5ba49c05f7b3fb5acaf55df993ccd3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad50eab1ee1abb18515e914a294668907"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gad50eab1ee1abb18515e914a294668907">atcab_checkmac_with_response_mac</a> (uint8_t mode, const uint8_t *challenge, const uint8_t *response, const uint8_t *other_data, uint8_t *mac)</td></tr>
<tr class="memdesc:gad50eab1ee1abb18515e914a294668907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a MAC response with input values.SHA105 device can generate optional mac Output response mac mode only supports in SHA105 device.  <br /></td></tr>
<tr class="separator:gad50eab1ee1abb18515e914a294668907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaaaef242649206029e1c10ac6d1fb7d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gabaaaef242649206029e1c10ac6d1fb7d">atcab_counter</a> (uint8_t mode, uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:gabaaaef242649206029e1c10ac6d1fb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Counter functions.  <br /></td></tr>
<tr class="separator:gabaaaef242649206029e1c10ac6d1fb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e510e056ea16a0a34b405b7ca378f16"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga6e510e056ea16a0a34b405b7ca378f16">atcab_counter_increment</a> (uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:ga6e510e056ea16a0a34b405b7ca378f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments one of the device's monotonic counters.  <br /></td></tr>
<tr class="separator:ga6e510e056ea16a0a34b405b7ca378f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee666028a097659af69cc828a6bd68b"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaeee666028a097659af69cc828a6bd68b">atcab_counter_read</a> (uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:gaeee666028a097659af69cc828a6bd68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one of the device's monotonic counters.  <br /></td></tr>
<tr class="separator:gaeee666028a097659af69cc828a6bd68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b7b6d46868f0d63d195216ef9939b1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga34b7b6d46868f0d63d195216ef9939b1">atcab_derivekey</a> (uint8_t mode, uint16_t key_id, const uint8_t *mac)</td></tr>
<tr class="memdesc:ga34b7b6d46868f0d63d195216ef9939b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key.  <br /></td></tr>
<tr class="separator:ga34b7b6d46868f0d63d195216ef9939b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5b5206bd54f7e7513a0c21a3ffbe31"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gabd5b5206bd54f7e7513a0c21a3ffbe31">atcab_derivekey_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint8_t mode, uint16_t key_id, const uint8_t *mac)</td></tr>
<tr class="memdesc:gabd5b5206bd54f7e7513a0c21a3ffbe31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key.  <br /></td></tr>
<tr class="separator:gabd5b5206bd54f7e7513a0c21a3ffbe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga211c9405bb5049dd4a5da92d25c83f3c">atcab_ecdh_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *public_key, uint8_t *pms, uint8_t *out_nonce)</td></tr>
<tr class="memdesc:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base function for generating premaster secret key using ECDH.  <br /></td></tr>
<tr class="separator:ga211c9405bb5049dd4a5da92d25c83f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc480ad2824df6309f4f370ffad15f9"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga6fc480ad2824df6309f4f370ffad15f9">atcab_ecdh</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms)</td></tr>
<tr class="memdesc:ga6fc480ad2824df6309f4f370ffad15f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is returned in the clear.  <br /></td></tr>
<tr class="separator:ga6fc480ad2824df6309f4f370ffad15f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51e3ae10f0596d473f646074650904e6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga51e3ae10f0596d473f646074650904e6">atcab_ecdh_enc</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms, const uint8_t *read_key, uint16_t read_key_id, const uint8_t num_in[(20)])</td></tr>
<tr class="memdesc:ga51e3ae10f0596d473f646074650904e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is read from the next slot.  <br /></td></tr>
<tr class="separator:ga51e3ae10f0596d473f646074650904e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975f7303086190d3b6f76c367583d622"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga975f7303086190d3b6f76c367583d622">atcab_ecdh_ioenc</a> (uint16_t key_id, const uint8_t *public_key, uint8_t *pms, const uint8_t *io_key)</td></tr>
<tr class="memdesc:ga975f7303086190d3b6f76c367583d622"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is returned encrypted using the IO protection key.  <br /></td></tr>
<tr class="separator:ga975f7303086190d3b6f76c367583d622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac244b83b061ffd8ae3d59b5f973baa53"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gac244b83b061ffd8ae3d59b5f973baa53">atcab_ecdh_tempkey</a> (const uint8_t *public_key, uint8_t *pms)</td></tr>
<tr class="memdesc:gac244b83b061ffd8ae3d59b5f973baa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in TempKey and the premaster secret is returned in the clear.  <br /></td></tr>
<tr class="separator:gac244b83b061ffd8ae3d59b5f973baa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaccb0c9d12154b0c5b917f89f233721"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gafaccb0c9d12154b0c5b917f89f233721">atcab_ecdh_tempkey_ioenc</a> (const uint8_t *public_key, uint8_t *pms, const uint8_t *io_key)</td></tr>
<tr class="memdesc:gafaccb0c9d12154b0c5b917f89f233721"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in TempKey and the premaster secret is returned encrypted using the IO protection key.  <br /></td></tr>
<tr class="separator:gafaccb0c9d12154b0c5b917f89f233721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga70751ea87f2cf913986bc7bca2cc661f">atcab_gendig</a> (uint8_t zone, uint16_t key_id, const uint8_t *other_data, uint8_t other_data_size)</td></tr>
<tr class="memdesc:ga70751ea87f2cf913986bc7bca2cc661f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to.  <br /></td></tr>
<tr class="separator:ga70751ea87f2cf913986bc7bca2cc661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f7953865c6091f266e727714e6f91dd"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga3f7953865c6091f266e727714e6f91dd">atcab_gendivkey</a> (const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga3f7953865c6091f266e727714e6f91dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a GenDivKey command to generate the equivalent diversified key as that programmed into the client side device.  <br /></td></tr>
<tr class="separator:ga3f7953865c6091f266e727714e6f91dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaa8b6953ad2c7f749e61566fd38fe6903">atcab_genkey_base</a> (uint8_t mode, uint16_t key_id, const uint8_t *other_data, uint8_t *public_key)</td></tr>
<tr class="memdesc:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which can generate a private key, compute a public key, nd/or compute a digest of a public key.  <br /></td></tr>
<tr class="separator:gaa8b6953ad2c7f749e61566fd38fe6903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga617bdbdce7b5736351d93214d44c5b8f">atcab_genkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga617bdbdce7b5736351d93214d44c5b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which generates a new random private key in slot/handle and returns the public key.  <br /></td></tr>
<tr class="separator:ga617bdbdce7b5736351d93214d44c5b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301d5e57486fefc1bd19da3cddc5bc0c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga301d5e57486fefc1bd19da3cddc5bc0c">atcab_genkey_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga301d5e57486fefc1bd19da3cddc5bc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which generates a new random private key in slot/handle and returns the public key.  <br /></td></tr>
<tr class="separator:ga301d5e57486fefc1bd19da3cddc5bc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2096a4618dd37c48ed48847fe63d844"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gad2096a4618dd37c48ed48847fe63d844">atcab_get_pubkey</a> (uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:gad2096a4618dd37c48ed48847fe63d844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses GenKey command to calculate the public key from an existing private key in a slot.  <br /></td></tr>
<tr class="separator:gad2096a4618dd37c48ed48847fe63d844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2cbb1989eff2c66935040f41a593bf6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gae2cbb1989eff2c66935040f41a593bf6">atcab_get_pubkey_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:gae2cbb1989eff2c66935040f41a593bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses GenKey command to calculate the public key from an existing private key in a slot.  <br /></td></tr>
<tr class="separator:gae2cbb1989eff2c66935040f41a593bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga45f1d09a51f7a1f68916536ab5125b9d">atcab_hmac</a> (uint8_t mode, uint16_t key_id, uint8_t *digest)</td></tr>
<tr class="memdesc:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a HMAC command, which computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device.  <br /></td></tr>
<tr class="separator:ga45f1d09a51f7a1f68916536ab5125b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga806d07982fda5c30755af6b5b4ef9314"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga806d07982fda5c30755af6b5b4ef9314">atcab_info_base</a> (uint8_t mode, uint16_t param2, uint8_t *out_data)</td></tr>
<tr class="memdesc:ga806d07982fda5c30755af6b5b4ef9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues an Info command, which return internal device information and can control GPIO and the persistent latch.  <br /></td></tr>
<tr class="separator:ga806d07982fda5c30755af6b5b4ef9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e19ecd60be4c74665d9ec142e460771"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga6e19ecd60be4c74665d9ec142e460771">atcab_info</a> (uint8_t *revision)</td></tr>
<tr class="memdesc:ga6e19ecd60be4c74665d9ec142e460771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the device revision (DevRev).  <br /></td></tr>
<tr class="separator:ga6e19ecd60be4c74665d9ec142e460771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd308bac927905d5c59f526b40c63d76"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gacd308bac927905d5c59f526b40c63d76">atcab_info_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint8_t *revision)</td></tr>
<tr class="memdesc:gacd308bac927905d5c59f526b40c63d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the device revision (DevRev).  <br /></td></tr>
<tr class="separator:gacd308bac927905d5c59f526b40c63d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d11f96c8d4b30c7cfb12a106fed7d35"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga0d11f96c8d4b30c7cfb12a106fed7d35">atcab_info_lock_status</a> (uint16_t param2, uint8_t *is_locked)</td></tr>
<tr class="memdesc:ga0d11f96c8d4b30c7cfb12a106fed7d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the lock status.  <br /></td></tr>
<tr class="separator:ga0d11f96c8d4b30c7cfb12a106fed7d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a2f89236943bcd0ed7f6616ccbb043"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaa7a2f89236943bcd0ed7f6616ccbb043">atcab_info_chip_status</a> (uint8_t *chip_status)</td></tr>
<tr class="memdesc:gaa7a2f89236943bcd0ed7f6616ccbb043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the chip status.  <br /></td></tr>
<tr class="separator:gaa7a2f89236943bcd0ed7f6616ccbb043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2649126606db8a0b64ae8e19d09f6600"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga2649126606db8a0b64ae8e19d09f6600">atcab_info_set_latch</a> (bool state)</td></tr>
<tr class="memdesc:ga2649126606db8a0b64ae8e19d09f6600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to set the persistent latch state for an ATECC608 device.  <br /></td></tr>
<tr class="separator:ga2649126606db8a0b64ae8e19d09f6600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga376b6ae92f14c60fba4ca5c6461e0b48">atcab_info_get_latch</a> (bool *state)</td></tr>
<tr class="memdesc:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the persistent latch current state for an ATECC608 device.  <br /></td></tr>
<tr class="separator:ga376b6ae92f14c60fba4ca5c6461e0b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a6c01492a76366f9402302b527c4e1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga40a6c01492a76366f9402302b527c4e1">atcab_kdf</a> (uint8_t mode, uint16_t key_id, const uint32_t details, const uint8_t *message, uint8_t *out_data, uint8_t *out_nonce)</td></tr>
<tr class="memdesc:ga40a6c01492a76366f9402302b527c4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the KDF command, which derives a new key in PRF, AES, or HKDF modes.  <br /></td></tr>
<tr class="separator:ga40a6c01492a76366f9402302b527c4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d2895192d93c524f5dba92a492cdfb"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga25d2895192d93c524f5dba92a492cdfb">atcab_lock</a> (uint8_t mode, uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga25d2895192d93c524f5dba92a492cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked.  <br /></td></tr>
<tr class="separator:ga25d2895192d93c524f5dba92a492cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga7cd67c03c7184ad041e2c0ad4f27db23">atcab_lock_config_zone</a> (void)</td></tr>
<tr class="memdesc:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the config zone.  <br /></td></tr>
<tr class="separator:ga7cd67c03c7184ad041e2c0ad4f27db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5059df8d40a5f9f0f5e2004039de424"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaf5059df8d40a5f9f0f5e2004039de424">atcab_lock_config_zone_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device)</td></tr>
<tr class="memdesc:gaf5059df8d40a5f9f0f5e2004039de424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the config zone.  <br /></td></tr>
<tr class="separator:gaf5059df8d40a5f9f0f5e2004039de424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0698e0c55ad700fe57498321e842cb38"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga0698e0c55ad700fe57498321e842cb38">atcab_lock_config_zone_crc</a> (uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga0698e0c55ad700fe57498321e842cb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the config zone with summary CRC.  <br /></td></tr>
<tr class="separator:ga0698e0c55ad700fe57498321e842cb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga8020aa89a5bed09ad35320b78e0fb890">atcab_lock_data_zone</a> (void)</td></tr>
<tr class="memdesc:ga8020aa89a5bed09ad35320b78e0fb890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the data zone (slots and OTP). for CryptoAuth devices and lock the setup for Trust Anchor device.  <br /></td></tr>
<tr class="separator:ga8020aa89a5bed09ad35320b78e0fb890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8105d79d3dd914cf643121ff243b00a3"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga8105d79d3dd914cf643121ff243b00a3">atcab_lock_data_zone_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device)</td></tr>
<tr class="memdesc:ga8105d79d3dd914cf643121ff243b00a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the data zone (slots and OTP). for CryptoAuth devices and lock the setup for Trust Anchor device.  <br /></td></tr>
<tr class="separator:ga8105d79d3dd914cf643121ff243b00a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaf29e398e2aca927ab4606aa1ec0308c6">atcab_lock_data_zone_crc</a> (uint16_t summary_crc)</td></tr>
<tr class="memdesc:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the data zone (slots and OTP) with summary CRC.  <br /></td></tr>
<tr class="separator:gaf29e398e2aca927ab4606aa1ec0308c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958190a9182d1b54f82fbca8216406ea"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga958190a9182d1b54f82fbca8216406ea">atcab_lock_data_slot</a> (uint16_t slot)</td></tr>
<tr class="memdesc:ga958190a9182d1b54f82fbca8216406ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1) (for cryptoauth devices) or Lock an individual handle in shared data element on an Trust Anchor device (for Trust Anchor devices).  <br /></td></tr>
<tr class="separator:ga958190a9182d1b54f82fbca8216406ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d91be168c4b3714cc0177632627bfc3"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga0d91be168c4b3714cc0177632627bfc3">atcab_lock_data_slot_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint16_t slot)</td></tr>
<tr class="memdesc:ga0d91be168c4b3714cc0177632627bfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1) (for cryptoauth devices) or Lock an individual handle in shared data element on an Trust Anchor device (for Trust Anchor devices).  <br /></td></tr>
<tr class="separator:ga0d91be168c4b3714cc0177632627bfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga98cb802fbb5d78cd552bb05c21d6c791">atcab_mac</a> (uint8_t mode, uint16_t key_id, const uint8_t *challenge, uint8_t *digest)</td></tr>
<tr class="memdesc:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes MAC command, which computes a SHA-256 digest of a key stored in the device, a challenge, and other information on the device.  <br /></td></tr>
<tr class="separator:ga98cb802fbb5d78cd552bb05c21d6c791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaf8e10791759a8a5e5dcd82774f4895d6">atcab_nonce_base</a> (uint8_t mode, uint16_t zero, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Nonce command, which loads a random or fixed nonce/data into the device for use by subsequent commands.  <br /></td></tr>
<tr class="separator:gaf8e10791759a8a5e5dcd82774f4895d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2293df1c1c794496790bae25d3844fa5"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga2293df1c1c794496790bae25d3844fa5">atcab_nonce</a> (const uint8_t *num_in)</td></tr>
<tr class="memdesc:ga2293df1c1c794496790bae25d3844fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to initialize TempKey to a specified value.  <br /></td></tr>
<tr class="separator:ga2293df1c1c794496790bae25d3844fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2239ae3a87c341a48aa108bd82a58552"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga2239ae3a87c341a48aa108bd82a58552">atcab_nonce_load</a> (uint8_t target, const uint8_t *num_in, uint16_t num_in_size)</td></tr>
<tr class="memdesc:ga2239ae3a87c341a48aa108bd82a58552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to load one of the device's internal buffers with a fixed value.  <br /></td></tr>
<tr class="separator:ga2239ae3a87c341a48aa108bd82a58552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaed67d447d547c67b7b8be6b958d1fb5c">atcab_nonce_rand</a> (const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number.  <br /></td></tr>
<tr class="separator:gaed67d447d547c67b7b8be6b958d1fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89942894a5a8f82391d74346603aa837"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga89942894a5a8f82391d74346603aa837">atcab_nonce_rand_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga89942894a5a8f82391d74346603aa837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number.  <br /></td></tr>
<tr class="separator:ga89942894a5a8f82391d74346603aa837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114a721517c95d5ba5fcac5b226669d6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga114a721517c95d5ba5fcac5b226669d6">atcab_challenge</a> (const uint8_t *num_in)</td></tr>
<tr class="memdesc:ga114a721517c95d5ba5fcac5b226669d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to initialize TempKey to a specified value.  <br /></td></tr>
<tr class="separator:ga114a721517c95d5ba5fcac5b226669d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadde4309089c569fd87c24a1a2326cd4"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaadde4309089c569fd87c24a1a2326cd4">atcab_challenge_seed_update</a> (const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:gaadde4309089c569fd87c24a1a2326cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random challenge combining a host nonce (num_in) and a device random number.  <br /></td></tr>
<tr class="separator:gaadde4309089c569fd87c24a1a2326cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead7151af044da249b398dc457fc8e06"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaead7151af044da249b398dc457fc8e06">atcab_priv_write</a> (uint16_t key_id, const uint8_t priv_key[36], uint16_t write_key_id, const uint8_t write_key[32], const uint8_t num_in[(20)])</td></tr>
<tr class="memdesc:gaead7151af044da249b398dc457fc8e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes PrivWrite command, to write externally generated ECC private keys into the device.  <br /></td></tr>
<tr class="separator:gaead7151af044da249b398dc457fc8e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fa442396dfbb89e59dfca837b565cec"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga4fa442396dfbb89e59dfca837b565cec">atcab_random</a> (uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga4fa442396dfbb89e59dfca837b565cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Random command, which generates a 32 byte random number from the device.  <br /></td></tr>
<tr class="separator:ga4fa442396dfbb89e59dfca837b565cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga103f4596f0f9590971763592c5233ec3"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga103f4596f0f9590971763592c5233ec3">atcab_random_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga103f4596f0f9590971763592c5233ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Random command, which generates a 32 byte random number from the device.  <br /></td></tr>
<tr class="separator:ga103f4596f0f9590971763592c5233ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga3ce01f02f456c08891ca1d67cd3ed0eb">atcab_read_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads either 4 or 32 bytes of data from a given slot, configuration zone, or the OTP zone.  <br /></td></tr>
<tr class="separator:ga3ce01f02f456c08891ca1d67cd3ed0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245f181cbf1ba418e60d060503945c33"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga245f181cbf1ba418e60d060503945c33">atcab_read_zone_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga245f181cbf1ba418e60d060503945c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads either 4 or 32 bytes of data from a given slot, configuration zone, or the OTP zone.  <br /></td></tr>
<tr class="separator:ga245f181cbf1ba418e60d060503945c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefce484222bdbedef37787a9b10d4426"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaefce484222bdbedef37787a9b10d4426">atcab_is_locked</a> (uint8_t zone, bool *is_locked)</td></tr>
<tr class="memdesc:gaefce484222bdbedef37787a9b10d4426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the configuration zone to see if the specified zone is locked.  <br /></td></tr>
<tr class="separator:gaefce484222bdbedef37787a9b10d4426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d0626815c3df9dd2b43d72eecd3a36"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga25d0626815c3df9dd2b43d72eecd3a36">atcab_is_config_locked</a> (bool *is_locked)</td></tr>
<tr class="memdesc:ga25d0626815c3df9dd2b43d72eecd3a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether configuration zone is locked or not.  <br /></td></tr>
<tr class="separator:ga25d0626815c3df9dd2b43d72eecd3a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadac89d52a30b7a11768cf4c5de8d4d08"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gadac89d52a30b7a11768cf4c5de8d4d08">atcab_is_config_locked_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, bool *is_locked)</td></tr>
<tr class="memdesc:gadac89d52a30b7a11768cf4c5de8d4d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether configuration zone is locked or not.  <br /></td></tr>
<tr class="separator:gadac89d52a30b7a11768cf4c5de8d4d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44aae7e0a28993eb6abf78bb3d42e26d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga44aae7e0a28993eb6abf78bb3d42e26d">atcab_is_data_locked</a> (bool *is_locked)</td></tr>
<tr class="memdesc:ga44aae7e0a28993eb6abf78bb3d42e26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether data/setup zone is locked or not.  <br /></td></tr>
<tr class="separator:ga44aae7e0a28993eb6abf78bb3d42e26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3189411975d835c0115511556302d8"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga7e3189411975d835c0115511556302d8">atcab_is_data_locked_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, bool *is_locked)</td></tr>
<tr class="memdesc:ga7e3189411975d835c0115511556302d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether data/setup zone is locked or not.  <br /></td></tr>
<tr class="separator:ga7e3189411975d835c0115511556302d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802de50265ff91dc30dd7c93d9e026e1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga802de50265ff91dc30dd7c93d9e026e1">atcab_is_slot_locked</a> (uint16_t slot, bool *is_locked)</td></tr>
<tr class="memdesc:ga802de50265ff91dc30dd7c93d9e026e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether slot/handle is locked or not.  <br /></td></tr>
<tr class="separator:ga802de50265ff91dc30dd7c93d9e026e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df72bf98b5f19668dc402c35fd4ef17"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga4df72bf98b5f19668dc402c35fd4ef17">atcab_is_slot_locked_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint16_t slot, bool *is_locked)</td></tr>
<tr class="memdesc:ga4df72bf98b5f19668dc402c35fd4ef17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check whether slot/handle is locked or not.  <br /></td></tr>
<tr class="separator:ga4df72bf98b5f19668dc402c35fd4ef17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5f4cc263fd729871446e01cb063f141"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gac5f4cc263fd729871446e01cb063f141">atcab_is_private_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint16_t slot, bool *is_private)</td></tr>
<tr class="memdesc:gac5f4cc263fd729871446e01cb063f141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the key is a private key or not.  <br /></td></tr>
<tr class="separator:gac5f4cc263fd729871446e01cb063f141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d916826086a53649672f8abc009f3d"><td class="memItemLeft" align="right" valign="top">
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_is_private</b> (uint16_t slot, bool *is_private)</td></tr>
<tr class="separator:gac0d916826086a53649672f8abc009f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649af88b2dc1d2c235c6e5a1842340fa"><td class="memItemLeft" align="right" valign="top">
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_read_bytes_zone_ext</b> (<a class="el" href="a01508.html">ATCADevice</a> device, uint8_t zone, uint16_t slot, size_t offset, uint8_t *data, size_t length)</td></tr>
<tr class="separator:ga649af88b2dc1d2c235c6e5a1842340fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga750704332198726725a327344f4f7dd5"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga750704332198726725a327344f4f7dd5">atcab_read_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset, uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:ga750704332198726725a327344f4f7dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to read an arbitrary number of bytes from any zone configured for clear reads.  <br /></td></tr>
<tr class="separator:ga750704332198726725a327344f4f7dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga96c434878e1f435e2cda5b0b5fec444f">atcab_read_serial_number</a> (uint8_t *serial_number)</td></tr>
<tr class="memdesc:ga96c434878e1f435e2cda5b0b5fec444f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns serial number of the device.  <br /></td></tr>
<tr class="separator:ga96c434878e1f435e2cda5b0b5fec444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a741e461c20d2a72493bc6178826eb1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga8a741e461c20d2a72493bc6178826eb1">atcab_read_serial_number_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint8_t *serial_number)</td></tr>
<tr class="memdesc:ga8a741e461c20d2a72493bc6178826eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns serial number of the device.  <br /></td></tr>
<tr class="separator:ga8a741e461c20d2a72493bc6178826eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga782ca1e5b1574b2b6793c841be22b28b"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga782ca1e5b1574b2b6793c841be22b28b">atcab_read_pubkey</a> (uint16_t slot, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga782ca1e5b1574b2b6793c841be22b28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read an ECC P256 public key from a slot configured for clear reads.  <br /></td></tr>
<tr class="separator:ga782ca1e5b1574b2b6793c841be22b28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea51a5aafd900c9bdffeffe82274255"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga2ea51a5aafd900c9bdffeffe82274255">atcab_read_pubkey_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint16_t slot, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga2ea51a5aafd900c9bdffeffe82274255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read an ECC P256 public key from a slot configured for clear reads.  <br /></td></tr>
<tr class="separator:ga2ea51a5aafd900c9bdffeffe82274255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga098c4c2c724b90b7e2f4ecf12b9530b7">atcab_read_sig</a> (uint16_t slot, uint8_t *sig)</td></tr>
<tr class="memdesc:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read a 64 byte ECDSA P256 signature from a slot configured for clear reads.  <br /></td></tr>
<tr class="separator:ga098c4c2c724b90b7e2f4ecf12b9530b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga8ef47330eef6bc72ae8f7a8ef026dae3">atcab_read_config_zone</a> (uint8_t *config_data)</td></tr>
<tr class="memdesc:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read the complete device configuration zone.  <br /></td></tr>
<tr class="separator:ga8ef47330eef6bc72ae8f7a8ef026dae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee98f13a88710e5234266b4b456b1dc"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga9ee98f13a88710e5234266b4b456b1dc">atcab_read_config_zone_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint8_t *config_data)</td></tr>
<tr class="memdesc:ga9ee98f13a88710e5234266b4b456b1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read the complete device configuration zone.  <br /></td></tr>
<tr class="separator:ga9ee98f13a88710e5234266b4b456b1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gadb91d2c3601b95f0ad413cf84a4dfd87">atcab_cmp_config_zone</a> (uint8_t *config_data, bool *same_config)</td></tr>
<tr class="memdesc:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a specified configuration zone with the configuration zone currently on the device.  <br /></td></tr>
<tr class="separator:gadb91d2c3601b95f0ad413cf84a4dfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf0048247bb577c85142510225ea960"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga0cf0048247bb577c85142510225ea960">atcab_read_enc</a> (uint16_t key_id, uint8_t block, uint8_t *data, const uint8_t *enc_key, const uint16_t enc_key_id, const uint8_t num_in[(20)])</td></tr>
<tr class="memdesc:ga0cf0048247bb577c85142510225ea960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command on a slot configured for encrypted reads and decrypts the data to return it as plaintext.  <br /></td></tr>
<tr class="separator:ga0cf0048247bb577c85142510225ea960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9506331ea7d454fe3c9b2585128c77aa"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga9506331ea7d454fe3c9b2585128c77aa">atcab_secureboot</a> (uint8_t mode, uint16_t param2, const uint8_t *digest, const uint8_t *signature, uint8_t *mac)</td></tr>
<tr class="memdesc:ga9506331ea7d454fe3c9b2585128c77aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Secure Boot command, which provides support for secure boot of an external MCU or MPU.  <br /></td></tr>
<tr class="separator:ga9506331ea7d454fe3c9b2585128c77aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga5c11f2012a03ec79cb46de8e03ed0534">atcab_secureboot_mac</a> (uint8_t mode, const uint8_t *digest, const uint8_t *signature, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Secure Boot command with encrypted digest and validated MAC response using the IO protection key.  <br /></td></tr>
<tr class="separator:ga5c11f2012a03ec79cb46de8e03ed0534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaeb4a36bc6992612cc3b1f950c0d020b7">atcab_selftest</a> (uint8_t mode, uint16_t param2, uint8_t *result)</td></tr>
<tr class="memdesc:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the SelfTest command, which performs a test of one or more of the cryptographic engines within the ATECC608 chip.  <br /></td></tr>
<tr class="separator:gaeb4a36bc6992612cc3b1f950c0d020b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gab3a32e171ca1c30bd31a216b32c9b5a4">atcab_sha_base</a> (uint8_t mode, uint16_t length, const uint8_t *data_in, uint8_t *data_out, uint16_t *data_out_size)</td></tr>
<tr class="memdesc:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command, which computes a SHA-256 or HMAC/SHA-256 digest for general purpose use by the host system.  <br /></td></tr>
<tr class="separator:gab3a32e171ca1c30bd31a216b32c9b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gae0a7ef89fce4cbd0ee1c76759cd93b9a">atcab_sha_start</a> (void)</td></tr>
<tr class="memdesc:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to initialize SHA-256 calculation engine.  <br /></td></tr>
<tr class="separator:gae0a7ef89fce4cbd0ee1c76759cd93b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga39bd70baa7a4c7f4849fcf8b94d4d949">atcab_sha_update</a> (const uint8_t *message)</td></tr>
<tr class="memdesc:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to add 64 bytes of message data to the current context.  <br /></td></tr>
<tr class="separator:ga39bd70baa7a4c7f4849fcf8b94d4d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db86704035048066a370815b657234d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga1db86704035048066a370815b657234d">atcab_sha_end</a> (uint8_t *digest, uint16_t length, const uint8_t *message)</td></tr>
<tr class="memdesc:ga1db86704035048066a370815b657234d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to complete SHA-256 or HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:ga1db86704035048066a370815b657234d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d1db50562642ce511fa7cbd384c2ab"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga74d1db50562642ce511fa7cbd384c2ab">atcab_sha_read_context</a> (uint8_t *context, uint16_t *context_size)</td></tr>
<tr class="memdesc:ga74d1db50562642ce511fa7cbd384c2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to read the SHA-256 context back. Only for ATECC608 with SHA-256 contexts. HMAC not supported.  <br /></td></tr>
<tr class="separator:ga74d1db50562642ce511fa7cbd384c2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga070fa80ac0d76f6816d9f7affbcfb120">atcab_sha_write_context</a> (const uint8_t *context, uint16_t context_size)</td></tr>
<tr class="memdesc:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to write (restore) a SHA-256 context into the the device. Only supported for ATECC608 with SHA-256 contexts.  <br /></td></tr>
<tr class="separator:ga070fa80ac0d76f6816d9f7affbcfb120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d269ccdafd08519a899a8aebf53df1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga31d269ccdafd08519a899a8aebf53df1">atcab_sha</a> (uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga31d269ccdafd08519a899a8aebf53df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute a SHA-256 digest.  <br /></td></tr>
<tr class="separator:ga31d269ccdafd08519a899a8aebf53df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf8b665fe1712626a480742c2daa16b"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga4bf8b665fe1712626a480742c2daa16b">atcab_hw_sha2_256</a> (const uint8_t *data, size_t data_size, uint8_t *digest)</td></tr>
<tr class="memdesc:ga4bf8b665fe1712626a480742c2daa16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute a SHA-256 digest.  <br /></td></tr>
<tr class="separator:ga4bf8b665fe1712626a480742c2daa16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade49e7746864105730fa7d531645ff62"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gade49e7746864105730fa7d531645ff62">atcab_hw_sha2_256_init</a> (<a class="el" href="a01616.html">atca_sha256_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:gade49e7746864105730fa7d531645ff62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a SHA context for performing a hardware SHA-256 operation on a device. Note that only one SHA operation can be run at a time.  <br /></td></tr>
<tr class="separator:gade49e7746864105730fa7d531645ff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga67f2ce6224651d9cc65e9915e35558bd">atcab_hw_sha2_256_update</a> (<a class="el" href="a01616.html">atca_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:ga67f2ce6224651d9cc65e9915e35558bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add message data to a SHA context for performing a hardware SHA-256 operation on a device.  <br /></td></tr>
<tr class="separator:ga67f2ce6224651d9cc65e9915e35558bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga6ed7e645262fcc32b00d8a9facf09e91">atcab_hw_sha2_256_finish</a> (<a class="el" href="a01616.html">atca_sha256_ctx_t</a> *ctx, uint8_t *digest)</td></tr>
<tr class="memdesc:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish SHA-256 digest for a SHA context for performing a hardware SHA-256 operation on a device.  <br /></td></tr>
<tr class="separator:ga6ed7e645262fcc32b00d8a9facf09e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga310a017cddce9ef05071cb619b4b6db9"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga310a017cddce9ef05071cb619b4b6db9">atcab_sha_hmac_init</a> (<a class="el" href="a01616.html">atca_hmac_sha256_ctx_t</a> *ctx, uint16_t key_slot)</td></tr>
<tr class="memdesc:ga310a017cddce9ef05071cb619b4b6db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to start an HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:ga310a017cddce9ef05071cb619b4b6db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3343c160e80365b7e96bdfdc9b6365c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gae3343c160e80365b7e96bdfdc9b6365c">atcab_sha_hmac_update</a> (<a class="el" href="a01616.html">atca_hmac_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:gae3343c160e80365b7e96bdfdc9b6365c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to add an arbitrary amount of message data to a HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:gae3343c160e80365b7e96bdfdc9b6365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4be9972396b7cadb08dd8e2199daf08"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaa4be9972396b7cadb08dd8e2199daf08">atcab_sha_hmac_finish</a> (<a class="el" href="a01616.html">atca_hmac_sha256_ctx_t</a> *ctx, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gaa4be9972396b7cadb08dd8e2199daf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to complete a HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:gaa4be9972396b7cadb08dd8e2199daf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae655ce06583c08169170102fbb0b55c9"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gae655ce06583c08169170102fbb0b55c9">atcab_sha_hmac</a> (const uint8_t *data, size_t data_size, uint16_t key_slot, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gae655ce06583c08169170102fbb0b55c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute an HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:gae655ce06583c08169170102fbb0b55c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede6ae09e6192e452ad261f4e15e1c62"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaede6ae09e6192e452ad261f4e15e1c62">atcab_sha_hmac_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, const uint8_t *data, size_t data_size, uint16_t key_slot, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gaede6ae09e6192e452ad261f4e15e1c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute an HMAC/SHA-256 operation.  <br /></td></tr>
<tr class="separator:gaede6ae09e6192e452ad261f4e15e1c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga5c1e598bf3d4d25b522f42d6038a4268">atcab_sign_base</a> (uint8_t mode, uint16_t key_id, uint8_t *signature)</td></tr>
<tr class="memdesc:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Sign command, which generates a signature using the ECDSA algorithm.  <br /></td></tr>
<tr class="separator:ga5c1e598bf3d4d25b522f42d6038a4268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga69b8282d1b1e0c54b9a7d286fed503b8">atcab_sign</a> (uint16_t key_id, const uint8_t *msg, uint8_t *signature)</td></tr>
<tr class="memdesc:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:ga69b8282d1b1e0c54b9a7d286fed503b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b76ca12e6f7236d9ef3235b174f48cc"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga4b76ca12e6f7236d9ef3235b174f48cc">atcab_sign_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint16_t key_id, const uint8_t *msg, uint8_t *signature)</td></tr>
<tr class="memdesc:ga4b76ca12e6f7236d9ef3235b174f48cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:ga4b76ca12e6f7236d9ef3235b174f48cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga559add3e8b4f85a9d91fc0ed86aefa29">atcab_sign_internal</a> (uint16_t key_id, bool is_invalidate, bool is_full_sn, uint8_t *signature)</td></tr>
<tr class="memdesc:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command to sign an internally generated message.  <br /></td></tr>
<tr class="separator:ga559add3e8b4f85a9d91fc0ed86aefa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga416e4aeacf3acc35b1d5b76028c6947d">atcab_updateextra</a> (uint8_t mode, uint16_t new_value)</td></tr>
<tr class="memdesc:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes UpdateExtra command to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85).  <br /></td></tr>
<tr class="separator:ga416e4aeacf3acc35b1d5b76028c6947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694d921c7bc17a0e158ef96e3d476700"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga694d921c7bc17a0e158ef96e3d476700">atcab_verify</a> (uint8_t mode, uint16_t key_id, const uint8_t *signature, const uint8_t *public_key, const uint8_t *other_data, uint8_t *mac)</td></tr>
<tr class="memdesc:ga694d921c7bc17a0e158ef96e3d476700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command.  <br /></td></tr>
<tr class="separator:ga694d921c7bc17a0e158ef96e3d476700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3e18de900ba705192963d08b37f600"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga2c3e18de900ba705192963d08b37f600">atcab_verify_extern</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga2c3e18de900ba705192963d08b37f600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:ga2c3e18de900ba705192963d08b37f600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4e2ffada9173db1a775a697bbebf18"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga3a4e2ffada9173db1a775a697bbebf18">atcab_verify_extern_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga3a4e2ffada9173db1a775a697bbebf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:ga3a4e2ffada9173db1a775a697bbebf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga17bf17c4786be097a0bb111a6f9d8ca6">atcab_verify_extern_mac</a> (const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. This function is only available on the ATECC608.  <br /></td></tr>
<tr class="separator:ga17bf17c4786be097a0bb111a6f9d8ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8cc7670847805423ad591985eecd832"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gae8cc7670847805423ad591985eecd832">atcab_verify_stored</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:gae8cc7670847805423ad591985eecd832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:gae8cc7670847805423ad591985eecd832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08f6cceac6e8147aeb6f665dc0a2aff"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gad08f6cceac6e8147aeb6f665dc0a2aff">atcab_verify_stored_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, const uint8_t *message, const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:gad08f6cceac6e8147aeb6f665dc0a2aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608 device or TempKey for other devices.  <br /></td></tr>
<tr class="separator:gad08f6cceac6e8147aeb6f665dc0a2aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582dc8686f0491ad4292287f6971543c"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga582dc8686f0491ad4292287f6971543c">atcab_verify_stored_with_tempkey</a> (const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:ga582dc8686f0491ad4292287f6971543c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. keyConfig.reqrandom bit should be set and the message to be signed should be already loaded into TempKey for all devices.  <br /></td></tr>
<tr class="separator:ga582dc8686f0491ad4292287f6971543c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaa52cdbbfd2f089d8eb42ef2640204ca7">atcab_verify_stored_mac</a> (const uint8_t *message, const uint8_t *signature, uint16_t key_id, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with a public key stored in the device. This function is only available on the ATECC608.  <br /></td></tr>
<tr class="separator:gaa52cdbbfd2f089d8eb42ef2640204ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gacf9a0c7772ebb65b87c4a4788850702b">atcab_verify_validate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:gacf9a0c7772ebb65b87c4a4788850702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command in Validate mode to validate a public key stored in a slot.  <br /></td></tr>
<tr class="separator:gacf9a0c7772ebb65b87c4a4788850702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga9393b545b2fa1fdd539672a0428a30ab">atcab_verify_invalidate</a> (uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:ga9393b545b2fa1fdd539672a0428a30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command in Invalidate mode which invalidates a previously validated public key stored in a slot.  <br /></td></tr>
<tr class="separator:ga9393b545b2fa1fdd539672a0428a30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gabf2b29b4d3ae926b63c403d084380dbe">atcab_write</a> (uint8_t zone, uint16_t <a class="el" href="a00257.html#af3f726014b044194def151079f1f2d89">address</a>, const uint8_t *value, const uint8_t *mac)</td></tr>
<tr class="memdesc:gabf2b29b4d3ae926b63c403d084380dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either one four byte word or a 32-byte block to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys.  <br /></td></tr>
<tr class="separator:gabf2b29b4d3ae926b63c403d084380dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga1f5a6bbcf4f840803635fb8951b3a7e2">atcab_write_zone</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either 4 or 32 bytes of data into a device zone.  <br /></td></tr>
<tr class="separator:ga1f5a6bbcf4f840803635fb8951b3a7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03eaf30d3d776260ad57ff05c2d6aa1"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gad03eaf30d3d776260ad57ff05c2d6aa1">atcab_write_zone_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:gad03eaf30d3d776260ad57ff05c2d6aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either 4 or 32 bytes of data into a device zone.  <br /></td></tr>
<tr class="separator:gad03eaf30d3d776260ad57ff05c2d6aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1442f24118397b11eb46a0cbe1601016"><td class="memItemLeft" align="right" valign="top">
ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>atcab_write_bytes_zone_ext</b> (<a class="el" href="a01508.html">ATCADevice</a> device, uint8_t zone, uint16_t slot, size_t offset_bytes, const uint8_t *data, size_t length)</td></tr>
<tr class="separator:ga1442f24118397b11eb46a0cbe1601016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac395a7e195aa3cf28b48de345755feb0"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gac395a7e195aa3cf28b48de345755feb0">atcab_write_bytes_zone</a> (uint8_t zone, uint16_t slot, size_t offset_bytes, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gac395a7e195aa3cf28b48de345755feb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes data into the configuration, otp, or data zones with a given byte offset and length. Offset and length must be multiples of a word (4 bytes).  <br /></td></tr>
<tr class="separator:gac395a7e195aa3cf28b48de345755feb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga47cbedeb3c3e9f7cbf2b9433cd60d1aa">atcab_write_pubkey</a> (uint16_t slot, const uint8_t *public_key)</td></tr>
<tr class="memdesc:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the write command to write a public key to a slot in the proper format.  <br /></td></tr>
<tr class="separator:ga47cbedeb3c3e9f7cbf2b9433cd60d1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80d6c193374d363649236778289f2ea"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gaa80d6c193374d363649236778289f2ea">atcab_write_pubkey_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, uint16_t slot, const uint8_t *public_key)</td></tr>
<tr class="memdesc:gaa80d6c193374d363649236778289f2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the write command to write a public key to a slot in the proper format.  <br /></td></tr>
<tr class="separator:gaa80d6c193374d363649236778289f2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0777a86aa412a97b19cc72a12c171b94"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga0777a86aa412a97b19cc72a12c171b94">atcab_write_config_zone</a> (const uint8_t *config_data)</td></tr>
<tr class="memdesc:ga0777a86aa412a97b19cc72a12c171b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes the configuration zone.  <br /></td></tr>
<tr class="separator:ga0777a86aa412a97b19cc72a12c171b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d651c637007f8c3672c3313767c0e7"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga92d651c637007f8c3672c3313767c0e7">atcab_write_config_zone_ext</a> (<a class="el" href="a01508.html">ATCADevice</a> device, const uint8_t *config_data)</td></tr>
<tr class="memdesc:ga92d651c637007f8c3672c3313767c0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes the configuration zone.  <br /></td></tr>
<tr class="separator:ga92d651c637007f8c3672c3313767c0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a5394997ea31b125cd57d07aa73636"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#ga78a5394997ea31b125cd57d07aa73636">atcab_write_enc</a> (uint16_t key_id, uint8_t block, const uint8_t *data, const uint8_t *enc_key, const uint16_t enc_key_id, const uint8_t num_in[(20)])</td></tr>
<tr class="memdesc:ga78a5394997ea31b125cd57d07aa73636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which performs an encrypted write of a 32 byte block into given slot.  <br /></td></tr>
<tr class="separator:ga78a5394997ea31b125cd57d07aa73636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25ca44957dff1c2df34607738ca3bf7"><td class="memItemLeft" align="right" valign="top">ATCA_STATUS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01439.html#gab25ca44957dff1c2df34607738ca3bf7">atcab_write_config_counter</a> (uint16_t counter_id, uint32_t counter_value)</td></tr>
<tr class="memdesc:gab25ca44957dff1c2df34607738ca3bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize one of the monotonic counters in device with a specific value.  <br /></td></tr>
<tr class="separator:gab25ca44957dff1c2df34607738ca3bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga04ab61dc670ca87600f9f71380b9b198"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="a01508.html">ATCADevice</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_atcab_device_ptr</b></td></tr>
<tr class="separator:ga04ab61dc670ca87600f9f71380b9b198"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CryptoAuthLib Basic API methods - a simple crypto authentication API. These methods manage a global ATCADevice object behind the scenes. They also manage the wake/idle state transitions so callers don't need to. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2015-2020 Microchip Technology Inc. and its subsidiaries. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="a00224.html">atca_basic.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>

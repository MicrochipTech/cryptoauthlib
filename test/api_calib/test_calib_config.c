/**
 * \file
 * \brief Cryptoauthlib API (cablib) Test Configuration
 *
 * \copyright (c) 2015-2020 Microchip Technology Inc. and its subsidiaries.
 *
 * \page License
 *
 * Subject to your compliance with these terms, you may use Microchip software
 * and any derivatives exclusively with Microchip products. It is your
 * responsibility to comply with third party license terms applicable to your
 * use of third party software (including open source software) that may
 * accompany Microchip software.
 *
 * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
 * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
 * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
 * PARTICULAR PURPOSE. IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT,
 * SPECIAL, PUNITIVE, INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE
 * OF ANY KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF
 * MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE
 * FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL
 * LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED
 * THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR
 * THIS SOFTWARE.
 */

#include "atca_test.h"

const uint8_t g_slot4_key[] = {
    0x37, 0x80, 0xe6, 0x3d, 0x49, 0x68, 0xad, 0xe5,
    0xd8, 0x22, 0xc0, 0x13, 0xfc, 0xc3, 0x23, 0x84,
    0x5d, 0x1b, 0x56, 0x9f, 0xe7, 0x05, 0xb6, 0x00,
    0x06, 0xfe, 0xec, 0x14, 0x5a, 0x0d, 0xb1, 0xe3
};

#if ATCA_CA_SUPPORT

#include "test_calib.h"

#ifdef ATCA_ATECC608_SUPPORT
uint8_t test_ecc608_configdata[ATCA_ECC_CONFIG_SIZE] = {
    0x01, 0x23, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x04, 0x05, 0x06, 0x07, 0xEE, 0x01, 0x01, 0x00,  //15
    0xC0, 0x00, 0xA1, 0x00, 0xAF, 0x2F, 0xC4, 0x44, 0x87, 0x20, 0xC4, 0xF4, 0x8F, 0x0F, 0x0F, 0x0F,  //31,
    0x9F, 0x8F, 0x83, 0x64, 0xC4, 0x44, 0xC4, 0x64, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,  //47
    0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,  //63
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x84, 0x03, 0xBC, 0x09, 0x69, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00,  //79
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x0E, 0x40, 0x00, 0x00, 0x00, 0x00,  //95
    0x33, 0x00, 0x1C, 0x00, 0x13, 0x00, 0x1C, 0x00, 0x3C, 0x00, 0x3A, 0x10, 0x1C, 0x00, 0x33, 0x00,  //111
    0x1C, 0x00, 0x1C, 0x00, 0x38, 0x00, 0x30, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x32, 0x00, 0x30, 0x00   //127
};
#endif

#if defined(ATCA_ATECC108A_SUPPORT) || defined(ATCA_ATECC508A_SUPPORT)
const uint8_t test_ecc_configdata[ATCA_ECC_CONFIG_SIZE] = {
    0x01, 0x23, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x04, 0x05, 0x06, 0x07, 0xEE, 0x00, 0x01, 0x00, //15
    0xC0, 0x00, 0x55, 0x00, 0x8F, 0x2F, 0xC4, 0x44, 0x87, 0x20, 0xC4, 0xF4, 0x8F, 0x0F, 0x8F, 0x8F, //31,
    0x9F, 0x8F, 0x83, 0x64, 0xC4, 0x44, 0xC4, 0x64, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, //47
    0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, //63
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, //79
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //95
    0x33, 0x00, 0x1C, 0x00, 0x13, 0x00, 0x1C, 0x00, 0x3C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x33, 0x00, //111
    0x1C, 0x00, 0x1C, 0x00, 0x3C, 0x00, 0x30, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x32, 0x00, 0x30, 0x00  //127
};
#endif


static device_object_meta_t calib_config_object_data[] =
{
    { TEST_TYPE_ECC_SIGN,   2,                    NULL                  },
    { TEST_TYPE_ECC_VERIFY, 15,                   NULL                  },
    { TEST_TYPE_ECC_GENKEY, 2,                    NULL                  },
    { TEST_TYPE_ECDH,       0,                    NULL                  },
    { TEST_TYPE_AES,        10,                   NULL                  },
    { TEST_TYPE_HMAC,       4,                    NULL                  },
    { TEST_TYPE_DATA,       11,                   NULL                  },
    { 0,                    0,                    NULL                  }
};



static ATCA_STATUS calib_config_get_slot_internal(device_object_meta_t * table, uint8_t test_type, uint16_t* handle)
{
    ATCA_STATUS status = ATCA_UNIMPLEMENTED;

    for (; table->test_type; table++)
    {
        if (table->test_type == test_type)
        {
            *handle = table->handle;
            status = ATCA_SUCCESS;
            break;
        }
    }
    return status;
}

ATCA_STATUS calib_config_get_slot_by_test(uint8_t test_type, uint16_t* handle)
{
    return calib_config_get_slot_internal(calib_config_object_data, test_type, handle);
}
#endif

#if defined(ATCA_ECC204_SUPPORT) || defined(ATCA_TA010_SUPPORT)

const uint8_t test_ecc204_configdata[ATCA_CA2_CONFIG_SIZE] = {
    0xB9, 0xFA, 0x3C, 0x1A, 0xAA, 0xD4, 0x91, 0x7C, 0x03, 0x3C, 0x00, 0x00, 0x3E, 0xAF, 0x81, 0x80,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static device_object_meta_t calib_config_ecc204_object_data[] =
{
    { TEST_TYPE_ECC_SIGN,   0,                    NULL                  },
    { TEST_TYPE_ECC_GENKEY, 0,                    NULL                  },
    { TEST_TYPE_DATA,       1,                    NULL                  },
    { TEST_TYPE_HMAC,       3,                    NULL                  },
    { 0,                    0,                    NULL                  }
};

ATCA_STATUS calib_config_get_ecc204_slot_by_test(uint8_t test_type, uint16_t* handle)
{
    return calib_config_get_slot_internal(calib_config_ecc204_object_data, test_type, handle);
}
#endif

#ifdef ATCA_SHA104_SUPPORT
const uint8_t test_sha104_configdata[ATCA_CA2_CONFIG_SIZE] = {
    0x01, 0x23, 0x47, 0x29, 0xCA, 0x9A, 0x3B, 0x7A, 0xEE,  0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
#endif

#ifdef ATCA_SHA105_SUPPORT
const uint8_t test_sha105_configdata[ATCA_CA2_CONFIG_SIZE] = {
    0x01, 0x23, 0x47, 0x29, 0xCA, 0x9A, 0x3B, 0x7A, 0xEE,  0x3B, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
#endif

#if defined(ATCA_SHA104_SUPPORT) || defined(ATCA_SHA105_SUPPORT)
static device_object_meta_t calib_config_sha10x_object_data[] =
{
    { TEST_TYPE_DATA, 1,                    NULL                  },
    { TEST_TYPE_HMAC, 3,                    NULL                  },
    { 0,              0,                    NULL                  }
};

ATCA_STATUS calib_config_get_sha10x_slot_by_test(uint8_t test_type, uint16_t* handle)
{
    return calib_config_get_slot_internal(calib_config_sha10x_object_data, test_type, handle);
}
#endif

{
  "atcab_get_device": {
    "restype": "ctypes.c_void_p",
    "argtypes": null,
    "docstring": "Get the global device object. ",
    "parameters": []
  },
  "atcab_get_device_type_ext": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Get the selected device type of rthe device context. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ]
    ]
  },
  "atcab_get_device_type": {
    "restype": "ctypes.c_uint8",
    "argtypes": null,
    "docstring": "Get the current device type configured for the global ATCADevice. ",
    "parameters": []
  },
  "talib_wakeup": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": null,
    "parameters": []
  },
  "talib_idle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": null,
    "parameters": []
  },
  "talib_sleep": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": null,
    "parameters": []
  },
  "_talib_exit": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": null,
    "parameters": []
  },
  "talib_get_zone_size": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_size_t)"
    ],
    "docstring": "Gets the size of the specified zone in bytes. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "zone",
        "Zone to get size information from. Config(0), OTP(1), or Data(2) which requires a slot. "
      ],
      [
        "handle",
        "If zone is Data(2), report the handle size "
      ],
      [
        "size",
        "Zone size is returned here."
      ]
    ]
  },
  "talib_cfg_discover": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ATCAIfaceCfg*",
      "ctypes.c_int"
    ],
    "docstring": null,
    "parameters": []
  },
  "talib_aes_keyload": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Loads a Key into internal key memory for AES operation. This must be called before performing AES operations. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "mode",
        "Mode value for key load operation "
      ],
      [
        "iv_index",
        "IV offset in the Key handle. Applicable only for TLS1.2 IV mode "
      ],
      [
        "key_index",
        "Key Offset in the Key group / Handle "
      ],
      [
        "key_handle",
        "Handle of the Symmetric key to be used"
      ]
    ]
  },
  "talib_aes_ecb": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Perform an AES-128 ECB encrypt or decrypt operation with a key in the device. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "mode",
        "Mode value for AES operation, including encryption or decryption setting "
      ],
      [
        "aes_in",
        "Input text to be encrypted or decrypted (16 bytes). "
      ],
      [
        "aes_out",
        "Output plaintext or ciphertext is returned here (16 bytes)."
      ]
    ]
  },
  "talib_aes_gcm": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Perform an AES-128 GCM encrypt or decrypt operation with a key in the device. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "mode",
        "Mode value for AES operation, including encryption or decryption setting "
      ],
      [
        "aad_length",
        "Length of the auth_data to include in GCM operation "
      ],
      [
        "message_length",
        "Length of the message to include in GCM operation "
      ],
      [
        "iv",
        "Initialization vector. "
      ],
      [
        "aad",
        "AAD data "
      ],
      [
        "message",
        "Cipher text for decrypt or Plain text for encrypt "
      ],
      [
        "tag",
        "Authentication tag to be used or returned "
      ],
      [
        "data_out",
        "The output data plain text or decrypt text. "
      ]
    ]
  },
  "talib_aes_encrypt": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint8",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "Perform an AES-128 encrypt operation with a key in the device. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "key_id",
        "Key handle containing the AES key. "
      ],
      [
        "key_block",
        "Index within the key handle to be used as AES key. "
      ],
      [
        "plaintext",
        "Input plaintext to be encrypted (16 bytes). "
      ],
      [
        "ciphertext",
        "Output ciphertext is returned here (16 bytes)."
      ]
    ]
  },
  "talib_aes_decrypt": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint8",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "Perform an AES-128 decrypt operation with a key in the device. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "key_id",
        "Key handle containing the AES key. "
      ],
      [
        "key_block",
        "Index of the 16-byte block to use within the key location for the actual key. "
      ],
      [
        "ciphertext",
        "Input ciphertext to be decrypted (16 bytes). "
      ],
      [
        "plaintext",
        "Output plaintext is returned here (16 bytes)."
      ]
    ]
  },
  "talib_aes_gcm_keyload": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint8"
    ],
    "docstring": "Performs loading of an AES-128 key to the engine in device. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "key_id",
        "Key handle containing the AES key. "
      ],
      [
        "key_block",
        "Index of the byte block to use within the key location for the actual key."
      ]
    ]
  },
  "talib_aes_gcm_keyload_with_implicit_iv": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint8",
      "ctypes.c_uint8"
    ],
    "docstring": "Performs loading of an AES-128 key & 4 byte iv to the engine in device. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "key_id",
        "Key handle containing the AES key. "
      ],
      [
        "key_block",
        "Index of the byte block to use within the key location for the actual key. "
      ],
      [
        "iv_index",
        "Index to the 4 byte IV in the key_id handle for GCM operation."
      ]
    ]
  },
  "talib_aes_gcm_encrypt": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Perform an AES-128 GCM encrypt operation with a key in the device and with given Additional authentication data, Initialization vector and the plain text. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "aad",
        "AAD data "
      ],
      [
        "aad_length",
        "Length of the auth_data to include in GCM operation "
      ],
      [
        "iv",
        "The 12 byte Initialization vector for GCP operation. "
      ],
      [
        "plaintext",
        "Plain text to be encrypted "
      ],
      [
        "plaintext_length",
        "Length of the plaintext to include in GCM operation "
      ],
      [
        "ciphertext",
        "The output cipher text "
      ],
      [
        "tag",
        "Authentication tag to be returned "
      ]
    ]
  },
  "talib_aes_gcm_encrypt_with_rand_iv": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Perform an AES-128 GCM encrypt operation with a key in the device, with given Additional authentication data, plain text and random Initialization vector generated within device. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "aad",
        "AAD data "
      ],
      [
        "aad_length",
        "Length of the auth_data to include in GCM operation "
      ],
      [
        "plaintext",
        "Plain text to be encrypted "
      ],
      [
        "plaintext_length",
        "Length of the plaintext to include in GCM operation "
      ],
      [
        "ciphertext",
        "The output cipher text "
      ],
      [
        "tag",
        "Authentication tag to be returned "
      ],
      [
        "iv",
        "The 12 byte Initialization vector returned. "
      ]
    ]
  },
  "talib_aes_gcm_decrypt": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Perform an AES-128 GCM decrypt operation with a key in the device and with given Additional authentication data, Initialization vector, TAG and the cipher text. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "aad",
        "AAD data "
      ],
      [
        "aad_length",
        "Length of the auth_data to include in GCM operation "
      ],
      [
        "iv",
        "The 12 byte Initialization vector for GCP operation "
      ],
      [
        "tag",
        "Authentication tag to be verified "
      ],
      [
        "ciphertext",
        "Cipher text to be decrypted "
      ],
      [
        "ciphertext_length",
        "Length of the ciphertext to include in GCM operation "
      ],
      [
        "plaintext",
        "The output cipher text "
      ]
    ]
  },
  "talib_auth_hmac_kdf": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char*16",
      "ctypes.c_char*16"
    ],
    "docstring": "TA API - Calculate the session key for the authenticated session. ",
    "parameters": []
  },
  "talib_auth_create_hmac": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_size_t)"
    ],
    "docstring": "TA API - Create an hmac for a packet in an authenticated session. ",
    "parameters": []
  },
  "talib_auth_generate_nonce": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char*16"
    ],
    "docstring": "TA API - Exchange nonces between host and device. ",
    "parameters": []
  },
  "talib_auth_startup": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint8",
      "ctypes.c_char*32",
      "ctypes.c_char*16",
      "ctypes.c_char*16"
    ],
    "docstring": "TA API - Initiate an authorization session. ",
    "parameters": []
  },
  "talib_auth_execute_nested": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_void_p",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes a nested command. ",
    "parameters": []
  },
  "talib_auth_terminate": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "TA API - Terminate an authorization session. ",
    "parameters": []
  },
  "talib_counter": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_uint32)"
    ],
    "docstring": "TA API - Compute the Counter functions. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "the mode used for the counter "
      ],
      [
        "counter_id",
        "The counter to be used "
      ],
      [
        "counter_value",
        "pointer to the counter value returned from device "
      ]
    ]
  },
  "talib_counter_read": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_uint32)"
    ],
    "docstring": "Read one of the device's nonvolatile counter. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "counter_id",
        "Counter to be read "
      ],
      [
        "counter_value",
        "Counter value is returned here."
      ]
    ]
  },
  "talib_counter_increment": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_uint32)"
    ],
    "docstring": "Increment one of the device's nonvolatile counter. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "counter_id",
        "Counter to be increment "
      ],
      [
        "counter_value",
        "Counter value is returned here."
      ]
    ]
  },
  "talib_create": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes Create command to create elements on shared data or volatile register. This cannot create Secure_boot special handles. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "mode parameter for the create operations "
      ],
      [
        "details",
        "Additional details for HMAC and Ephemeral elements "
      ],
      [
        "handle_in",
        "handle to use to create an element "
      ],
      [
        "handle_config",
        "Attributes information for the element to be created. Size must be 8 bytes "
      ],
      [
        "handle_out",
        "handle created by TA100 is returned here"
      ]
    ]
  },
  "talib_create_element": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes Create command to create elements on TA100 shared data memory. The handle is created by vega and handle value is copied into output buffer. This function wont create handle for ephemeral or HMAC symmetric key. This cannot create Secure_boot special handles. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle_cfg",
        "Attributes information for the element to be created. Size must be 8 bytes "
      ],
      [
        "handle_out",
        "handle created by TA100 is returned here"
      ]
    ]
  },
  "talib_create_element_with_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.POINTER(ta_element_attributes_t)"
    ],
    "docstring": "TA API - Executes Create command to create elements on TA100 shared data memory or volatile register. This cannot create Secure_boot special handles. This function wont create handle for ephemeral or HMAC symmetric key. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle_in",
        "handle to use to create an element "
      ],
      [
        "handle_config",
        "Attributes information for the element to be created. Size must be 8 bytes"
      ]
    ]
  },
  "talib_create_ephemeral_element_with_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.POINTER(ta_element_attributes_t)"
    ],
    "docstring": "TA API - Executes Create command to create Ephemeral element on volatile register This cannot create Secure_boot special handles. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "details",
        "Additional details for HMAC and Ephemeral elements "
      ],
      [
        "handle_in",
        "handle to use to create an element "
      ],
      [
        "handle_config",
        "Attributes information for the element to be created. Size must be 8 bytes"
      ]
    ]
  },
  "talib_create_hmac_element": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_size_t",
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes Create command to create HMAC symmetric elements on shared data. The handle is created by vega and handle value is copied into output buffer. This cannot create Secure_boot special handles. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "hmac_key_size",
        "size of hmac symmetric key size "
      ],
      [
        "handle_config",
        "Attributes information for the element to be created. Size must be 8 bytes "
      ],
      [
        "handle_out",
        "handle created by vega"
      ]
    ]
  },
  "talib_create_hmac_element_with_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_size_t",
      "ctypes.c_uint16",
      "ctypes.POINTER(ta_element_attributes_t)"
    ],
    "docstring": "TA API - Executes Create command to create HMAC symmetric elements on shared data memory or volatile register. This cannot create Secure_boot special handles. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "hmac_key_size",
        "size of hmac symmetric key size "
      ],
      [
        "handle_in",
        "handle to use to create an element "
      ],
      [
        "handle_config",
        "Attributes information for the element to be created. Size must be 8 bytes"
      ]
    ]
  },
  "talib_create_linked_shared_data": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA-API Execute the create command to create handle by TA100 in linked shared data. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "details",
        "Additional details for HMAC and Ephemeral elements "
      ],
      [
        "handle_config",
        "Attributes information for the element to be created. Size must be 8 bytes "
      ],
      [
        "handle_out",
        "handle created by TA100 is returned here"
      ]
    ]
  },
  "talib_delete_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint32"
    ],
    "docstring": "TA API - Executes delete command to delete elements on TA100. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "mode for delete entire chip or handle "
      ],
      [
        "handle",
        "Element handle to delete. Should point to shared or volatile register"
      ]
    ]
  },
  "talib_delete_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint32"
    ],
    "docstring": "TA API - Executes delete command to delete handle on shared data or volatile register. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle",
        "Element handle to delete. Should point to shared or volatile register"
      ]
    ]
  },
  "talib_chip_erase": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "TA API - Executes delete command to delete/erase entire chip. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ]
    ]
  },
  "talib_devupdate_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_char_p",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes devupdate command to Update one block of the nonvolatile operating code within the Vega device. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "mode",
        "Block ID. 0x00 through 0xFE legal "
      ],
      [
        "data",
        "data to Update image block "
      ],
      [
        "data_length",
        "length of update image block in bytes (maximum size is 1024)"
      ]
    ]
  },
  "talib_devupdate_init_ctx": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_int16"
    ],
    "docstring": "TA API - Initialize the Devupdate context stucture. ",
    "parameters": [
      [
        "ctx",
        "devupdate context pointer "
      ],
      [
        "first_block_size",
        "size of first block "
      ],
      [
        "second_block_szie",
        "size of remaining block"
      ]
    ]
  },
  "talib_devupdate_first_block": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes devupdate command to Update the first block (image) of the nonvolatile operating code within the Vega device. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "ctx",
        "As input, devupdate context pointer As output, Update the block id after successful first block update "
      ],
      [
        "first_block",
        "first block of the image"
      ]
    ]
  },
  "talib_devupdate_subsequent_block": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes devupdate command to Update the subsequent block (image) of the nonvolatile operating code within the Vega device. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "ctx",
        "As input, devupdate context pointer As output, Update the block id and remaining size "
      ],
      [
        "block",
        "block of the image to be updated in the device "
      ],
      [
        "block_len",
        "As input, length of the block As output, updated block length"
      ]
    ]
  },
  "talib_devupdate_image": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes devupdate command to Update the complete image of the nonvolatile operating code within the Vega device. ",
    "parameters": [
      [
        "image",
        "Update image of the non volatile operating code"
      ]
    ]
  },
  "talib_ecdh_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Base function for generating premaster secret key using ECDH. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "Mode to be used for ECDH computation "
      ],
      [
        "priv_handle",
        "Private key handle for ECDH computation, can be Volatile or Shared memory "
      ],
      [
        "target_handle",
        "Handle for ECDH computation result, can be IO, Volatile or Shared memory "
      ],
      [
        "public_key",
        "Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key , 56 bytes for P224 key and 96 bytes for P384 "
      ],
      [
        "public_key_size",
        "Length of the Public key parameter "
      ],
      [
        "pms",
        "Computed ECDH pre-master secret is returned here (28 or 32 or 48 bytes) if returned directly. Otherwise NULL."
      ]
    ]
  },
  "talib_ecdh_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char*64",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Generate pre master secret using ECDH and secret key copied into output buffer. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "priv_handle",
        "Private key handle for ECDH computation, can be Volatile or Shared memory "
      ],
      [
        "public_key",
        "Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key and 56 bytes for P224 key "
      ],
      [
        "pms",
        "Computed ECDH pre-master secret is returned here (28 or 32 bytes) if returned directly. Otherwise NULL. "
      ]
    ]
  },
  "talib_ecdh_io_buffer": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Generate pre master secret using ECDH and secret key copied into output buffer (premaster secret key size is equal to the public key size divide by 2) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "priv_handle",
        "Private key handle for ECDH computation, can be Volatile or Shared memory "
      ],
      [
        "public_key",
        "Public key input to ECDH calculation. "
      ],
      [
        "pubkey_len",
        "Length of the Public key parameter "
      ],
      [
        "pms",
        "Computed ECDH pre-master secret is returned here (public key size/2) if returned directly. Otherwise NULL. "
      ]
    ]
  },
  "talib_ecdh_xy_in_io_buffer": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Generate pre master secret using ECDH and secret key copied into output buffer (premaster secret key size is same as the public key size) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "priv_handle",
        "Private key handle for ECDH computation, can be Volatile or Shared memory "
      ],
      [
        "public_key",
        "Public key input to ECDH calculation. "
      ],
      [
        "pubkey_len",
        "Length of the Public key parameter "
      ],
      [
        "pms",
        "Computed ECDH pre-master secret is returned here (public key size) if returned directly. Otherwise NULL. "
      ]
    ]
  },
  "talib_ecdh_to_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_size_t"
    ],
    "docstring": "TA API - Generating premaster secret key using ECDH and stores in shared data or volatile register (premaster secret key size is equal to the public key size divided by 2) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "priv_handle",
        "Private key handle for ECDH computation, can be Volatile or Shared memory "
      ],
      [
        "target_handle",
        "Handle for ECDH computation result can go to Volatile or Shared memory "
      ],
      [
        "public_key",
        "Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key and 56 bytes for P224 key "
      ],
      [
        "pubkey_len",
        "Length of the Public key parameter "
      ]
    ]
  },
  "talib_ecdh_xy_to_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_size_t"
    ],
    "docstring": "TA API - Generating premaster secret key using ECDH and stores in shared data or volatile register.(premaster secret key size is same as the public key size) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "priv_handle",
        "Private key handle for ECDH computation, can be Volatile or Shared memory "
      ],
      [
        "target_handle",
        "Handle for ECDH computation result can go to Volatile or Shared memory "
      ],
      [
        "public_key",
        "Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key and 56 bytes for P224 key "
      ],
      [
        "pubkey_len",
        "Length of the Public key parameter "
      ]
    ]
  },
  "talib_export": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes the Export command, which exports the contents of a key/data element in the shared data memory. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "The key_handle that contains key/data to be exported. "
      ],
      [
        "export_data",
        "The buffer to the store the exported data. "
      ],
      [
        "export_data_length",
        "As input, the size of the export_data buffer and as output the size of the exported data."
      ]
    ]
  },
  "talib_fcconfig_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint32",
      "ctypes.POINTER(ctypes.c_uint32)"
    ],
    "docstring": "TA API - Execute the FC config command to Configure the Fast Crypto engine for the desired algorithm and select the key group. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "mode",
        "Mode Algorithm Encoding "
      ],
      [
        "handle",
        "handle of the group of symmetric keys for use "
      ],
      [
        "written_map",
        "map of those keys that were successfully written to the FCE"
      ]
    ]
  },
  "talib_import_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint32",
      "ctypes.c_char_p",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes Import command to import the encrypted key/data blob into the handle. The target handle should be created prior to this command and the value of its attribute fields must match exactly that which is contained in the exported blob with the exception of the link fields. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "either link keys are as per target handle or exported blob handle "
      ],
      [
        "handle",
        "Element handle where to import the data blob "
      ],
      [
        "blob",
        "Encrypted key/data blob "
      ],
      [
        "blob_length",
        "Length of encrypted key/data blob"
      ]
    ]
  },
  "talib_import_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes Import command to import the encrypted key/data blob into the handle. The target handle should be created prior to this command and the value of its attribute fields must match exactly that which is contained in the exported blob. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle",
        "Element handle where to import the data blob "
      ],
      [
        "blob",
        "Encrypted key/data blob "
      ],
      [
        "blob_length",
        "Length of encrypted key/data blob"
      ]
    ]
  },
  "talib_import_handle_with_target_links": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes Import command to import the encrypted key/data blob into the handle. The target handle should be created prior to this command and the value of its attribute fields must match exactly that which is contained in the exported blob with the exception of the link fields. Link keys are as per target handle (where blob going to import) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle",
        "Element handle where to import the data blob "
      ],
      [
        "blob",
        "Encrypted key/data blob "
      ],
      [
        "blob_length",
        "Length of encrypted key/data blob"
      ]
    ]
  },
  "talib_info_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint32",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_size_t)"
    ],
    "docstring": "TA API - Issues an Info command, which return internal device information. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "Selects which mode to be used for info command. "
      ],
      [
        "param2",
        "Handle for mode 2 & 3. "
      ],
      [
        "out_data",
        "Response from info command "
      ],
      [
        "data_size",
        "out_data buffer size as input and valid data length as output"
      ]
    ]
  },
  "talib_info": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*8"
    ],
    "docstring": "TA API - Issues an Info command to return revision of the internal hardware, configuration or firmware of the device. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "revision",
        "device revision number returned here"
      ]
    ]
  },
  "talib_info_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*4"
    ],
    "docstring": "TA API - Issues an Info command to return revision of the internal hardware (compatible with cryptoauthlib info command) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "revision",
        "device revision number returned here"
      ]
    ]
  },
  "talib_info_serial_number": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*8"
    ],
    "docstring": "The function returns 8 byte serial number of the device. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "serial_number",
        "8 byte serial number is returned here."
      ]
    ]
  },
  "talib_info_serial_number_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*9"
    ],
    "docstring": "The function return 8 byte serial number of the device in 9 byte buffer (compatibility mode - cryptoauth devices have a 9 byte serial number) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "serial_number",
        "8 byte serial number is returned here."
      ]
    ]
  },
  "talib_info_get_nv_remain": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.POINTER(ctypes.c_uint32)"
    ],
    "docstring": "TA API - Issues an Info command to return remaining bytes in Non Volatile memory. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "nv_remain",
        "remaining non volatile memory in the device is returned here"
      ]
    ]
  },
  "talib_is_handle_valid": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint32",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Issues an Info command to return handle validity. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "target_handle",
        "Target handle to read info "
      ],
      [
        "is_valid",
        "True if handle is created, irrespective of written or used status"
      ]
    ]
  },
  "talib_info_get_handle_info": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint32",
      "ctypes.c_char*(9)"
    ],
    "docstring": "TA API - Issues an Info command to return attributes & status of a handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "target_handle",
        "Target handle to read handle info "
      ],
      [
        "handle_info",
        "Handle info (handle attributes) returned here"
      ]
    ]
  },
  "talib_info_get_handles_array": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.POINTER(ctypes.c_uint16)",
      "ctypes.POINTER(ctypes.c_size_t)"
    ],
    "docstring": "TA API - Issues an Info command to return handles list. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle_array",
        "List of handles received as response.. "
      ],
      [
        "array_size",
        "As input, handle_array buffer size As output, number of elements in handle_array"
      ]
    ]
  },
  "talib_info_get_handle_size": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint32",
      "ctypes.POINTER(ctypes.c_size_t)"
    ],
    "docstring": "TA API - Get the data stored in a handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "target_handle",
        "Target handle to read info "
      ],
      [
        "out_size",
        "data handle size is returned here"
      ]
    ]
  },
  "talib_is_auth_session_valid": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Issues an Info command to get auth session validity. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "auth_session_id",
        "Target Auth session id to check validity, 0-1 are only valid "
      ],
      [
        "is_valid",
        "Auth session validity. True if session is valid for use"
      ]
    ]
  },
  "talib_is_volatile_register_valid": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Issues an Info command to get volatile register status. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "volatile_register_id",
        "Target Volatile register id to check validity, 0-3 are only valid "
      ],
      [
        "is_valid",
        "True if handle is created, irrespective of written or used status"
      ]
    ]
  },
  "talib_info_get_dedicated_memory": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Issues an Info command to return dedicated memory contents. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "dedicated_memory",
        "dedicated memory content of 16 byte is return here"
      ]
    ]
  },
  "talib_info_get_chip_status": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*(6)"
    ],
    "docstring": "TA API - Issues an Info command to return chip status. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "chip_status",
        "chip status (config lock status, setup lock status, latch status) returned here"
      ]
    ]
  },
  "talib_is_config_locked": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Issues an Info command to get config lock status. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "is_locked",
        "True if config is locked or else false"
      ]
    ]
  },
  "talib_is_setup_locked": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Issues an Info command to get setup lock status. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "is_locked",
        "True if setup is locked or else false"
      ]
    ]
  },
  "talib_is_locked_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "Executes Read command, which reads the configuration zone to see if the specified zone is locked. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "zone",
        "The zone to query for locked (use LOCK_ZONE_CONFIG or LOCK_ZONE_SETUP). "
      ],
      [
        "is_locked",
        "Lock state returned here. True if locked. "
      ]
    ]
  },
  "talib_info_get_vcc_latch": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Issues an Info command to get Vcc latch state. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "latch_value",
        "return current state of the vcc latches"
      ]
    ]
  },
  "talib_info_get_failure_log": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Issues an Info command to get Failure logs. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "failure_log",
        "previous self test failure log is returned here (64 byte)"
      ]
    ]
  },
  "talib_info_get_rom_id": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Issues an Info command to get ROM ID. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "rom_id",
        "Device rom version id is returned here"
      ]
    ]
  },
  "talib_info_get_crl_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Issues an Info command to get CRL handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "crl_handle",
        "valid crl handle is returned here"
      ]
    ]
  },
  "talib_is_handle_locked": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "Executes info command, which reads the handle info to see if the specified handle element is locked. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle",
        "Handle to query for locked "
      ],
      [
        "is_locked",
        "Lock state returned here. True if locked."
      ]
    ]
  },
  "talib_kdf_aesA": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes AES OptionA operations using KDF command. Output_Handle = AESencrypt(key, Message[16:31]) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "msg_handle",
        "handle refers to the message which present in device "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "output_handle",
        "kdf output will be stored in this handle "
      ],
      [
        "message",
        "Message to send on IO if indicated by message_handle if present, should be 32 bytes "
      ],
      [
        "kdf_out",
        "Output of the KDF AES-A function is retuned here."
      ]
    ]
  },
  "talib_kdf_aesA_io": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes AES OptionA operations using KDF command, result is on IO buffer. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "msg_handle",
        "Input handle for the message "
      ],
      [
        "message",
        "Message to send on IO if indicated by message_handle if present, should be 32 bytes "
      ],
      [
        "kdf_output",
        "Output of the KDF - AESA function is retuned here."
      ]
    ]
  },
  "talib_kdf_aesA_stored": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes AES OptionA operations using KDF command, result is stored inside device either in shared data memory or volatile register. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "message_handle",
        "handle refers to the message which present in device "
      ],
      [
        "message",
        "Message to send on IO if indicated by message_handle if present, should be 32 bytes "
      ],
      [
        "output_handle",
        "Stores the KDF output result in this handle"
      ]
    ]
  },
  "talib_kdf_aesB": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes AES OptionB operations using KDF command. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "msg_handle",
        "handle refers to the message (which present in device) "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "output_handle",
        "Holds the KDF output result "
      ],
      [
        "input_data",
        "Application data to include in computation, should be 16 bytes "
      ],
      [
        "kdf_out",
        "Output of the HKDF function is retuned here."
      ]
    ]
  },
  "talib_kdf_aesB_io": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes AES OptionB operations using KDF command, result is on IO buffer. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "message_handle",
        "Input handle for the message "
      ],
      [
        "input_data",
        "Message to send on IO if indicated by message_handle if present, should be 16 bytes "
      ],
      [
        "kdf_output",
        "Output of the KDF - AESA function is retuned here."
      ]
    ]
  },
  "talib_kdf_aesB_stored": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes AES OptionB operations using KDF command, result is stored inside device in either shared data memory or volatile register. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "output_handle",
        "Holds the KDF output result "
      ],
      [
        "message_handle",
        "handle refers to the message (which present in device) "
      ],
      [
        "input_data",
        "Application data to include in computation, should be 16 bytes"
      ]
    ]
  },
  "talib_hkdf": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes HKDF operation using KDF command. Extract_key = HMAC(Salt, Key_Handle) Out_Handle[0-31] = HMAC(Key_ Extract_key, Info | 1) Out_Handle[32-63] = HMAC(Key_ Extract_key, Out_Handle[0-31] | Info | 2) Out_Handle[64-95] = HMAC(Key_ Extract_key, Out_Handle[32-63] | Info | 3) Out_Handle[96-127] = HMAC(Key_ Extract_key, Out_Handle[64-95] | Info | 4) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "output_handle",
        "Holds the KDF output result "
      ],
      [
        "salt_len",
        "Input Salt size "
      ],
      [
        "info_len",
        "Input Info size "
      ],
      [
        "salt",
        "Input Salt for HKDF-Extract phase "
      ],
      [
        "info",
        "Application specific info for HKDF-Exapnd phase "
      ],
      [
        "kdf_out",
        "Output of the HKDF function is retuned here. "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_hkdf_io": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes HKDF operation using KDF command, result in IO buffer. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "salt",
        "Input Salt for HKDF-Extract phase "
      ],
      [
        "salt_len",
        "Input Salt size "
      ],
      [
        "info",
        "Application specific info for HKDF-Exapnd phase "
      ],
      [
        "info_len",
        "Input Info size "
      ],
      [
        "kdf_output",
        "Output of the HKDF function is retuned here. "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_hkdf_stored": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes HKDF operation using KDF command, result is stored inside device either in shared data memory or volatile register. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "salt",
        "Input Salt for HKDF-Extract phase "
      ],
      [
        "salt_len",
        "Input Salt size "
      ],
      [
        "info",
        "Application specific info for HKDF-Exapnd phase "
      ],
      [
        "info_len",
        "Input Info size "
      ],
      [
        "target_handle",
        "Holds the KDF output result "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_kdf_prf": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes PRF operation using KDF command. A1 = HMAC(Key_Handle, Input_Data) Out_Handle[0-31] = HMAC(Key_Handle, A1 | Input_Data) A2 = HMAC(Key_Handle, A1) Out_Handle[32-63] = HMAC(Key_Handle, A2 | Input_Data) A3 = HMAC(Key_Handle, A2) Out_Handle[64-95] = HMAC(Key_Handle, A3 | Input_Data) A4 = HMAC(Key_Handle, A3) Out_Handle[96-127] = HMAC(Key_Handle, A4 | Input_Data) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "output_handle",
        "Holds the KDF output result "
      ],
      [
        "input_len",
        "Input \"input\" size "
      ],
      [
        "input_data",
        "concatenated value of label and seed "
      ],
      [
        "kdf_out",
        "Output of the HKDF function is retuned here. "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_kdf_prf_io": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint8",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes PRF operation using KDF command, result in IO buffer. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "src_key_length",
        "Source Key length in bytes. 16, 32, 48 and 64 are only valid "
      ],
      [
        "input",
        "concatenated value of label and seed "
      ],
      [
        "input_len",
        "Input \"input\" size "
      ],
      [
        "kdf_output",
        "Output of the HKDF function is retuned here. "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_kdf_prf_stored": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint8",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes PRF operation using KDF command, result is stored inside device either in shared data memory or volatile register. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "src_key_length",
        "Source Key length in bytes. 16, 32, 48 and 64 are only valid "
      ],
      [
        "input",
        "concatenated value of label and seed "
      ],
      [
        "input_len",
        "Input \"input\" size "
      ],
      [
        "target_handle",
        "Holds the KDF output result "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_kdf_hmac_counter": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes HMAC-Counter operation using KDF command. Bytes 0-31: HMAC(key_handle, 1 | Label | 0 | Context | Length) Bytes 32-63: HMAC(key_handle, 2 | Label | 0 | Context | Length) Bytes 64-95: HMAC(key_handle, 3 | Label | 0 | Context | Length) Bytes 95-127: HMAC(key_handle, 4 | Label | 0 | Context | Length) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "output_handle",
        "Holds the KDF output result "
      ],
      [
        "label_len",
        "Input label size "
      ],
      [
        "context_len",
        "Input context size "
      ],
      [
        "label",
        "Input label string provided by host "
      ],
      [
        "context",
        "Input context provided by host "
      ],
      [
        "kdf_out",
        "Output of the HKDF function is retuned here. "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_kdf_hmac_counter_io": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes HMAC-Counter operation using KDF command, result is in IO buffer. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "label",
        "Input label string provided by host "
      ],
      [
        "label_len",
        "Input label size "
      ],
      [
        "context",
        "Input context provided by host "
      ],
      [
        "context_len",
        "Input context size "
      ],
      [
        "kdf_output",
        "Output of the HKDF function is retuned here. "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_kdf_hmac_counter_stored": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes HMAC-Counter operation using KDF command, result is stored inside device either in shared data memory or volatile register. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "label",
        "Input label string provided by host "
      ],
      [
        "label_len",
        "Input label size "
      ],
      [
        "context",
        "Input context provided by host "
      ],
      [
        "context_len",
        "Input context size "
      ],
      [
        "target_handle",
        "Holds the KDF output result "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_kdf_sha256": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes SHA256 operation using KDF command. Bytes 0-31: SHA256(Pre_pad | key_handle | Post_pad) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "output_handle",
        "Holds the KDF output result "
      ],
      [
        "pre_pad",
        "Host data to prepad IKM "
      ],
      [
        "pre_len",
        "Input pre-pad size "
      ],
      [
        "post_pad",
        "Host data to prepad IKM "
      ],
      [
        "post_len",
        "Input post-pad size "
      ],
      [
        "kdf_out",
        "Output of the HKDF function is retuned here. "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_kdf_sha256_io": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes SHA256 operation using KDF command, result in IO buffer. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "pre_pad",
        "Host data to prepad IKM "
      ],
      [
        "pre_pad_len",
        "Input pre-pad size "
      ],
      [
        "post_pad",
        "Host data to prepad IKM "
      ],
      [
        "post_pad_len",
        "Input post-pad size "
      ],
      [
        "kdf_output",
        "Output of the HKDF function is retuned here. "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_kdf_sha256_stored": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes SHA256 operation using KDF command, result is stored inside device either in shared data memory or volatile register. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Contains Input Key Material "
      ],
      [
        "pre_pad",
        "Host data to prepad IKM "
      ],
      [
        "pre_pad_len",
        "Input pre-pad size "
      ],
      [
        "post_pad",
        "Host data to prepad IKM "
      ],
      [
        "post_pad_len",
        "Input post-pad size "
      ],
      [
        "target_handle",
        "Holds the KDF output result "
      ],
      [
        "kdf_length",
        "As input, expected Key Material size As output, length of the Key Material in kdf_output"
      ]
    ]
  },
  "talib_genkey_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint32",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_size_t)"
    ],
    "docstring": "TA API - Issues GenKey command, which generates a new random key in handle and returns the public key if applicable. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "Mode determines what operations the GenKey command performs "
      ],
      [
        "key_handle",
        "Handle for a Symmetric or private key "
      ],
      [
        "public_key",
        "Public key will be returned here. Format will be the X and Y integers in big-endian format. Length depends on the Key attributes. Set to NULL if public key isn't required. "
      ],
      [
        "pubkey_len",
        "As input, expected public key length As output, public key length received from device."
      ]
    ]
  },
  "talib_genkey": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_size_t)"
    ],
    "docstring": "TA API - Issues GenKey command, which generates a new random key in handle and returns the public key if applicable. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Handle for a Symmetric or private key "
      ],
      [
        "public_key",
        "Public key will be returned here. Format will be the X and Y integers in big-endian format. Length depends on the Key attributes. Set to NULL if public key isn't required. "
      ],
      [
        "pubkey_len",
        "As input, expected public key length As output, public key length received from device."
      ]
    ]
  },
  "talib_genkey_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char*64"
    ],
    "docstring": "Issue Keygen command, which generates a new random ECCP256 private key in handle and returns the public key. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Handle of a private key. "
      ],
      [
        "public_key",
        "Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required."
      ]
    ]
  },
  "talib_get_pubkey_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char*64"
    ],
    "docstring": "Uses GenKey command to calculate the public key from an existing ECCP256 private key in a handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Handle of a private key. "
      ],
      [
        "public_key",
        "Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required."
      ]
    ]
  },
  "talib_get_pubkey": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_size_t)"
    ],
    "docstring": "Uses GenKey command to calculate the public key from an existing private key in a handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Handle of a private key. "
      ],
      [
        "public_key",
        "Public key will be returned here. "
      ],
      [
        "pubkey_len",
        "As input, expected public key length As output, public key length received from device."
      ]
    ]
  },
  "talib_genkey_symmetric_key": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16"
    ],
    "docstring": "Uses GenKey command to calculate the symmetric key and load into given handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "generated symmetric key write into handle."
      ]
    ]
  },
  "talib_lock": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint32"
    ],
    "docstring": "TA API - Executes Lock command to prevent further updates to Configuration or Setup or shared data or one time based on the mode. Once locked, these can't be unlocked. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "Parameter to select the memory type and options to lock "
      ],
      [
        "param2",
        "CRC if locking Config, Handle if locking a shared element"
      ]
    ]
  },
  "talib_lock_config": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Lock the config zone without CRC. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ]
    ]
  },
  "talib_lock_config_with_crc": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16"
    ],
    "docstring": "Lock the config zone with summary CRC. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "summary_crc",
        "Expected CRC over the config zone."
      ]
    ]
  },
  "talib_lock_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16"
    ],
    "docstring": "Lock an individual handle in the data zone on an ATECC device. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle",
        "handle to be locked in nv shared data zone."
      ]
    ]
  },
  "talib_lock_setup": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Locks Setup memory. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ]
    ]
  },
  "talib_lock_onetime_latch": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Locks one time latch. Applicable only when enabled in Chip Options. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ]
    ]
  },
  "talib_mac_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes MAC command for CMAC and HMAC calculations. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Handle of the Symmetric key to be used either present in Shared data or Volatile register "
      ],
      [
        "key_index",
        "Key index in the Key grup if handle points to a group "
      ],
      [
        "message",
        "Challenge message of max size 1022 bytes "
      ],
      [
        "msg_length",
        "Carries the message length "
      ],
      [
        "digest",
        "CMAC or HMAC response is returned here (16 or 32 bytes) "
      ],
      [
        "mac_length",
        "As input, digest buffer size As output, mac size in digest buffer"
      ]
    ]
  },
  "talib_cmac": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes MAC command for CMAC calculations. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Handle of the Symmetric key to be used either present in Shared data or Volatile register "
      ],
      [
        "key_index",
        "Key index in the Key grup if handle points to a group "
      ],
      [
        "message",
        "Challenge message of max size 1022 bytes "
      ],
      [
        "length",
        "carries the message length "
      ],
      [
        "cmac",
        "CMAC response is returned here (16 bytes)"
      ]
    ]
  },
  "talib_hmac": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes MAC command for HMAC calculations. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Handle of the Symmetric key to be used either present in Shared data or Volatile register "
      ],
      [
        "key_index",
        "Key index in the Key grup if handle points to a group "
      ],
      [
        "message",
        "Challenge message of max size 1022 bytes "
      ],
      [
        "length",
        "carries the message length "
      ],
      [
        "hmac",
        "HMAC response is returned here (32 bytes)"
      ]
    ]
  },
  "talib_hmac_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint8"
    ],
    "docstring": "Executes MAC command for HMAC calculation (compatible with sha-hmac command) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "data",
        "Challenge message of max size 1022 bytes "
      ],
      [
        "data_size",
        "carries the message length "
      ],
      [
        "key_slot",
        "Handle of the Symmetric key to be used either present in Shared data or Volatile register "
      ],
      [
        "digest",
        "HMAC response is returned here (32 bytes) "
      ],
      [
        "target",
        "Where to save the digest internal to the device."
      ]
    ]
  },
  "talib_manage_cert": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes ManageCert command to parse and verify x.509 certs or manage an input certificate revocation list. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "mode",
        "mode parameter for ManageCert command "
      ],
      [
        "parent_handle",
        "Verifying certificate handle. This can be in Shared or Volatile "
      ],
      [
        "target_handle",
        "Handle to write verified certificate or CRL element. After successful verification, extracted element is written to this handle. A value of 0xFFFF, skips write to handle but returns verification status "
      ],
      [
        "source_handle",
        "Handle pointing to Full certificate or CRL. Only supports IO buffer or shared memory, but not Volatile register. CRL must point to IO buffer. "
      ],
      [
        "in_cert",
        "Incoming certificate or CRL when source handle pointing to IO buffer. Maximum size is 1020. Should be NULL if source_handle points to internal memory "
      ],
      [
        "length",
        "Length of the incoming certificate or CRL. Applicable only when in_cert exists on the IO buffer"
      ]
    ]
  },
  "talib_store_extracted_cert_io": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes ManageCert command to verify x.509 incoming cert and store extracted certificate to shared element. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "parent_handle",
        "Verifying certificate handle. This can be in Shared or Volatile "
      ],
      [
        "target_handle",
        "Handle to write verified certificate. After successful verification, extracted elements are written to this handle. "
      ],
      [
        "in_cert",
        "Incoming certificate to verify and extract "
      ],
      [
        "cert_length",
        "Length of the incoming certificate"
      ]
    ]
  },
  "talib_store_extracted_cert": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes ManageCert command to verify x.509 stored cert and store extracted certificate to shared element. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "parent_handle",
        "Verifying certificate handle. This can be in Shared or Volatile "
      ],
      [
        "target_handle",
        "Handle to write verified certificate. After successful verification, extracted elements are written to this handle. "
      ],
      [
        "source_handle",
        "Handle pointing to Full certificate only supports shared memory"
      ]
    ]
  },
  "talib_verify_cert_io": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes ManageCert command to verify x.509 incoming cert and returns verification status. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "parent_handle",
        "Verifying certificate handle. This can be in Shared or Volatile "
      ],
      [
        "in_cert",
        "Incoming certificate to verify and extract "
      ],
      [
        "cert_length",
        "Length of the incoming certificate"
      ]
    ]
  },
  "talib_verify_cert": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Executes ManageCert command to verify x.509 stored cert and returns verification status. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "parent_handle",
        "Verifying certificate handle. This can be in Shared or Volatile "
      ],
      [
        "source_handle",
        "Handle pointing to Full certificate only supports shared memory"
      ]
    ]
  },
  "talib_power": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Executes MAC command for CMAC and HMAC calculations. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "Mode parameter to control the power state of the device"
      ]
    ]
  },
  "talib_power_reboot": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "TA API - Executes Power command to reboot the TA100. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ]
    ]
  },
  "talib_power_sleep": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "TA API - Executes Power command to sleep the TA100. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ]
    ]
  },
  "talib_random": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*16",
      "ctypes.c_char_p",
      "ctypes.c_uint32"
    ],
    "docstring": "TA API - Executes Random command and returns requested number of random bytes. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "stir_data",
        "Extra data to be stirred into the random number calculation. Should be 16 bytes "
      ],
      [
        "rand_out",
        "Requested number of random bytes are returned here "
      ],
      [
        "rand_length",
        "Contains number of random bytes to read"
      ]
    ]
  },
  "talib_random_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*32"
    ],
    "docstring": "Compatibility mode which generates a 32 byte random number from the TA100 device. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "rand_out",
        "32 bytes of random data is returned here."
      ]
    ]
  },
  "talib_read": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_uint16)",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes Read command to read an element from shared data memory. This supports both partial and completed writes Restrictions apply based on attributes of the element Volatile registers can never be read. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "mode parameter for the read operations "
      ],
      [
        "transfer_handle",
        "Remote device write handle in case of transfer operation "
      ],
      [
        "key_handle",
        "Target handle to initiate read operation "
      ],
      [
        "offset",
        "Offset to the first byte to be read... Applicable only to Shared data memory only Valid only for partial reads "
      ],
      [
        "length",
        "As Input, number of bytes to read. Cannot exceed element size Valid only for partial reads As Output, number bytes read is returned here "
      ],
      [
        "data_read",
        "Actual data read is returned here "
      ],
      [
        "mac",
        "MAC for the transfer function."
      ]
    ]
  },
  "talib_read_element": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_uint16)",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes Read command to read complete element from shared data memory. Restrictions apply based on attributes of the element. Volatile registers can never be read. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Target handle to initiate read operation "
      ],
      [
        "length",
        "As Input, number of bytes to read. Cannot exceed element size "
      ],
      [
        "data_out",
        "Actual data read is returned here"
      ]
    ]
  },
  "talib_read_partial_element": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_uint16)",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes Read command to read partial element from shared date memory. Restrictions apply based on attributes of the element. Volatile registers can never be read. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Target handle to initiate read operation "
      ],
      [
        "offset",
        "Offset to the first byte to be read... Applicable only to Shared data memory only "
      ],
      [
        "length",
        "As Input, number of bytes to read. Cannot exceed element size As Output, number bytes read is returned here "
      ],
      [
        "data",
        "Actual data read is returned here"
      ]
    ]
  },
  "talib_read_config_zone": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes Read command to read the complete device configuration handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "config_data",
        "Configuration zone data is returned here."
      ]
    ]
  },
  "talib_read_gpio_pin_state": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes Read command to read the gpio pin state. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "gpio_handle",
        "refer to gpio handle (gpio1, gpio2, gpio2) "
      ],
      [
        "pin_state",
        "state of the gpio pin returned here"
      ]
    ]
  },
  "talib_read_pubkey_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char*64"
    ],
    "docstring": "Executes Read command to read an ECC P256 public key from a handle for clear reads. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle",
        "Handle number to read from. "
      ],
      [
        "public_key",
        "Public key is returned here."
      ]
    ]
  },
  "talib_read_bytes_zone": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_size_t",
      "ctypes.c_char_p",
      "ctypes.c_size_t"
    ],
    "docstring": "Used to read an arbitrary number of bytes from internal memory for clear reads. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "zone",
        "Zone to read data from. Unused "
      ],
      [
        "handle",
        "handle number to read "
      ],
      [
        "offset",
        "Byte offset within the handle to read from. "
      ],
      [
        "data",
        "Read data is returned here. "
      ],
      [
        "length",
        "Number of bytes to read starting from the offset."
      ]
    ]
  },
  "talib_read_sig_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char*64"
    ],
    "docstring": "Executes Read command to read a 64 byte ECDSA P256 signature from a slot configured for clear reads. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle",
        "Handle number to read from. "
      ],
      [
        "signature",
        "Signature will be returned here (64 bytes). Format will be the 32 byte R and S big-endian integers concatenated."
      ]
    ]
  },
  "talib_read_data_transfer": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes Read command to transfer key to another vega device. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "transfer_handle",
        "handle where data need to be written "
      ],
      [
        "data",
        "transfer package is returned here "
      ],
      [
        "transfer_mac",
        "mac for transfer read"
      ]
    ]
  },
  "talib_cmp_config_zone": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*(48)",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "Compares a specified configuration zone with the configuration zone currently on the device. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "config_data",
        "Full configuration data to compare the device against. "
      ],
      [
        "same_config",
        "Result is returned here. True if the static portions on the configuration zones are the same."
      ]
    ]
  },
  "talib_rsaenc": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes RSAEnc command to perform RSA Encryption and Decryption operations Maximum number of bytes that can be encrypted or decrypted is 62. This is available only for RSA-1024 bit keys. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "mode parameter for RSAEnc command "
      ],
      [
        "in_length",
        "number of bytes in data_in "
      ],
      [
        "handle",
        "RSA Key handle for encrypt or decrypt operation "
      ],
      [
        "data_in",
        "Input data to encrypt or decrypt"
      ],
      [
        "data_out",
        "Encrypt or decrypt result is returned here "
      ],
      [
        "public_key",
        "RSA-1024 bit public key for encryption if handle is IO buffer, otherwise NULL. "
      ],
      [
        "out_length",
        "As Input, size of data_out As output, number of bytes in data_out"
      ]
    ]
  },
  "talib_rsaenc_encrypt": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes RSAEnc command to perform RSA Encryption. Encrypt using shared data element which is referred by handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle",
        "RSA public Key handle for encrypt operation "
      ],
      [
        "text_size",
        "number of bytes of plain text (maximum 62 bytes) "
      ],
      [
        "plain_text",
        "Input data to encrypt "
      ],
      [
        "cipher_text_size",
        "The size of the ciphertext buffer "
      ],
      [
        "cipher_text",
        "Encrypted result is returned here "
      ]
    ]
  },
  "talib_rsaenc_encrypt_with_iobuffer": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes RSAEnc command to perform RSA Encryption. Encrypt using given public key in input buffer. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "pub_key",
        "public key used to encrypt the plain text "
      ],
      [
        "text_size",
        "number of bytes of plain text (maximum 62 bytes) "
      ],
      [
        "plain_text",
        "Input data to encrypt "
      ],
      [
        "cipher_text_size",
        "The size of the ciphertext buffer "
      ],
      [
        "cipher_text",
        "Encrypted result is returned here"
      ]
    ]
  },
  "talib_rsaenc_decrypt": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes RSAEnc command to perform RSA Decryption. Decrypt using private key referred by the handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle",
        "RSA private Key handle to decrypt cipher text "
      ],
      [
        "text_size",
        "number of bytes of cipher text which is always 128 bytes. "
      ],
      [
        "cipher_text",
        "Input data to decrypt "
      ],
      [
        "plain_text_size",
        "Size of the plain_text buffer. "
      ],
      [
        "plain_text",
        "decrypted result is returned here"
      ]
    ]
  },
  "talib_secureboot_full_asymmetric": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Execute secureboot command with full asymmetric mode. signature is validated against extracted certificates or secure boot public key. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "dig_handle",
        "Handle for the code digest "
      ],
      [
        "pub_handle",
        "Handle for the validating public key which must be a root key or extracted certificate element "
      ],
      [
        "digest",
        "Input digest "
      ],
      [
        "signature",
        "Input code signature "
      ],
      [
        "sig_len",
        "length of the input signature "
      ],
      [
        "is_validated",
        "result of secure boot validation (True or False)"
      ]
    ]
  },
  "talib_secureboot_preset": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Execute secure boot command preset phase mode for full stored, partial and pre boot config mode. This phase allocates the necessary space for the stored digest in the secureboot handle. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "mode",
        "determine full store or partial or pre-boot For full stored, 0x10 For partial, 0x20 For pre-boot, 0x40 "
      ],
      [
        "dig_handle",
        "handle for the code digest. For full stored and pre-boot, it is always 0x4800 For partial, it is always 0x0000 "
      ],
      [
        "param",
        "determine digest present in io buffer or not For full stored and pre-boot, it is either 0x0001 or 0x0000 For partial, it is always 0x0000 "
      ],
      [
        "digest",
        "input code digest"
      ]
    ]
  },
  "talib_secureboot_update": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Execute secureboot command with update phase mode for full stored and pre-boot For partial config mode, this phase is similar with complete phase This phase writes a new digest to the special handle allocated during the Preset phase. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "mode",
        "determine config mode For full stored, 0x11 For partial, 0x24 For pre-boot, 0x41 "
      ],
      [
        "dig_handle",
        "Handle for the code digest For partial, 0x0000 "
      ],
      [
        "pub_handle",
        "Handle for the validating public key which must be a root key or extracted certificate element "
      ],
      [
        "digest",
        "Input digest For partial, no input digest required "
      ],
      [
        "signature",
        "Input code signature "
      ],
      [
        "sig_len",
        "length of the input signature "
      ],
      [
        "is_validated",
        "result of secure boot validation (True or False)"
      ]
    ]
  },
  "talib_secureboot_boot": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Execute secureboot command with boot phase mode for full store, partial and pre boot config mode. Validate the code digest from the host against stored digest. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "mode",
        "Determine config mode For full store, 0x12 For partial, 0x26 For pre boot, 0x42 "
      ],
      [
        "dig_handle",
        "Handle for the code digest "
      ],
      [
        "digest",
        "input code digest "
      ],
      [
        "is_validated",
        "result of secure boot validation (True or False)"
      ]
    ]
  },
  "talib_secureboot_fullstore_preset": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Execute secure boot command preset phase mode for full stored config mode. This phase allocates the necessary space for the stored digest in the secureboot handle. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "digest",
        "input code digest"
      ]
    ]
  },
  "talib_secureboot_fullstore_update": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Execute secureboot command with update phase mode for full stored config mode. This phase writes a new digest to the special handle allocated during the Preset phase. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "dig_handle",
        "Handle for the code digest "
      ],
      [
        "pub_handle",
        "Handle for the validating public key which must be a root key or extracted certificate element "
      ],
      [
        "digest",
        "Input digest "
      ],
      [
        "signature",
        "Input code signature "
      ],
      [
        "sig_len",
        "length of the input signature "
      ],
      [
        "is_validated",
        "result of secure boot validation (True or False)"
      ]
    ]
  },
  "talib_secureboot_fullstore_boot": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Execute secureboot command with boot phase mode for full store config mode. Validate the code digest from the host against stored digest. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "dig_handle",
        "Handle for the code digest "
      ],
      [
        "digest",
        "input code digest "
      ],
      [
        "is_validated",
        "result of secure boot validation (True or False)"
      ]
    ]
  },
  "talib_secureboot_partial_preset": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "TA API - Execute secure boot command preset phase mode for partial config mode. This phase allocates the necessary space for the stored digest in the secureboot handle. ",
    "parameters": [
      [
        "device",
        "device context pointer"
      ]
    ]
  },
  "talib_secureboot_partial_setup": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint32"
    ],
    "docstring": "TA API - Execute secure boot command for setup phase in partial config mode This phase initializes the code update sequence. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "code_size",
        "Total size of the code over which the signature was generated"
      ]
    ]
  },
  "talib_secureboot_partial_code_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_char_p",
      "ctypes.c_size_t"
    ],
    "docstring": "TA API - Execute Secureboot command in partial config mode to update the code Pass a full SHA256 (64 byte) block of code to the Vega device as part of the overall code load/upgrade procedure. This phase is run repeatedly till the final full or partial block has been sent. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "mode",
        "determine initial block or final block "
      ],
      [
        "code",
        "Subsequent block of operating code bytes "
      ],
      [
        "code_size",
        "size of the operating code"
      ]
    ]
  },
  "talib_secureboot_partial_code": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Execute Secureboot command in partial config mode to update the initial code Pass a full SHA256 (64 byte) block of code to the Vega device as part of the overall code load/upgrade procedure. This phase is run repeatedly till before the final full or partial block has been sent. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "code",
        "Subsequent block of operating code bytes Data must be of 64 bytes"
      ]
    ]
  },
  "talib_secureboot_partial_final": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.c_size_t"
    ],
    "docstring": "TA API - Execute Secureboot command in partial config mode to update the final code This phase update the final code block. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "code",
        "Subsequent block of operating code bytes "
      ],
      [
        "code_size",
        "size of the operating code"
      ]
    ]
  },
  "talib_secureboot_partial_complete": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Execute secureboot command in partial config mode of complete phase This phase verifies the signature and updated the partial digests. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "pub_handle",
        "Handle for the validating public key which must be a root key or extracted certificate element "
      ],
      [
        "signature",
        "Input code signature "
      ],
      [
        "sig_len",
        "length of the input signature "
      ],
      [
        "is_validated",
        "result of secure boot validation (True or False)"
      ]
    ]
  },
  "talib_secureboot_partial_address": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.POINTER(ctypes.c_uint32)",
      "ctypes.POINTER(ctypes.c_uint32)"
    ],
    "docstring": "TA API - Execute secureboot command in partial config mode of address phase This pahse retrieve address min/max bounds from the Vega device. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "begin",
        "The begin address (inclusive) for the current portion over which host should calculate digest "
      ],
      [
        "end",
        "The ending address (inclusive) for the current portion"
      ]
    ]
  },
  "talib_secureboot_partial_boot": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Execute secureboot command with boot phase mode for partial config mode. Validate the code digest from the host against stored digest. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "dig_handle",
        "Handle for the code digest "
      ],
      [
        "digest",
        "input code digest "
      ],
      [
        "is_validated",
        "result of secure boot validation (True or False)"
      ]
    ]
  },
  "talib_secureboot_preboot_preset": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Execute secure boot command preset phase mode for pre boot config mode. This phase allocates the necessary space for the stored digest in the secureboot handle. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "digest",
        "input code digest"
      ]
    ]
  },
  "talib_secureboot_preboot_update": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.c_size_t",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Execute secureboot command with update phase mode for pre boot config mode. This phase writes a new digest to the special handle allocated during the Preset phase. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "dig_handle",
        "Handle for the code digest "
      ],
      [
        "pub_handle",
        "Handle for the validating public key which must be a root key or extracted certificate element "
      ],
      [
        "digest",
        "Input digest "
      ],
      [
        "signature",
        "Input code signature "
      ],
      [
        "sig_len",
        "length of the input signature "
      ],
      [
        "is_validated",
        "result of secure boot validation (True or False)"
      ]
    ]
  },
  "talib_secureboot_preboot_boot": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Execute secureboot command with boot phase mode for pre boot config mode. Validate the code digest from the host against stored digest. ",
    "parameters": [
      [
        "device",
        "device context pointer "
      ],
      [
        "dig_handle",
        "Handle for the code digest "
      ],
      [
        "digest",
        "input code digest "
      ],
      [
        "is_validated",
        "result of secure boot validation (True or False)"
      ]
    ]
  },
  "talib_secureboot_common_lock": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "TA API - Execute secureboot command to prevents further Secure_Boot commands from executing until the next power/reset cycle or the passing of 50% of the secure boot timer. ",
    "parameters": [
      [
        "device",
        "device context pointer"
      ]
    ]
  },
  "talib_selftest": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint32",
      "ctypes.POINTER(ctypes.c_uint32)"
    ],
    "docstring": "TA API - Executes the SelfTest command, which performs a test of one or more of the cryptographic engines within the chip. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "Mode for self test command "
      ],
      [
        "tests_bitmap",
        "Bit map of tests to be run for self tests "
      ],
      [
        "result_bitmap",
        "Bit map of tests that failed self tests"
      ]
    ]
  },
  "talib_sha_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes SHA command, which computes a SHA-256 digest for general purpose use by the host system. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "SHA command mode Start(0), Update/Compute(1), Finalize(2) or Entire message is in IO buffer(3). "
      ],
      [
        "length",
        "Number of bytes in the input stream "
      ],
      [
        "context_handle",
        "Target handle to write digest or SHA context handle of prior calculation "
      ],
      [
        "message",
        "Data bytes to be hashed "
      ],
      [
        "data_out",
        "Data returned by the command (digest or context). "
      ],
      [
        "data_out_size",
        "As input, the size of the data_out buffer. As output, the number of bytes returned in data_out."
      ]
    ]
  },
  "talib_sha_base_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes SHA command, which computes a SHA-256 digest for general purpose use by the host system. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "SHA command mode Start(0), Update/Compute(1), Finalize(2) or Entire message is in IO buffer(3). "
      ],
      [
        "length",
        "Number of bytes in the input stream "
      ],
      [
        "message",
        "Data bytes to be hashed "
      ],
      [
        "digest",
        "Data returned by the command (digest or context). "
      ],
      [
        "digest_size",
        "As input, the size of the data_out buffer. As output, the number of bytes returned in data_out."
      ]
    ]
  },
  "talib_sha_start": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Executes SHA command to initialize SHA-256 calculation engine. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ]
    ]
  },
  "talib_sha_start_with_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16"
    ],
    "docstring": "Executes SHA command to initialize SHA-256 calculation engine. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "context_handle",
        "SHA context handle of prior calculation"
      ]
    ]
  },
  "talib_sha_update": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes SHA command to add message data to the current context. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "message_length",
        "length of input message for SHA operation "
      ],
      [
        "message",
        "message data to add to SHA operation."
      ]
    ]
  },
  "talib_sha_update_with_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes SHA command to add message data to the current context. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "context_handle",
        "SHA context handle of prior calculation "
      ],
      [
        "message_length",
        "length of input message for SHA operation "
      ],
      [
        "message",
        "message data to add to SHA operation."
      ]
    ]
  },
  "talib_sha_update_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes SHA command to add message data to the current context. (compatibility function) ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "message",
        "message data to add to SHA operation."
      ]
    ]
  },
  "talib_sha_end": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes SHA command to finalize SHA-256 calculation engine. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "digest",
        "Digest is returned here (32 bytes)."
      ]
    ]
  },
  "talib_sha_end_with_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes SHA command to finalize SHA-256 calculation engine. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "context_handle",
        "SHA context handle of prior calculation "
      ],
      [
        "digest",
        "Digest is returned here (32 bytes)."
      ]
    ]
  },
  "talib_sha_end_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes SHA command to finalize SHA-256 calculation engine. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "digest",
        "Digest is returned here (32 bytes). "
      ],
      [
        "length",
        "input message length to update the context "
      ],
      [
        "message",
        "message to compute SHA"
      ]
    ]
  },
  "talib_sha": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char*32"
    ],
    "docstring": "Use the SHA command to compute a SHA-256 digest for given message in input stream. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "length",
        "Size of message parameter in bytes. "
      ],
      [
        "message",
        "Message data to be hashed. "
      ],
      [
        "digest",
        "Digest is returned here (32 bytes)."
      ]
    ]
  },
  "talib_sha_with_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "Use the SHA command to compute a SHA-256 digest for given message in input stream. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "context_handle",
        "Target to write the digest "
      ],
      [
        "length",
        "Size of message parameter in bytes. "
      ],
      [
        "message",
        "Message data to be hashed. "
      ],
      [
        "digest",
        "Digest is returned here (32 bytes)."
      ]
    ]
  },
  "talib_sha_read_context": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": null,
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "context",
        "Context data is returned here. "
      ],
      [
        "context_size",
        "As input, the size of the context buffer in bytes. As output, the size of the returned context data."
      ]
    ]
  },
  "talib_sha_read_context_with_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "Executes Read command to read the SHA-256 context from given input handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "context_handle",
        "SHA context handle of prior calculation "
      ],
      [
        "context",
        "Context data is returned here. "
      ],
      [
        "context_size",
        "As input, the size of the context buffer in bytes. As output, the size of the returned context data."
      ]
    ]
  },
  "talib_sha_write_context": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char_p",
      "ctypes.c_uint16"
    ],
    "docstring": "Executes SHA command to write (restore) a SHA-256 context into the the device SHA context0 handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "context",
        "Context data to be restored. "
      ],
      [
        "context_size",
        "Size of the context data in bytes."
      ]
    ]
  },
  "talib_sha_write_context_with_handle": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16"
    ],
    "docstring": "Executes SHA command to write (restore) a SHA-256 context into the the device in given input handle. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "context_handle",
        "SHA context handle of prior calculation "
      ],
      [
        "context",
        "Context data to be restored. "
      ],
      [
        "context_size",
        "Size of the context data in bytes."
      ]
    ]
  },
  "talib_sign_internal": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes the Sign command for sign internally generated messages using ECDSA or RSA algorithm. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "Mode determines algorithm, key and algorithm options "
      ],
      [
        "priv_handle",
        "Private key handle used to sign the message. "
      ],
      [
        "template_handle",
        "Message template handle... Should be in Shared Data memory "
      ],
      [
        "target_handle",
        "Private key corresponding to Public Key to be included in the message... Should be in Shared Data memory "
      ],
      [
        "signature",
        "Signature is returned here. "
      ],
      [
        "sign_size",
        "As input, the size of the data_out buffer. As output, the number of bytes returned in data_out."
      ]
    ]
  },
  "talib_sign_external": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - Executes the Sign command for sign the external messages using ECDSA or RSA algorithm. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "Mode determines algorithm, key and algorithm options "
      ],
      [
        "priv_handle",
        "Private key handle used to sign the message "
      ],
      [
        "msg_handle",
        "Message handle that contains message to be signed "
      ],
      [
        "message",
        "Message to be signed when msg_handle points to Input buffer Should be 28, 32 or 48 bytes when sent on Input buffer "
      ],
      [
        "message_length",
        "number of bytes in message buffer "
      ],
      [
        "signature",
        "Signature is returned here. "
      ],
      [
        "sign_size",
        "As input, the size of the signature buffer. As output, the number of bytes returned in data_out."
      ]
    ]
  },
  "talib_sign_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char*32",
      "ctypes.c_char*64"
    ],
    "docstring": "Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_id",
        "Slot of the private key to be used to sign the message. "
      ],
      [
        "msg",
        "32-byte message to be signed. Typically the SHA256 hash of the full message. "
      ],
      [
        "signature",
        "Signature will be returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve."
      ]
    ]
  },
  "talib_verify": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "TA API - Executes the Verify command, to Verify a signature using given the message and a public key. The message and public key can either be stored within Vega or passed on the command line. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "Verify command mode options "
      ],
      [
        "msg_handle",
        "Message handle that contains message used for Signature calculation "
      ],
      [
        "pub_handle",
        "Public key Handle to be used to verify signature "
      ],
      [
        "signature",
        "Signature to be verified "
      ],
      [
        "sign_size",
        "Size of the signature passed. Varies based on Key type and Algorithm "
      ],
      [
        "message",
        "If msg_handle is IO buffer, message used for Signature calculation. NULL if message is coming from other than IO buffer "
      ],
      [
        "message_len",
        "input message length "
      ],
      [
        "public_key",
        "If pub_handle is IO buffer, the public key to be used for verification. NULL if Public key is stored internally "
      ],
      [
        "pubkey_len",
        "Size of the public_key passed. Varies based on Key type and Algorithm "
      ],
      [
        "is_verified",
        "if verified true returned here or else false."
      ]
    ]
  },
  "talib_verify_extern_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*32",
      "ctypes.c_char*64",
      "ctypes.c_char*64",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "Executes the Verify command for ECCP256, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "message",
        "32 byte message to be verified. Typically the SHA256 hash of the full message. "
      ],
      [
        "signature",
        "Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. "
      ],
      [
        "public_key",
        "The public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. "
      ],
      [
        "is_verified",
        "Boolean whether or not the message, signature, public key verified."
      ]
    ]
  },
  "talib_verify_stored_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*32",
      "ctypes.c_char*64",
      "ctypes.c_uint16",
      "ctypes.POINTER(ctypes.c_bool)"
    ],
    "docstring": "Executes the Verify command for ECCP256, which verifies a signature (ECDSA verify operation) with a public key stored in the device. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "message",
        "32 byte message to be verified. Typically the SHA256 hash of the full message. "
      ],
      [
        "signature",
        "Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. "
      ],
      [
        "key_id",
        "Handle containing the public key to be used in the verification. "
      ],
      [
        "is_verified",
        "Boolean whether or not the message, signature, public key verified."
      ]
    ]
  },
  "talib_verify_point_exp": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes the Verify command, to expand a point for known X - value and return Y - val. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "y_odd",
        "2 if Y is even or 3 if Y is odd"
      ],
      [
        "x_val",
        "Known X value"
      ],
      [
        "y_val",
        "Y value for corresponding X value returned here"
      ]
    ]
  },
  "talib_write": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes Write command to write an element. This supports both partial and completed writes Restrictions apply based on attributes of the element. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "mode",
        "mode parameter for the write operations "
      ],
      [
        "source_handle",
        "Memory handle to source data from... Must be IO buffer or volatile register "
      ],
      [
        "target_handle",
        "Target handle to write data "
      ],
      [
        "length",
        "Number of bytes to write. Cannot exceed element size "
      ],
      [
        "offset",
        "Offset to the first byte to be written... Valid only for partial writes "
      ],
      [
        "write_data",
        "Data to write if source_handle points to IO buffer "
      ],
      [
        "mac",
        "MAC returned for the transfer function. "
      ]
    ]
  },
  "talib_write_element": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes Write command to write an entire element. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "target_handle",
        "Target handle to write data "
      ],
      [
        "length",
        "Number of bytes to write. Cannot exceed element size Valid only for partial writes "
      ],
      [
        "write_data",
        "Data to write if source_handle points to IO buffer"
      ]
    ]
  },
  "talib_write_partial_element": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes Write command to write a partial element. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "target_handle",
        "Target handle to write data "
      ],
      [
        "length",
        "Number of bytes to write. Cannot exceed element size "
      ],
      [
        "offset",
        "Offset to the first byte to be written... Valid only for partial writes "
      ],
      [
        "write_data",
        "Data to write if source_handle points to IO buffer"
      ]
    ]
  },
  "talib_write_config_zone": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_char*(48)"
    ],
    "docstring": "Executes the Write command, which writes the configuration zone. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "config_data",
        "Data to the config zone data. ."
      ]
    ]
  },
  "talib_write_pubkey_compat": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char*64"
    ],
    "docstring": "Executes the Write command, which writes a public key to a data handle in the device format. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "handle",
        "refer to handle where public key reside "
      ],
      [
        "public_key",
        "Public key to write into the handle specified. X and Y integers in big-endian format. 64 bytes for P256 curve."
      ]
    ]
  },
  "talib_write_zone": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_char_p",
      "ctypes.c_uint8"
    ],
    "docstring": "Executes the Write command in compability mode. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "zone",
        "Unused parameter "
      ],
      [
        "handle",
        "the handle number to write to. "
      ],
      [
        "block",
        "Block number (cryptoauth block size is 32 bytes) "
      ],
      [
        "offset",
        "Byte offset within the \"block\" to write to. "
      ],
      [
        "data",
        "Data to be written. "
      ],
      [
        "length",
        "Number of bytes to be written."
      ]
    ]
  },
  "talib_write_bytes_zone": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint16",
      "ctypes.c_size_t",
      "ctypes.c_char_p",
      "ctypes.c_size_t"
    ],
    "docstring": "Executes the Write command. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "zone",
        "Unused parameter "
      ],
      [
        "handle",
        "the handle number to write to. "
      ],
      [
        "offset_bytes",
        "Byte offset within the handle to write to. "
      ],
      [
        "data",
        "Data to be written. "
      ],
      [
        "length",
        "Number of bytes to be written."
      ]
    ]
  },
  "talib_write_gpio_pin_state": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "Executes write command to write the gpio pin state. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "gpio_handle",
        "refer to gpio handle (gpio1, gpio2, gpio2) "
      ],
      [
        "pin_state",
        "state of the gpio pin"
      ]
    ]
  },
  "talib_write_volatile_shared_transfer": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16"
    ],
    "docstring": "Executes write command to transfer key from vol_reg to shared data. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "source_handle",
        "handle from data will be copied "
      ],
      [
        "target_handle",
        "handle where data will be written"
      ]
    ]
  },
  "talib_write_priv_key": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes Write command to write a private key. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Target handle to write data "
      ],
      [
        "length",
        "Number of bytes to write. Cannot exceed element size Valid only for partial writes "
      ],
      [
        "private_key",
        "private key to write into key_handle mentioned"
      ]
    ]
  },
  "talib_write_pub_key": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_char_p"
    ],
    "docstring": "TA API - Executes Write command to write a public key. ",
    "parameters": [
      [
        "device",
        "Device context pointer "
      ],
      [
        "key_handle",
        "Target handle to write data "
      ],
      [
        "length",
        "The size of the public key. Cannot exceed element size "
      ],
      [
        "public_key",
        "Public key to write into key_handle mentioned"
      ]
    ]
  },
  "talib_handle_init_public_key": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Helper function to create the Handle attributes for Public key. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer to store the 8 byte Handle attributes. "
      ],
      [
        "key_type",
        "The key type for the Handle. "
      ],
      [
        "alg_mode",
        "The algorithm mode for the key_type and is applicable to rsa key only. "
      ],
      [
        "secure_boot_enable",
        "Mode for the Secure boot functions. "
      ],
      [
        "root_key_enable",
        "Mode for the Public key functions. "
      ]
    ]
  },
  "talib_handle_init_private_key": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Helper function to create the Handle attributes for Private key. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer to store the 8 byte Handle attributes. "
      ],
      [
        "key_type",
        "The key type for the Handle. "
      ],
      [
        "alg_mode",
        "The algorithm mode for the key_type and is applicable to rsa key only. "
      ],
      [
        "sign_use",
        "Modes for signature generation. "
      ],
      [
        "key_agreement_use",
        "Modes for Key agreement. "
      ]
    ]
  },
  "talib_handle_init_symmetric_key": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint8",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Helper function to create the Handle attributes for Symmetric key. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer to store the 8 byte Handle attributes. "
      ],
      [
        "key_type",
        "The key type for the Handle. "
      ],
      [
        "sym_usage",
        "Modes for MAC/ENC/KDF operations. "
      ]
    ]
  },
  "talib_handle_init_data": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint16"
    ],
    "docstring": "TA API - Helper function to create the Handle attributes for Symmetric key. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer to store the 8 byte Handle attributes. "
      ],
      [
        "data_size",
        "The size of the data element and the maximum size is 2048. "
      ]
    ]
  },
  "talib_handle_init_extracated_certificate": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Helper function to create the Handle attributes for Extracted Certificates. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer to store the 8 byte Handle attributes. "
      ],
      [
        "key_type",
        "The key type the extracted cert. "
      ],
      [
        "alg_mode",
        "The algorithm mode for the extracted cert and is applicable to rsa key only. "
      ],
      [
        "secure_boot_use",
        "Modes for the Secure boot use. "
      ],
      [
        "intermediate_CA_enable",
        "Mode for the extracted cert use as parent CA or not. "
      ]
    ]
  },
  "talib_handle_init_fast_crypto_key_group": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Helper function to create the Handle attributes for Fast Crypto key group. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer to store the 8 byte Handle attributes. "
      ],
      [
        "key_type",
        "The key type for the handle. Applicable only for symmetric key. "
      ],
      [
        "no_of_keys",
        "No of key space in the handle. "
      ],
      [
        "handles",
        "Mode for single key or for a group of keys space. "
      ]
    ]
  },
  "talib_handle_set_permissions": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint8",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Helper function to create the permission for the handle. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer the handle attributes. "
      ],
      [
        "usage_perm",
        "Usage permissions for the handle. "
      ],
      [
        "write_perm",
        "Write permissions for the handle. "
      ],
      [
        "read_perm",
        "Read permissions for the handle. "
      ],
      [
        "delete_perm",
        "Delete permissions for the handle.. "
      ]
    ]
  },
  "talib_handle_set_usage_permission": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Helper function to create the permission for the handle. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer the handle attributes. "
      ],
      [
        "usage_perm",
        "Usage permissions for the handle. "
      ]
    ]
  },
  "talib_handle_set_write_permission": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Helper function to create the permission for the handle. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer the handle attributes. "
      ],
      [
        "write_perm",
        "Usage permissions for the handle. "
      ]
    ]
  },
  "talib_handle_set_read_permission": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Helper function to create the permission for the handle. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer the handle attributes. "
      ],
      [
        "read_perm",
        "Usage permissions for the handle. "
      ]
    ]
  },
  "talib_handle_set_delete_permission": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.POINTER(ta_element_attributes_t)",
      "ctypes.c_uint8"
    ],
    "docstring": "TA API - Helper function to create the permission for the handle. This function will not create the handle and it is only a helper function for Create command. ",
    "parameters": [
      [
        "element_attributes",
        "Pointer the handle attributes. "
      ],
      [
        "delete_perm",
        "Usage permissions for the handle. "
      ]
    ]
  },
  "talib_sequence_base": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_uint8",
      "ctypes.c_uint32",
      "ctypes.c_char_p",
      "ctypes.c_uint16",
      "ctypes.c_char_p",
      "ctypes.POINTER(ctypes.c_uint16)"
    ],
    "docstring": "TA API - To pass data from host to TA100 or TA100 to host for sequence calculation. ",
    "parameters": [
      [
        "device",
        "Device object that holds the device related informations "
      ],
      [
        "mode",
        "Mode value for sequence operation "
      ],
      [
        "param",
        "TA100 parameter for sequence command "
      ],
      [
        "data_in",
        "Input data for the sequence command "
      ],
      [
        "data_in_length",
        "Input data length "
      ],
      [
        "data_out",
        "Output data buffer where sequence command output is copied "
      ],
      [
        "data_out_length",
        "As input, the size of the data_out buffer and as output the size of the data."
      ]
    ]
  },
  "talib_sharekey_sequence_init": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p",
      "ctypes.c_void_p",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_uint16",
      "ctypes.c_bool",
      "ctypes.c_void_p"
    ],
    "docstring": "TA API - To initialize share key sequence context with given input parameters. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations "
      ],
      [
        "target_handle",
        "Handle where shared secret to be created "
      ],
      [
        "ephe_handle",
        "Handle where local ephemeral to be created "
      ],
      [
        "sign_handle",
        "Signing handle to create singature to be send to remote "
      ],
      [
        "cert_handle",
        "Handle where remote certificate is extracted "
      ],
      [
        "symm_key_size",
        "Share key size to be created "
      ],
      [
        "is_local_first",
        "It is Set, if local nonce and public key to be used in first for TBS message "
      ],
      [
        "sharekey_cb",
        "Call back function used to share IO buffers between application and CAL"
      ]
    ]
  },
  "talib_sequence_sharekey_step1": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Share Key - Step 1: Random. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sequence_sharekey_step2": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Share Key - Step 2: Remote Nonce. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sequence_sharekey_step3": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Share Key - Step 3: Create Target Handle. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sequence_sharekey_step4": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Share Key - Step 4: Create Ephemeral Key Handle. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sequence_sharekey_step5": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Share Key - Step 5: Key Gen Ephemeral Private Key. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sequence_sharekey_step6": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Share Key - Step 6: Receive Remote Ephemeral Public Key. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sequence_sharekey_step7": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Share Key - Step 7: Sign. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sequence_sharekey_step8": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Share Key - Step 8: Verify Remote Signature. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sequence_sharekey_step9": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Share Key - Step 9: Ephemeral ECDH. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sequence_sharekey_step10": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "Share Key - Step 10: KDF (HMAC-counter) ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sharekey_sequence_execute": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "TA API - To execute share key sequence steps. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  },
  "talib_sharekey_sequence_terminate": {
    "restype": "ctypes.c_uint8",
    "argtypes": [
      "ctypes.c_void_p"
    ],
    "docstring": "TA API - To terminate the share key sequence steps. ",
    "parameters": [
      [
        "ctx",
        "Share key sequence object that holds the share key related informations"
      ]
    ]
  }
}

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CryptoAuthLib: Basic Crypto API methods for CryptoAuth Devices (calib_)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="microchip.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CryptoAuthLib
   &#160;<span id="projectnumber">v3.2.0</span>
   </div>
   <div id="projectbrief">Microchip CryptoAuthentication Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a01588.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Basic Crypto API methods for CryptoAuth Devices (calib_)</div>  </div>
</div><!--header-->
<div class="contents">

<p>These methods provide a simple API to CryptoAuth chips.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01683.html">atca_sha256_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7dc326cdf6fbade0eee6081225a379de"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="a01683.html">atca_sha256_ctx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga7dc326cdf6fbade0eee6081225a379de">atca_sha256_ctx_t</a></td></tr>
<tr class="separator:ga7dc326cdf6fbade0eee6081225a379de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c1f62e502c168be9261d2af921e78ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01588.html#ga7dc326cdf6fbade0eee6081225a379de">atca_sha256_ctx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a></td></tr>
<tr class="separator:ga4c1f62e502c168be9261d2af921e78ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafbc037d57a4cc4fec6a2f291736170cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gafbc037d57a4cc4fec6a2f291736170cb">calib_wakeup</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device)</td></tr>
<tr class="memdesc:gafbc037d57a4cc4fec6a2f291736170cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">basic API methods are all prefixed with atcab_ (CryptoAuthLib Basic) the fundamental premise of the basic API is it is based on a single interface instance and that instance is global, so all basic API commands assume that one global device is the one to operate on.  <a href="a01588.html#gafbc037d57a4cc4fec6a2f291736170cb">More...</a><br /></td></tr>
<tr class="separator:gafbc037d57a4cc4fec6a2f291736170cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59750d83d93368b2944f57bb38bf4d1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga59750d83d93368b2944f57bb38bf4d1f">calib_idle</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device)</td></tr>
<tr class="memdesc:ga59750d83d93368b2944f57bb38bf4d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">idle the CryptoAuth device  <a href="a01588.html#ga59750d83d93368b2944f57bb38bf4d1f">More...</a><br /></td></tr>
<tr class="separator:ga59750d83d93368b2944f57bb38bf4d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad26b70951a0da6d80fb98027faae7a1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gad26b70951a0da6d80fb98027faae7a1f">calib_sleep</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device)</td></tr>
<tr class="memdesc:gad26b70951a0da6d80fb98027faae7a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke sleep on the CryptoAuth device  <a href="a01588.html#gad26b70951a0da6d80fb98027faae7a1f">More...</a><br /></td></tr>
<tr class="separator:gad26b70951a0da6d80fb98027faae7a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2167248c704fb8d6864760c066bec13b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga2167248c704fb8d6864760c066bec13b">_calib_exit</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device)</td></tr>
<tr class="memdesc:ga2167248c704fb8d6864760c066bec13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">common cleanup code which idles the device after any operation  <a href="a01588.html#ga2167248c704fb8d6864760c066bec13b">More...</a><br /></td></tr>
<tr class="separator:ga2167248c704fb8d6864760c066bec13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78cfdfa5c6afa83804fd344eae3f0105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga78cfdfa5c6afa83804fd344eae3f0105">calib_cfg_discover</a> (<a class="el" href="a01619.html">ATCAIfaceCfg</a> cfg_array[], int max)</td></tr>
<tr class="memdesc:ga78cfdfa5c6afa83804fd344eae3f0105"><td class="mdescLeft">&#160;</td><td class="mdescRight">auto discovery of crypto auth devices  <a href="a01588.html#ga78cfdfa5c6afa83804fd344eae3f0105">More...</a><br /></td></tr>
<tr class="separator:ga78cfdfa5c6afa83804fd344eae3f0105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51a67781e9e4618e669db1c999e6ec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gae51a67781e9e4618e669db1c999e6ec2">calib_get_addr</a> (uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint16_t *addr)</td></tr>
<tr class="memdesc:gae51a67781e9e4618e669db1c999e6ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the address given the zone, slot, block, and offset.  <a href="a01588.html#gae51a67781e9e4618e669db1c999e6ec2">More...</a><br /></td></tr>
<tr class="separator:gae51a67781e9e4618e669db1c999e6ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023735b1c0b10e70832d9a957bc99ae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga023735b1c0b10e70832d9a957bc99ae3">calib_get_zone_size</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t zone, uint16_t slot, size_t *size)</td></tr>
<tr class="memdesc:ga023735b1c0b10e70832d9a957bc99ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the specified zone in bytes.  <a href="a01588.html#ga023735b1c0b10e70832d9a957bc99ae3">More...</a><br /></td></tr>
<tr class="separator:ga023735b1c0b10e70832d9a957bc99ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7e1ca9721d60824d7e5acbed5434ec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaf7e1ca9721d60824d7e5acbed5434ec0">calib_aes</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t key_id, const uint8_t *aes_in, uint8_t *aes_out)</td></tr>
<tr class="memdesc:gaf7e1ca9721d60824d7e5acbed5434ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the AES-128 encrypt, decrypt, or GFM calculation.  <a href="a01588.html#gaf7e1ca9721d60824d7e5acbed5434ec0">More...</a><br /></td></tr>
<tr class="separator:gaf7e1ca9721d60824d7e5acbed5434ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3622846e280fb209556193bee08684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gacb3622846e280fb209556193bee08684">calib_aes_encrypt</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, uint8_t key_block, const uint8_t *plaintext, uint8_t *ciphertext)</td></tr>
<tr class="memdesc:gacb3622846e280fb209556193bee08684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 encrypt operation with a key in the device.  <a href="a01588.html#gacb3622846e280fb209556193bee08684">More...</a><br /></td></tr>
<tr class="separator:gacb3622846e280fb209556193bee08684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f02958e2e68c685ccb7286113044be9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga4f02958e2e68c685ccb7286113044be9">calib_aes_decrypt</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, uint8_t key_block, const uint8_t *ciphertext, uint8_t *plaintext)</td></tr>
<tr class="memdesc:ga4f02958e2e68c685ccb7286113044be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an AES-128 decrypt operation with a key in the device.  <a href="a01588.html#ga4f02958e2e68c685ccb7286113044be9">More...</a><br /></td></tr>
<tr class="separator:ga4f02958e2e68c685ccb7286113044be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ab4d859b52e82ed0ebf611cbf51cfc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga0ab4d859b52e82ed0ebf611cbf51cfc1">calib_aes_gfm</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *h, const uint8_t *input, uint8_t *output)</td></tr>
<tr class="memdesc:ga0ab4d859b52e82ed0ebf611cbf51cfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a Galois Field Multiply (GFM) operation.  <a href="a01588.html#ga0ab4d859b52e82ed0ebf611cbf51cfc1">More...</a><br /></td></tr>
<tr class="separator:ga0ab4d859b52e82ed0ebf611cbf51cfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41015825c365d4e7e16655446e0ee4ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga41015825c365d4e7e16655446e0ee4ac">calib_checkmac</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t key_id, const uint8_t *challenge, const uint8_t *response, const uint8_t *other_data)</td></tr>
<tr class="memdesc:ga41015825c365d4e7e16655446e0ee4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a MAC response with input values.  <a href="a01588.html#ga41015825c365d4e7e16655446e0ee4ac">More...</a><br /></td></tr>
<tr class="separator:ga41015825c365d4e7e16655446e0ee4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51c2df6734379b2cc2459b04d2ad4928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga51c2df6734379b2cc2459b04d2ad4928">calib_counter</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:ga51c2df6734379b2cc2459b04d2ad4928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Counter functions.  <a href="a01588.html#ga51c2df6734379b2cc2459b04d2ad4928">More...</a><br /></td></tr>
<tr class="separator:ga51c2df6734379b2cc2459b04d2ad4928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad686b27c12c150be4f499ce3b5821a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gad686b27c12c150be4f499ce3b5821a8c">calib_counter_increment</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:gad686b27c12c150be4f499ce3b5821a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments one of the device's monotonic counters.  <a href="a01588.html#gad686b27c12c150be4f499ce3b5821a8c">More...</a><br /></td></tr>
<tr class="separator:gad686b27c12c150be4f499ce3b5821a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce6735118e98aae3bf5e53004dcb203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga2ce6735118e98aae3bf5e53004dcb203">calib_counter_read</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t counter_id, uint32_t *counter_value)</td></tr>
<tr class="memdesc:ga2ce6735118e98aae3bf5e53004dcb203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read one of the device's monotonic counters.  <a href="a01588.html#ga2ce6735118e98aae3bf5e53004dcb203">More...</a><br /></td></tr>
<tr class="separator:ga2ce6735118e98aae3bf5e53004dcb203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b7a1a8772d52c2eb79e6c25498dd880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga4b7a1a8772d52c2eb79e6c25498dd880">calib_derivekey</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t key_id, const uint8_t *mac)</td></tr>
<tr class="memdesc:ga4b7a1a8772d52c2eb79e6c25498dd880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key.  <a href="a01588.html#ga4b7a1a8772d52c2eb79e6c25498dd880">More...</a><br /></td></tr>
<tr class="separator:ga4b7a1a8772d52c2eb79e6c25498dd880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f93c7e589cd2bd5750de31fcac50c0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga3f93c7e589cd2bd5750de31fcac50c0c">calib_ecdh_base</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t key_id, const uint8_t *public_key, uint8_t *pms, uint8_t *out_nonce)</td></tr>
<tr class="memdesc:ga3f93c7e589cd2bd5750de31fcac50c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base function for generating premaster secret key using ECDH.  <a href="a01588.html#ga3f93c7e589cd2bd5750de31fcac50c0c">More...</a><br /></td></tr>
<tr class="separator:ga3f93c7e589cd2bd5750de31fcac50c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aef47665ce6b1c83b9a00bc605e1d37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga4aef47665ce6b1c83b9a00bc605e1d37">calib_ecdh</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, const uint8_t *public_key, uint8_t *pms)</td></tr>
<tr class="memdesc:ga4aef47665ce6b1c83b9a00bc605e1d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is returned in the clear.  <a href="a01588.html#ga4aef47665ce6b1c83b9a00bc605e1d37">More...</a><br /></td></tr>
<tr class="separator:ga4aef47665ce6b1c83b9a00bc605e1d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaae968030e1e07bc3461fbee74889622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaaae968030e1e07bc3461fbee74889622">calib_ecdh_enc</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, const uint8_t *public_key, uint8_t *pms, const uint8_t *read_key, uint16_t read_key_id, const uint8_t num_in[(20)])</td></tr>
<tr class="separator:gaaae968030e1e07bc3461fbee74889622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad18289d81bc0120dc7fdb15beaedcb24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gad18289d81bc0120dc7fdb15beaedcb24">calib_ecdh_ioenc</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, const uint8_t *public_key, uint8_t *pms, const uint8_t *io_key)</td></tr>
<tr class="memdesc:gad18289d81bc0120dc7fdb15beaedcb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in a slot and the premaster secret is returned encrypted using the IO protection key.  <a href="a01588.html#gad18289d81bc0120dc7fdb15beaedcb24">More...</a><br /></td></tr>
<tr class="separator:gad18289d81bc0120dc7fdb15beaedcb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec19f484a19ed7d9bf5ac4a1a35644f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga5ec19f484a19ed7d9bf5ac4a1a35644f">calib_ecdh_tempkey</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *public_key, uint8_t *pms)</td></tr>
<tr class="memdesc:ga5ec19f484a19ed7d9bf5ac4a1a35644f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in TempKey and the premaster secret is returned in the clear.  <a href="a01588.html#ga5ec19f484a19ed7d9bf5ac4a1a35644f">More...</a><br /></td></tr>
<tr class="separator:ga5ec19f484a19ed7d9bf5ac4a1a35644f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed4b0410333cf93ecc8e665b89f3a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga9ed4b0410333cf93ecc8e665b89f3a03">calib_ecdh_tempkey_ioenc</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *public_key, uint8_t *pms, const uint8_t *io_key)</td></tr>
<tr class="memdesc:ga9ed4b0410333cf93ecc8e665b89f3a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECDH command with a private key in TempKey and the premaster secret is returned encrypted using the IO protection key.  <a href="a01588.html#ga9ed4b0410333cf93ecc8e665b89f3a03">More...</a><br /></td></tr>
<tr class="separator:ga9ed4b0410333cf93ecc8e665b89f3a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574916fbc77d017ee829b262e741b11b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga574916fbc77d017ee829b262e741b11b">calib_gendig</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t zone, uint16_t key_id, const uint8_t *other_data, uint8_t other_data_size)</td></tr>
<tr class="memdesc:ga574916fbc77d017ee829b262e741b11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to.  <a href="a01588.html#ga574916fbc77d017ee829b262e741b11b">More...</a><br /></td></tr>
<tr class="separator:ga574916fbc77d017ee829b262e741b11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d87bd17122bc323bb0e47db8341c6d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga1d87bd17122bc323bb0e47db8341c6d8">calib_genkey_base</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t key_id, const uint8_t *other_data, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga1d87bd17122bc323bb0e47db8341c6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which can generate a private key, compute a public key, nd/or compute a digest of a public key.  <a href="a01588.html#ga1d87bd17122bc323bb0e47db8341c6d8">More...</a><br /></td></tr>
<tr class="separator:ga1d87bd17122bc323bb0e47db8341c6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa08c0fb0fd4de0137bd82c7ed410cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga5fa08c0fb0fd4de0137bd82c7ed410cb">calib_genkey</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga5fa08c0fb0fd4de0137bd82c7ed410cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues GenKey command, which generates a new random private key in slot and returns the public key.  <a href="a01588.html#ga5fa08c0fb0fd4de0137bd82c7ed410cb">More...</a><br /></td></tr>
<tr class="separator:ga5fa08c0fb0fd4de0137bd82c7ed410cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad902a2fe308340751b52ae249a38d688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gad902a2fe308340751b52ae249a38d688">calib_get_pubkey</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, uint8_t *public_key)</td></tr>
<tr class="memdesc:gad902a2fe308340751b52ae249a38d688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses GenKey command to calculate the public key from an existing private key in a slot.  <a href="a01588.html#gad902a2fe308340751b52ae249a38d688">More...</a><br /></td></tr>
<tr class="separator:gad902a2fe308340751b52ae249a38d688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2a3d2083992c399f6da6efee006cfc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaf2a3d2083992c399f6da6efee006cfc8">calib_hmac</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t key_id, uint8_t *digest)</td></tr>
<tr class="memdesc:gaf2a3d2083992c399f6da6efee006cfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a HMAC command, which computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device.  <a href="a01588.html#gaf2a3d2083992c399f6da6efee006cfc8">More...</a><br /></td></tr>
<tr class="separator:gaf2a3d2083992c399f6da6efee006cfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc7aff4f1707fbe0a05cf416955f43b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gabc7aff4f1707fbe0a05cf416955f43b0">calib_info_base</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t param2, uint8_t *out_data)</td></tr>
<tr class="memdesc:gabc7aff4f1707fbe0a05cf416955f43b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues an Info command, which return internal device information and can control GPIO and the persistent latch.  <a href="a01588.html#gabc7aff4f1707fbe0a05cf416955f43b0">More...</a><br /></td></tr>
<tr class="separator:gabc7aff4f1707fbe0a05cf416955f43b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132cfbb5c581c5cc5adf5350d4161966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga132cfbb5c581c5cc5adf5350d4161966">calib_info</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t *revision)</td></tr>
<tr class="memdesc:ga132cfbb5c581c5cc5adf5350d4161966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the device revision (DevRev).  <a href="a01588.html#ga132cfbb5c581c5cc5adf5350d4161966">More...</a><br /></td></tr>
<tr class="separator:ga132cfbb5c581c5cc5adf5350d4161966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab08ad37a48da6aee1448939f9e59d8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gab08ad37a48da6aee1448939f9e59d8db">calib_info_set_latch</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, bool state)</td></tr>
<tr class="memdesc:gab08ad37a48da6aee1448939f9e59d8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to set the persistent latch state for an ATECC608A device.  <a href="a01588.html#gab08ad37a48da6aee1448939f9e59d8db">More...</a><br /></td></tr>
<tr class="separator:gab08ad37a48da6aee1448939f9e59d8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0335f0c23df27d5a4cb51a05bb7fb00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gab0335f0c23df27d5a4cb51a05bb7fb00">calib_info_get_latch</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, bool *state)</td></tr>
<tr class="memdesc:gab0335f0c23df27d5a4cb51a05bb7fb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the Info command to get the persistent latch current state for an ATECC608A device.  <a href="a01588.html#gab0335f0c23df27d5a4cb51a05bb7fb00">More...</a><br /></td></tr>
<tr class="separator:gab0335f0c23df27d5a4cb51a05bb7fb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e89694762b85f8507a3cdaa11fdb415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga3e89694762b85f8507a3cdaa11fdb415">calib_kdf</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t key_id, const uint32_t details, const uint8_t *message, uint8_t *out_data, uint8_t *out_nonce)</td></tr>
<tr class="memdesc:ga3e89694762b85f8507a3cdaa11fdb415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the KDF command, which derives a new key in PRF, AES, or HKDF modes.  <a href="a01588.html#ga3e89694762b85f8507a3cdaa11fdb415">More...</a><br /></td></tr>
<tr class="separator:ga3e89694762b85f8507a3cdaa11fdb415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcd432286630b9b0b05aef743fcf140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaedcd432286630b9b0b05aef743fcf140">calib_lock</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t summary_crc)</td></tr>
<tr class="memdesc:gaedcd432286630b9b0b05aef743fcf140"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked.  <a href="a01588.html#gaedcd432286630b9b0b05aef743fcf140">More...</a><br /></td></tr>
<tr class="separator:gaedcd432286630b9b0b05aef743fcf140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59ce160afe0d695a51f3bb1869f8f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gad59ce160afe0d695a51f3bb1869f8f9f">calib_lock_config_zone</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device)</td></tr>
<tr class="memdesc:gad59ce160afe0d695a51f3bb1869f8f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the config zone.  <a href="a01588.html#gad59ce160afe0d695a51f3bb1869f8f9f">More...</a><br /></td></tr>
<tr class="separator:gad59ce160afe0d695a51f3bb1869f8f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd7f6f6e9a6b5e58fac18416b9cb8e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaedd7f6f6e9a6b5e58fac18416b9cb8e8">calib_lock_config_zone_crc</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t summary_crc)</td></tr>
<tr class="memdesc:gaedd7f6f6e9a6b5e58fac18416b9cb8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the config zone with summary CRC.  <a href="a01588.html#gaedd7f6f6e9a6b5e58fac18416b9cb8e8">More...</a><br /></td></tr>
<tr class="separator:gaedd7f6f6e9a6b5e58fac18416b9cb8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b43d1fe63cc9c5349bd0eacab073f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga8b43d1fe63cc9c5349bd0eacab073f05">calib_lock_data_zone</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device)</td></tr>
<tr class="memdesc:ga8b43d1fe63cc9c5349bd0eacab073f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally (no CRC required) lock the data zone (slots and OTP).  <a href="a01588.html#ga8b43d1fe63cc9c5349bd0eacab073f05">More...</a><br /></td></tr>
<tr class="separator:ga8b43d1fe63cc9c5349bd0eacab073f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f25b26b532c6f2cee224ebfd8d53c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga54f25b26b532c6f2cee224ebfd8d53c5">calib_lock_data_zone_crc</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t summary_crc)</td></tr>
<tr class="memdesc:ga54f25b26b532c6f2cee224ebfd8d53c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the data zone (slots and OTP) with summary CRC.  <a href="a01588.html#ga54f25b26b532c6f2cee224ebfd8d53c5">More...</a><br /></td></tr>
<tr class="separator:ga54f25b26b532c6f2cee224ebfd8d53c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8b5f9e30a712d0740f1a258ff6481d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaf8b5f9e30a712d0740f1a258ff6481d5">calib_lock_data_slot</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t slot)</td></tr>
<tr class="memdesc:gaf8b5f9e30a712d0740f1a258ff6481d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1).  <a href="a01588.html#gaf8b5f9e30a712d0740f1a258ff6481d5">More...</a><br /></td></tr>
<tr class="separator:gaf8b5f9e30a712d0740f1a258ff6481d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98ccfd6545cf40218259ace032f11d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gae98ccfd6545cf40218259ace032f11d1">calib_mac</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t key_id, const uint8_t *challenge, uint8_t *digest)</td></tr>
<tr class="memdesc:gae98ccfd6545cf40218259ace032f11d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes MAC command, which computes a SHA-256 digest of a key stored in the device, a challenge, and other information on the device.  <a href="a01588.html#gae98ccfd6545cf40218259ace032f11d1">More...</a><br /></td></tr>
<tr class="separator:gae98ccfd6545cf40218259ace032f11d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e63b42b9f17b12d9296ac019f9dfd10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga0e63b42b9f17b12d9296ac019f9dfd10">calib_nonce_base</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t zero, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga0e63b42b9f17b12d9296ac019f9dfd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Nonce command, which loads a random or fixed nonce/data into the device for use by subsequent commands.  <a href="a01588.html#ga0e63b42b9f17b12d9296ac019f9dfd10">More...</a><br /></td></tr>
<tr class="separator:ga0e63b42b9f17b12d9296ac019f9dfd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e9ba79d8d9d65263d8dd7d5df6fd53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gad4e9ba79d8d9d65263d8dd7d5df6fd53">calib_nonce</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *num_in)</td></tr>
<tr class="memdesc:gad4e9ba79d8d9d65263d8dd7d5df6fd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to initialize TempKey to a specified value.  <a href="a01588.html#gad4e9ba79d8d9d65263d8dd7d5df6fd53">More...</a><br /></td></tr>
<tr class="separator:gad4e9ba79d8d9d65263d8dd7d5df6fd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec82eed30721cfed86d8c33ad8e9385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga2ec82eed30721cfed86d8c33ad8e9385">calib_nonce_load</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t target, const uint8_t *num_in, uint16_t num_in_size)</td></tr>
<tr class="memdesc:ga2ec82eed30721cfed86d8c33ad8e9385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to load one of the device's internal buffers with a fixed value.  <a href="a01588.html#ga2ec82eed30721cfed86d8c33ad8e9385">More...</a><br /></td></tr>
<tr class="separator:ga2ec82eed30721cfed86d8c33ad8e9385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cc318c2497c9781c42df7a9c54fe234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga9cc318c2497c9781c42df7a9c54fe234">calib_nonce_rand</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga9cc318c2497c9781c42df7a9c54fe234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number.  <a href="a01588.html#ga9cc318c2497c9781c42df7a9c54fe234">More...</a><br /></td></tr>
<tr class="separator:ga9cc318c2497c9781c42df7a9c54fe234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527688ba64f8a45663b920ff3333bf06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga527688ba64f8a45663b920ff3333bf06">calib_challenge</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *num_in)</td></tr>
<tr class="memdesc:ga527688ba64f8a45663b920ff3333bf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command in pass-through mode to initialize TempKey to a specified value.  <a href="a01588.html#ga527688ba64f8a45663b920ff3333bf06">More...</a><br /></td></tr>
<tr class="separator:ga527688ba64f8a45663b920ff3333bf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3599eb3352da9d7dc527e5ff9935bd49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga3599eb3352da9d7dc527e5ff9935bd49">calib_challenge_seed_update</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *num_in, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga3599eb3352da9d7dc527e5ff9935bd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a Nonce command to generate a random challenge combining a host nonce (num_in) and a device random number.  <a href="a01588.html#ga3599eb3352da9d7dc527e5ff9935bd49">More...</a><br /></td></tr>
<tr class="separator:ga3599eb3352da9d7dc527e5ff9935bd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3cf86f7cf633f06e6ae3d919c34c6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaff3cf86f7cf633f06e6ae3d919c34c6b">calib_priv_write</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, const uint8_t priv_key[36], uint16_t write_key_id, const uint8_t write_key[32], const uint8_t num_in[(20)])</td></tr>
<tr class="separator:gaff3cf86f7cf633f06e6ae3d919c34c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e669a3df1795896af15dcff989b0f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga56e669a3df1795896af15dcff989b0f6">calib_random</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t *rand_out)</td></tr>
<tr class="memdesc:ga56e669a3df1795896af15dcff989b0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Random command, which generates a 32 byte random number from the CryptoAuth device.  <a href="a01588.html#ga56e669a3df1795896af15dcff989b0f6">More...</a><br /></td></tr>
<tr class="separator:ga56e669a3df1795896af15dcff989b0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08bb5c72c5f100144a7ccb8dba18dc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gae08bb5c72c5f100144a7ccb8dba18dc7">calib_read_zone</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:gae08bb5c72c5f100144a7ccb8dba18dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads either 4 or 32 bytes of data from a given slot, configuration zone, or the OTP zone.  <a href="a01588.html#gae08bb5c72c5f100144a7ccb8dba18dc7">More...</a><br /></td></tr>
<tr class="separator:gae08bb5c72c5f100144a7ccb8dba18dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d3cce5a7f1edfb8386c92d63d3cb5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga53d3cce5a7f1edfb8386c92d63d3cb5c">calib_is_locked</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t zone, bool *is_locked)</td></tr>
<tr class="memdesc:ga53d3cce5a7f1edfb8386c92d63d3cb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the configuration zone to see if the specified zone is locked.  <a href="a01588.html#ga53d3cce5a7f1edfb8386c92d63d3cb5c">More...</a><br /></td></tr>
<tr class="separator:ga53d3cce5a7f1edfb8386c92d63d3cb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd40a59b7398ab8a963aa5869a00eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gadfd40a59b7398ab8a963aa5869a00eab">calib_is_slot_locked</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t slot, bool *is_locked)</td></tr>
<tr class="memdesc:gadfd40a59b7398ab8a963aa5869a00eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the configuration zone to see if the specified slot is locked.  <a href="a01588.html#gadfd40a59b7398ab8a963aa5869a00eab">More...</a><br /></td></tr>
<tr class="separator:gadfd40a59b7398ab8a963aa5869a00eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24aaf479dedf2c21cc7af270186805ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga24aaf479dedf2c21cc7af270186805ae">calib_read_bytes_zone</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t zone, uint16_t slot, size_t offset, uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:ga24aaf479dedf2c21cc7af270186805ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to read an arbitrary number of bytes from any zone configured for clear reads.  <a href="a01588.html#ga24aaf479dedf2c21cc7af270186805ae">More...</a><br /></td></tr>
<tr class="separator:ga24aaf479dedf2c21cc7af270186805ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3247f37c13984694c621c88e0e3840ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga3247f37c13984694c621c88e0e3840ea">calib_read_serial_number</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t *serial_number)</td></tr>
<tr class="memdesc:ga3247f37c13984694c621c88e0e3840ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command, which reads the 9 byte serial number of the device from the config zone.  <a href="a01588.html#ga3247f37c13984694c621c88e0e3840ea">More...</a><br /></td></tr>
<tr class="separator:ga3247f37c13984694c621c88e0e3840ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e069fd857436bd88e0441ef4bcf4557"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga5e069fd857436bd88e0441ef4bcf4557">calib_read_pubkey</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t slot, uint8_t *public_key)</td></tr>
<tr class="memdesc:ga5e069fd857436bd88e0441ef4bcf4557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read an ECC P256 public key from a slot configured for clear reads.  <a href="a01588.html#ga5e069fd857436bd88e0441ef4bcf4557">More...</a><br /></td></tr>
<tr class="separator:ga5e069fd857436bd88e0441ef4bcf4557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06f8426afbc3eca5b00e6f42d197492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaf06f8426afbc3eca5b00e6f42d197492">calib_read_sig</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t slot, uint8_t *sig)</td></tr>
<tr class="memdesc:gaf06f8426afbc3eca5b00e6f42d197492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read a 64 byte ECDSA P256 signature from a slot configured for clear reads.  <a href="a01588.html#gaf06f8426afbc3eca5b00e6f42d197492">More...</a><br /></td></tr>
<tr class="separator:gaf06f8426afbc3eca5b00e6f42d197492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab555925b22a0490252778600c91cb67d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gab555925b22a0490252778600c91cb67d">calib_read_config_zone</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t *config_data)</td></tr>
<tr class="memdesc:gab555925b22a0490252778600c91cb67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Read command to read the complete device configuration zone.  <a href="a01588.html#gab555925b22a0490252778600c91cb67d">More...</a><br /></td></tr>
<tr class="separator:gab555925b22a0490252778600c91cb67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5ea7eb264a8518d62174000c9cbef19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gab5ea7eb264a8518d62174000c9cbef19">calib_cmp_config_zone</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t *config_data, bool *same_config)</td></tr>
<tr class="memdesc:gab5ea7eb264a8518d62174000c9cbef19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a specified configuration zone with the configuration zone currently on the device.  <a href="a01588.html#gab5ea7eb264a8518d62174000c9cbef19">More...</a><br /></td></tr>
<tr class="separator:gab5ea7eb264a8518d62174000c9cbef19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92e95cf611c8a255a56fdf88b011535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gad92e95cf611c8a255a56fdf88b011535">calib_read_enc</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, uint8_t block, uint8_t *data, const uint8_t *enc_key, const uint16_t enc_key_id, const uint8_t num_in[(20)])</td></tr>
<tr class="separator:gad92e95cf611c8a255a56fdf88b011535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ff79334f1b8e877c0e3bbb31d87f43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga85ff79334f1b8e877c0e3bbb31d87f43">calib_secureboot</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t param2, const uint8_t *digest, const uint8_t *signature, uint8_t *mac)</td></tr>
<tr class="memdesc:ga85ff79334f1b8e877c0e3bbb31d87f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Secure Boot command, which provides support for secure boot of an external MCU or MPU.  <a href="a01588.html#ga85ff79334f1b8e877c0e3bbb31d87f43">More...</a><br /></td></tr>
<tr class="separator:ga85ff79334f1b8e877c0e3bbb31d87f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c79b36f050621e8df14f9804a990162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga0c79b36f050621e8df14f9804a990162">calib_secureboot_mac</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, const uint8_t *digest, const uint8_t *signature, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga0c79b36f050621e8df14f9804a990162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Secure Boot command with encrypted digest and validated MAC response using the IO protection key.  <a href="a01588.html#ga0c79b36f050621e8df14f9804a990162">More...</a><br /></td></tr>
<tr class="separator:ga0c79b36f050621e8df14f9804a990162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6999f25a78a2a6313cbb3328394e29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga1b6999f25a78a2a6313cbb3328394e29">calib_selftest</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t param2, uint8_t *result)</td></tr>
<tr class="memdesc:ga1b6999f25a78a2a6313cbb3328394e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the SelfTest command, which performs a test of one or more of the cryptographic engines within the ATECC608A chip.  <a href="a01588.html#ga1b6999f25a78a2a6313cbb3328394e29">More...</a><br /></td></tr>
<tr class="separator:ga1b6999f25a78a2a6313cbb3328394e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dba7f8f64110f7e08f4e924246f12ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga0dba7f8f64110f7e08f4e924246f12ea">calib_sha_base</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t length, const uint8_t *data_in, uint8_t *data_out, uint16_t *data_out_size)</td></tr>
<tr class="memdesc:ga0dba7f8f64110f7e08f4e924246f12ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command, which computes a SHA-256 or HMAC/SHA-256 digest for general purpose use by the host system.  <a href="a01588.html#ga0dba7f8f64110f7e08f4e924246f12ea">More...</a><br /></td></tr>
<tr class="separator:ga0dba7f8f64110f7e08f4e924246f12ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d5cc0ddb695bf9c4d23e90e0d3d296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga39d5cc0ddb695bf9c4d23e90e0d3d296">calib_sha_start</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device)</td></tr>
<tr class="memdesc:ga39d5cc0ddb695bf9c4d23e90e0d3d296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to initialize SHA-256 calculation engine.  <a href="a01588.html#ga39d5cc0ddb695bf9c4d23e90e0d3d296">More...</a><br /></td></tr>
<tr class="separator:ga39d5cc0ddb695bf9c4d23e90e0d3d296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c2814ae00b7e6ef4bf8b1830d4eabc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga7c2814ae00b7e6ef4bf8b1830d4eabc5">calib_sha_update</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *message)</td></tr>
<tr class="memdesc:ga7c2814ae00b7e6ef4bf8b1830d4eabc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to add 64 bytes of message data to the current context.  <a href="a01588.html#ga7c2814ae00b7e6ef4bf8b1830d4eabc5">More...</a><br /></td></tr>
<tr class="separator:ga7c2814ae00b7e6ef4bf8b1830d4eabc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55670a11ebdb67c97e37e76a26bac65c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga55670a11ebdb67c97e37e76a26bac65c">calib_sha_end</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t *digest, uint16_t length, const uint8_t *message)</td></tr>
<tr class="memdesc:ga55670a11ebdb67c97e37e76a26bac65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to complete SHA-256 or HMAC/SHA-256 operation.  <a href="a01588.html#ga55670a11ebdb67c97e37e76a26bac65c">More...</a><br /></td></tr>
<tr class="separator:ga55670a11ebdb67c97e37e76a26bac65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga386101050bd2c033457a179971c72c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga386101050bd2c033457a179971c72c3d">calib_sha_read_context</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t *context, uint16_t *context_size)</td></tr>
<tr class="memdesc:ga386101050bd2c033457a179971c72c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to read the SHA-256 context back. Only for ATECC608A with SHA-256 contexts. HMAC not supported.  <a href="a01588.html#ga386101050bd2c033457a179971c72c3d">More...</a><br /></td></tr>
<tr class="separator:ga386101050bd2c033457a179971c72c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04ea40bc761db46291571e31d0dc050b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga04ea40bc761db46291571e31d0dc050b">calib_sha_write_context</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *context, uint16_t context_size)</td></tr>
<tr class="memdesc:ga04ea40bc761db46291571e31d0dc050b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to write (restore) a SHA-256 context into the the device. Only supported for ATECC608A with SHA-256 contexts.  <a href="a01588.html#ga04ea40bc761db46291571e31d0dc050b">More...</a><br /></td></tr>
<tr class="separator:ga04ea40bc761db46291571e31d0dc050b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76470faf5d311b715ccdacba7548e2f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga76470faf5d311b715ccdacba7548e2f5">calib_sha</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t length, const uint8_t *message, uint8_t *digest)</td></tr>
<tr class="memdesc:ga76470faf5d311b715ccdacba7548e2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute a SHA-256 digest.  <a href="a01588.html#ga76470faf5d311b715ccdacba7548e2f5">More...</a><br /></td></tr>
<tr class="separator:ga76470faf5d311b715ccdacba7548e2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac65d56a4ea11f345e76309ca1432b0c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gac65d56a4ea11f345e76309ca1432b0c1">calib_hw_sha2_256</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *data, size_t data_size, uint8_t *digest)</td></tr>
<tr class="memdesc:gac65d56a4ea11f345e76309ca1432b0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute a SHA-256 digest.  <a href="a01588.html#gac65d56a4ea11f345e76309ca1432b0c1">More...</a><br /></td></tr>
<tr class="separator:gac65d56a4ea11f345e76309ca1432b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d38b103472bd99e6f2d5bc85b8d509d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga2d38b103472bd99e6f2d5bc85b8d509d">calib_hw_sha2_256_init</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, <a class="el" href="a01588.html#ga7dc326cdf6fbade0eee6081225a379de">atca_sha256_ctx_t</a> *ctx)</td></tr>
<tr class="memdesc:ga2d38b103472bd99e6f2d5bc85b8d509d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a SHA context for performing a hardware SHA-256 operation on a device. Note that only one SHA operation can be run at a time.  <a href="a01588.html#ga2d38b103472bd99e6f2d5bc85b8d509d">More...</a><br /></td></tr>
<tr class="separator:ga2d38b103472bd99e6f2d5bc85b8d509d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31246b38ff9c3824ac2dbb968ae1fa27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga31246b38ff9c3824ac2dbb968ae1fa27">calib_hw_sha2_256_update</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, <a class="el" href="a01588.html#ga7dc326cdf6fbade0eee6081225a379de">atca_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:ga31246b38ff9c3824ac2dbb968ae1fa27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add message data to a SHA context for performing a hardware SHA-256 operation on a device.  <a href="a01588.html#ga31246b38ff9c3824ac2dbb968ae1fa27">More...</a><br /></td></tr>
<tr class="separator:ga31246b38ff9c3824ac2dbb968ae1fa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc02fd5631101eef76422779feb417b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga0bc02fd5631101eef76422779feb417b">calib_hw_sha2_256_finish</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, <a class="el" href="a01588.html#ga7dc326cdf6fbade0eee6081225a379de">atca_sha256_ctx_t</a> *ctx, uint8_t *digest)</td></tr>
<tr class="memdesc:ga0bc02fd5631101eef76422779feb417b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish SHA-256 digest for a SHA context for performing a hardware SHA-256 operation on a device.  <a href="a01588.html#ga0bc02fd5631101eef76422779feb417b">More...</a><br /></td></tr>
<tr class="separator:ga0bc02fd5631101eef76422779feb417b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f2d006812bec40ac0ef5b02498bec6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga7f2d006812bec40ac0ef5b02498bec6e">calib_sha_hmac_init</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, <a class="el" href="a01588.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *ctx, uint16_t key_slot)</td></tr>
<tr class="memdesc:ga7f2d006812bec40ac0ef5b02498bec6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to start an HMAC/SHA-256 operation.  <a href="a01588.html#ga7f2d006812bec40ac0ef5b02498bec6e">More...</a><br /></td></tr>
<tr class="separator:ga7f2d006812bec40ac0ef5b02498bec6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f2fa75050c0a6cd944d37a7d63ed618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga8f2fa75050c0a6cd944d37a7d63ed618">calib_sha_hmac_update</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, <a class="el" href="a01588.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *ctx, const uint8_t *data, size_t data_size)</td></tr>
<tr class="memdesc:ga8f2fa75050c0a6cd944d37a7d63ed618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to add an arbitrary amount of message data to a HMAC/SHA-256 operation.  <a href="a01588.html#ga8f2fa75050c0a6cd944d37a7d63ed618">More...</a><br /></td></tr>
<tr class="separator:ga8f2fa75050c0a6cd944d37a7d63ed618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadfd6a9da548fa63d6c69b9fe4839b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gadadfd6a9da548fa63d6c69b9fe4839b8">calib_sha_hmac_finish</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, <a class="el" href="a01588.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *ctx, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:gadadfd6a9da548fa63d6c69b9fe4839b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes SHA command to complete a HMAC/SHA-256 operation.  <a href="a01588.html#gadadfd6a9da548fa63d6c69b9fe4839b8">More...</a><br /></td></tr>
<tr class="separator:gadadfd6a9da548fa63d6c69b9fe4839b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e8094a3c5cebae7cdd2467ea0309df3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga6e8094a3c5cebae7cdd2467ea0309df3">calib_sha_hmac</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *data, size_t data_size, uint16_t key_slot, uint8_t *digest, uint8_t target)</td></tr>
<tr class="memdesc:ga6e8094a3c5cebae7cdd2467ea0309df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SHA command to compute an HMAC/SHA-256 operation.  <a href="a01588.html#ga6e8094a3c5cebae7cdd2467ea0309df3">More...</a><br /></td></tr>
<tr class="separator:ga6e8094a3c5cebae7cdd2467ea0309df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae453fe5f7e7fd31573ca0c21e61cd918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gae453fe5f7e7fd31573ca0c21e61cd918">calib_sign_base</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t key_id, uint8_t *signature)</td></tr>
<tr class="memdesc:gae453fe5f7e7fd31573ca0c21e61cd918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Sign command, which generates a signature using the ECDSA algorithm.  <a href="a01588.html#gae453fe5f7e7fd31573ca0c21e61cd918">More...</a><br /></td></tr>
<tr class="separator:gae453fe5f7e7fd31573ca0c21e61cd918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15d3f1059e6d1dc17382c29c84130873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga15d3f1059e6d1dc17382c29c84130873">calib_sign</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, const uint8_t *msg, uint8_t *signature)</td></tr>
<tr class="memdesc:ga15d3f1059e6d1dc17382c29c84130873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices.  <a href="a01588.html#ga15d3f1059e6d1dc17382c29c84130873">More...</a><br /></td></tr>
<tr class="separator:ga15d3f1059e6d1dc17382c29c84130873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74bbc8f13821ea025aecbf8fc6248f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaf74bbc8f13821ea025aecbf8fc6248f2">calib_sign_internal</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, bool is_invalidate, bool is_full_sn, uint8_t *signature)</td></tr>
<tr class="memdesc:gaf74bbc8f13821ea025aecbf8fc6248f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Sign command to sign an internally generated message.  <a href="a01588.html#gaf74bbc8f13821ea025aecbf8fc6248f2">More...</a><br /></td></tr>
<tr class="separator:gaf74bbc8f13821ea025aecbf8fc6248f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga261fac023e6833d7d042b07f499b622d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga261fac023e6833d7d042b07f499b622d">calib_updateextra</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t new_value)</td></tr>
<tr class="memdesc:ga261fac023e6833d7d042b07f499b622d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes UpdateExtra command to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85).  <a href="a01588.html#ga261fac023e6833d7d042b07f499b622d">More...</a><br /></td></tr>
<tr class="separator:ga261fac023e6833d7d042b07f499b622d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7339d13bf06e7a5d8abd50ed7654b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gae7339d13bf06e7a5d8abd50ed7654b87">calib_verify</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t mode, uint16_t key_id, const uint8_t *signature, const uint8_t *public_key, const uint8_t *other_data, uint8_t *mac)</td></tr>
<tr class="memdesc:gae7339d13bf06e7a5d8abd50ed7654b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command.  <a href="a01588.html#gae7339d13bf06e7a5d8abd50ed7654b87">More...</a><br /></td></tr>
<tr class="separator:gae7339d13bf06e7a5d8abd50ed7654b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7a48cb662f6229e864764a4fc16b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gabb7a48cb662f6229e864764a4fc16b2f">calib_verify_extern</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, bool *is_verified)</td></tr>
<tr class="memdesc:gabb7a48cb662f6229e864764a4fc16b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices.  <a href="a01588.html#gabb7a48cb662f6229e864764a4fc16b2f">More...</a><br /></td></tr>
<tr class="separator:gabb7a48cb662f6229e864764a4fc16b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d9e4b8decddca603fa6a0f00130714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaa0d9e4b8decddca603fa6a0f00130714">calib_verify_extern_mac</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *message, const uint8_t *signature, const uint8_t *public_key, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:gaa0d9e4b8decddca603fa6a0f00130714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. This function is only available on the ATECC608A.  <a href="a01588.html#gaa0d9e4b8decddca603fa6a0f00130714">More...</a><br /></td></tr>
<tr class="separator:gaa0d9e4b8decddca603fa6a0f00130714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c18378e7e634aef3f7cd5124b172f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga7c18378e7e634aef3f7cd5124b172f1e">calib_verify_stored</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *message, const uint8_t *signature, uint16_t key_id, bool *is_verified)</td></tr>
<tr class="memdesc:ga7c18378e7e634aef3f7cd5124b172f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices.  <a href="a01588.html#ga7c18378e7e634aef3f7cd5124b172f1e">More...</a><br /></td></tr>
<tr class="separator:ga7c18378e7e634aef3f7cd5124b172f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93620b7a951daa744e1c47dff7af2f5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga93620b7a951daa744e1c47dff7af2f5a">calib_verify_stored_mac</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *message, const uint8_t *signature, uint16_t key_id, const uint8_t *num_in, const uint8_t *io_key, bool *is_verified)</td></tr>
<tr class="memdesc:ga93620b7a951daa744e1c47dff7af2f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with a public key stored in the device. This function is only available on the ATECC608A.  <a href="a01588.html#ga93620b7a951daa744e1c47dff7af2f5a">More...</a><br /></td></tr>
<tr class="separator:ga93620b7a951daa744e1c47dff7af2f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e0e60a885d0a4910d273d2b820f74ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga0e0e60a885d0a4910d273d2b820f74ce">calib_verify_validate</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:ga0e0e60a885d0a4910d273d2b820f74ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command in Validate mode to validate a public key stored in a slot.  <a href="a01588.html#ga0e0e60a885d0a4910d273d2b820f74ce">More...</a><br /></td></tr>
<tr class="separator:ga0e0e60a885d0a4910d273d2b820f74ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c78ae47cda2f9d3ad0f24b7e3695c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gab2c78ae47cda2f9d3ad0f24b7e3695c5">calib_verify_invalidate</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, const uint8_t *signature, const uint8_t *other_data, bool *is_verified)</td></tr>
<tr class="memdesc:gab2c78ae47cda2f9d3ad0f24b7e3695c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Verify command in Invalidate mode which invalidates a previously validated public key stored in a slot.  <a href="a01588.html#gab2c78ae47cda2f9d3ad0f24b7e3695c5">More...</a><br /></td></tr>
<tr class="separator:gab2c78ae47cda2f9d3ad0f24b7e3695c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4791634e3df2b2a2746fec15b3c036cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga4791634e3df2b2a2746fec15b3c036cb">calib_write</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t zone, uint16_t address, const uint8_t *value, const uint8_t *mac)</td></tr>
<tr class="memdesc:ga4791634e3df2b2a2746fec15b3c036cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either one four byte word or a 32-byte block to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys.  <a href="a01588.html#ga4791634e3df2b2a2746fec15b3c036cb">More...</a><br /></td></tr>
<tr class="separator:ga4791634e3df2b2a2746fec15b3c036cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5046bb4ec9b6f7747b70ae9fb8a5922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gac5046bb4ec9b6f7747b70ae9fb8a5922">calib_write_zone</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t zone, uint16_t slot, uint8_t block, uint8_t offset, const uint8_t *data, uint8_t len)</td></tr>
<tr class="memdesc:gac5046bb4ec9b6f7747b70ae9fb8a5922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes either 4 or 32 bytes of data into a device zone.  <a href="a01588.html#gac5046bb4ec9b6f7747b70ae9fb8a5922">More...</a><br /></td></tr>
<tr class="separator:gac5046bb4ec9b6f7747b70ae9fb8a5922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39bfa045068f0a9d2badf844862df2f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga39bfa045068f0a9d2badf844862df2f2">calib_write_bytes_zone</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint8_t zone, uint16_t slot, size_t offset_bytes, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:ga39bfa045068f0a9d2badf844862df2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes data into the configuration, otp, or data zones with a given byte offset and length. Offset and length must be multiples of a word (4 bytes).  <a href="a01588.html#ga39bfa045068f0a9d2badf844862df2f2">More...</a><br /></td></tr>
<tr class="separator:ga39bfa045068f0a9d2badf844862df2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4408e08f86cd3bd48868ffaa0e966b09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga4408e08f86cd3bd48868ffaa0e966b09">calib_write_pubkey</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t slot, const uint8_t *public_key)</td></tr>
<tr class="memdesc:ga4408e08f86cd3bd48868ffaa0e966b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the write command to write a public key to a slot in the proper format.  <a href="a01588.html#ga4408e08f86cd3bd48868ffaa0e966b09">More...</a><br /></td></tr>
<tr class="separator:ga4408e08f86cd3bd48868ffaa0e966b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81f049d53107034808416e8f09e927f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga81f049d53107034808416e8f09e927f3">calib_write_config_zone</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, const uint8_t *config_data)</td></tr>
<tr class="memdesc:ga81f049d53107034808416e8f09e927f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Write command, which writes the configuration zone.  <a href="a01588.html#ga81f049d53107034808416e8f09e927f3">More...</a><br /></td></tr>
<tr class="separator:ga81f049d53107034808416e8f09e927f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fc342d4ebd76c4affd7abc7a1cac2aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#ga8fc342d4ebd76c4affd7abc7a1cac2aa">calib_write_enc</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t key_id, uint8_t block, const uint8_t *data, const uint8_t *enc_key, const uint16_t enc_key_id, const uint8_t num_in[(20)])</td></tr>
<tr class="separator:ga8fc342d4ebd76c4affd7abc7a1cac2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5238e0fac86dcb164f3c79d42e97976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaa5238e0fac86dcb164f3c79d42e97976">calib_write_config_counter</a> (<a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a> device, uint16_t counter_id, uint32_t counter_value)</td></tr>
<tr class="memdesc:gaa5238e0fac86dcb164f3c79d42e97976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize one of the monotonic counters in device with a specific value.  <a href="a01588.html#gaa5238e0fac86dcb164f3c79d42e97976">More...</a><br /></td></tr>
<tr class="separator:gaa5238e0fac86dcb164f3c79d42e97976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5990c6c2a55759960d25a1f8ad1973d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01588.html#gaa5990c6c2a55759960d25a1f8ad1973d">atca_basic_aes_gcm_version</a> = &quot;2.0&quot;</td></tr>
<tr class="separator:gaa5990c6c2a55759960d25a1f8ad1973d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These methods provide a simple API to CryptoAuth chips. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4c1f62e502c168be9261d2af921e78ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c1f62e502c168be9261d2af921e78ba">&#9670;&nbsp;</a></span>atca_hmac_sha256_ctx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01588.html#ga7dc326cdf6fbade0eee6081225a379de">atca_sha256_ctx_t</a> <a class="el" href="a01588.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7dc326cdf6fbade0eee6081225a379de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dc326cdf6fbade0eee6081225a379de">&#9670;&nbsp;</a></span>atca_sha256_ctx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="a01683.html">atca_sha256_ctx</a> <a class="el" href="a01588.html#ga7dc326cdf6fbade0eee6081225a379de">atca_sha256_ctx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2167248c704fb8d6864760c066bec13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2167248c704fb8d6864760c066bec13b">&#9670;&nbsp;</a></span>_calib_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> _calib_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>common cleanup code which idles the device after any operation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf7e1ca9721d60824d7e5acbed5434ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7e1ca9721d60824d7e5acbed5434ec0">&#9670;&nbsp;</a></span>calib_aes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_aes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>aes_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aes_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the AES-128 encrypt, decrypt, or GFM calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode for the AES command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aes_in</td><td>Input data to the AES command (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aes_out</td><td>Output data from the AES command is returned here (16 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4f02958e2e68c685ccb7286113044be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f02958e2e68c685ccb7286113044be9">&#9670;&nbsp;</a></span>calib_aes_decrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_aes_decrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an AES-128 decrypt operation with a key in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ciphertext</td><td>Input ciphertext to be decrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plaintext</td><td>Output plaintext is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gacb3622846e280fb209556193bee08684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb3622846e280fb209556193bee08684">&#9670;&nbsp;</a></span>calib_aes_encrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_aes_encrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>key_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>plaintext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ciphertext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an AES-128 encrypt operation with a key in the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location. Can either be a slot number or ATCA_TEMPKEY_KEYID for TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_block</td><td>Index of the 16-byte block to use within the key location for the actual key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plaintext</td><td>Input plaintext to be encrypted (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ciphertext</td><td>Output ciphertext is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0ab4d859b52e82ed0ebf611cbf51cfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ab4d859b52e82ed0ebf611cbf51cfc1">&#9670;&nbsp;</a></span>calib_aes_gfm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_aes_gfm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a Galois Field Multiply (GFM) operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>First input value (16 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Second input value (16 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>GFM result is returned here (16 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga78cfdfa5c6afa83804fd344eae3f0105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78cfdfa5c6afa83804fd344eae3f0105">&#9670;&nbsp;</a></span>calib_cfg_discover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_cfg_discover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01619.html">ATCAIfaceCfg</a>&#160;</td>
          <td class="paramname"><em>cfg_array</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_ifaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>auto discovery of crypto auth devices </p>
<p>Calls interface discovery functions and fills in cfg_array up to the maximum number of configurations either found or the size of the array. The cfg_array can have a mixture of interface types (ie: some I2C, some SWI or UART) depending upon which interfaces you've enabled</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cfg_array</td><td>ptr to an array of interface configs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_ifaces</td><td>maximum size of cfg_array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga527688ba64f8a45663b920ff3333bf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga527688ba64f8a45663b920ff3333bf06">&#9670;&nbsp;</a></span>calib_challenge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_challenge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command in pass-through mode to initialize TempKey to a specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Data to be loaded into TempKey (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga3599eb3352da9d7dc527e5ff9935bd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3599eb3352da9d7dc527e5ff9935bd49">&#9670;&nbsp;</a></span>calib_challenge_seed_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_challenge_seed_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command to generate a random challenge combining a host nonce (num_in) and a device random number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Host nonce to be combined with the device random number (20 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>Internally generated 32-byte random number that was used in the nonce/challenge calculation is returned here. Can be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga41015825c365d4e7e16655446e0ee4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41015825c365d4e7e16655446e0ee4ac">&#9670;&nbsp;</a></span>calib_checkmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_checkmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>challenge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a MAC response with input values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key location in the CryptoAuth device to use for the MAC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">challenge</td><td>Challenge data (32 bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">response</td><td>MAC response data (32 bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>OtherData parameter (13 bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab5ea7eb264a8518d62174000c9cbef19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5ea7eb264a8518d62174000c9cbef19">&#9670;&nbsp;</a></span>calib_cmp_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_cmp_config_zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>same_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares a specified configuration zone with the configuration zone currently on the device. </p>
<p>This only compares the static portions of the configuration zone and skips those that are unique per device (first 16 bytes) and areas that can change after the configuration zone has been locked (e.g. LastKeyUse).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config_data</td><td>Full configuration data to compare the device against. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">same_config</td><td>Result is returned here. True if the static portions on the configuration zones are the same.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>
<p>Max for all configs</p>

</div>
</div>
<a id="ga51c2df6734379b2cc2459b04d2ad4928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51c2df6734379b2cc2459b04d2ad4928">&#9670;&nbsp;</a></span>calib_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_counter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Counter functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>the mode used for the counter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>The counter to be used </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_value</td><td>pointer to the counter value returned from device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad686b27c12c150be4f499ce3b5821a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad686b27c12c150be4f499ce3b5821a8c">&#9670;&nbsp;</a></span>calib_counter_increment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_counter_increment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments one of the device's monotonic counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>Counter to be incremented </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_value</td><td>New value of the counter is returned here. Can be NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2ce6735118e98aae3bf5e53004dcb203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce6735118e98aae3bf5e53004dcb203">&#9670;&nbsp;</a></span>calib_counter_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_counter_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read one of the device's monotonic counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>Counter to be read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter_value</td><td>Counter value is returned here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4b7a1a8772d52c2eb79e6c25498dd880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b7a1a8772d52c2eb79e6c25498dd880">&#9670;&nbsp;</a></span>calib_derivekey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_derivekey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>target_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the DeviveKey command for deriving a new key from a nonce (TempKey) and an existing key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Bit 2 must match the value in TempKey.SourceFlag </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_key</td><td>Key slot to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>Optional 32 byte MAC used to validate operation. NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4aef47665ce6b1c83b9a00bc605e1d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aef47665ce6b1c83b9a00bc605e1d37">&#9670;&nbsp;</a></span>calib_ecdh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_ecdh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in a slot and the premaster secret is returned in the clear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here. 32 bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success </dd></dl>

</div>
</div>
<a id="ga3f93c7e589cd2bd5750de31fcac50c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f93c7e589cd2bd5750de31fcac50c0c">&#9670;&nbsp;</a></span>calib_ecdh_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_ecdh_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_nonce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base function for generating premaster secret key using ECDH. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode to be used for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH pre-master secret is returned here (32 bytes) if returned directly. Otherwise NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_nonce</td><td>Nonce used to encrypt pre-master secret. NULL if output encryption not used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaaae968030e1e07bc3461fbee74889622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaae968030e1e07bc3461fbee74889622">&#9670;&nbsp;</a></span>calib_ecdh_enc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_ecdh_enc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>read_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>read_key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>num_in</em>[(20)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad18289d81bc0120dc7fdb15beaedcb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad18289d81bc0120dc7fdb15beaedcb24">&#9670;&nbsp;</a></span>calib_ecdh_ioenc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_ecdh_ioenc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in a slot and the premaster secret is returned encrypted using the IO protection key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of key for ECDH computation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga5ec19f484a19ed7d9bf5ac4a1a35644f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ec19f484a19ed7d9bf5ac4a1a35644f">&#9670;&nbsp;</a></span>calib_ecdh_tempkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_ecdh_tempkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in TempKey and the premaster secret is returned in the clear. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga9ed4b0410333cf93ecc8e665b89f3a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed4b0410333cf93ecc8e665b89f3a03">&#9670;&nbsp;</a></span>calib_ecdh_tempkey_ioenc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_ecdh_tempkey_ioenc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECDH command with a private key in TempKey and the premaster secret is returned encrypted using the IO protection key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key input to ECDH calculation. X and Y integers in big-endian format. 64 bytes for P256 key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pms</td><td>Computed ECDH premaster secret is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga574916fbc77d017ee829b262e741b11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga574916fbc77d017ee829b262e741b11b">&#9670;&nbsp;</a></span>calib_gendig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_gendig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>other_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a GenDig command, which performs a SHA256 hash on the source data indicated by zone with the contents of TempKey. See the CryptoAuth datasheet for your chip to see what the values of zone correspond to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Designates the source of the data to hash with TempKey. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Indicates the key, OTP block, or message order for shared nonce mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>Four bytes of data for SHA calculation when using a NoMac key, 32 bytes for "Shared Nonce" mode, otherwise ignored (can be NULL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data_size</td><td>Size of other_data in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga5fa08c0fb0fd4de0137bd82c7ed410cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fa08c0fb0fd4de0137bd82c7ed410cb">&#9670;&nbsp;</a></span>calib_genkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_genkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues GenKey command, which generates a new random private key in slot and returns the public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot number where an ECC private key is configured. Can also be ATCA_TEMPKEY_KEYID to generate a private key in TempKey. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga1d87bd17122bc323bb0e47db8341c6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d87bd17122bc323bb0e47db8341c6d8">&#9670;&nbsp;</a></span>calib_genkey_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_genkey_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues GenKey command, which can generate a private key, compute a public key, nd/or compute a digest of a public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the GenKey command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot to perform the GenKey command on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>OtherData for PubKey digest calculation. Can be set to NULL otherwise. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>If the mode indicates a public key will be calculated, it will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae51a67781e9e4618e669db1c999e6ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae51a67781e9e4618e669db1c999e6ec2">&#9670;&nbsp;</a></span>calib_get_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_get_addr </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the address given the zone, slot, block, and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to get address from. Config(0), OTP(1), or Data(2) which requires a slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot Id number for data zone and zero for other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Block number within the data or configuration or OTP zone . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset Number within the block of data or configuration or OTP zone. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>Pointer to the address of data or configuration or OTP zone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad902a2fe308340751b52ae249a38d688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad902a2fe308340751b52ae249a38d688">&#9670;&nbsp;</a></span>calib_get_pubkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_get_pubkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses GenKey command to calculate the public key from an existing private key in a slot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot number of the private key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key will be returned here. Format will be the X and Y integers in big-endian format. 64 bytes for P256 curve. Set to NULL if public key isn't required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga023735b1c0b10e70832d9a957bc99ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga023735b1c0b10e70832d9a957bc99ae3">&#9670;&nbsp;</a></span>calib_get_zone_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_get_zone_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the specified zone in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to get size information from. Config(0), OTP(1), or Data(2) which requires a slot. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If zone is Data(2), the slot to query for size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Zone size is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf2a3d2083992c399f6da6efee006cfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2a3d2083992c399f6da6efee006cfc8">&#9670;&nbsp;</a></span>calib_hmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_hmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues a HMAC command, which computes an HMAC/SHA-256 digest of a key stored in the device, a challenge, and other information on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Which key is to be used to generate the response. Bits 0:3 only are used to select a slot but all 16 bits are used in the HMAC message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>HMAC digest is returned in this buffer (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gac65d56a4ea11f345e76309ca1432b0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac65d56a4ea11f345e76309ca1432b0c1">&#9670;&nbsp;</a></span>calib_hw_sha2_256()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_hw_sha2_256 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the SHA command to compute a SHA-256 digest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0bc02fd5631101eef76422779feb417b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bc02fd5631101eef76422779feb417b">&#9670;&nbsp;</a></span>calib_hw_sha2_256_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_hw_sha2_256_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01588.html#ga7dc326cdf6fbade0eee6081225a379de">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish SHA-256 digest for a SHA context for performing a hardware SHA-256 operation on a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>SHA256 context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>SHA256 digest is returned here (32 bytes)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2d38b103472bd99e6f2d5bc85b8d509d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d38b103472bd99e6f2d5bc85b8d509d">&#9670;&nbsp;</a></span>calib_hw_sha2_256_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_hw_sha2_256_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01588.html#ga7dc326cdf6fbade0eee6081225a379de">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a SHA context for performing a hardware SHA-256 operation on a device. Note that only one SHA operation can be run at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>SHA256 context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga31246b38ff9c3824ac2dbb968ae1fa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31246b38ff9c3824ac2dbb968ae1fa27">&#9670;&nbsp;</a></span>calib_hw_sha2_256_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_hw_sha2_256_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01588.html#ga7dc326cdf6fbade0eee6081225a379de">atca_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add message data to a SHA context for performing a hardware SHA-256 operation on a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>SHA256 context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to be added to hash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga59750d83d93368b2944f57bb38bf4d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59750d83d93368b2944f57bb38bf4d1f">&#9670;&nbsp;</a></span>calib_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_idle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>idle the CryptoAuth device </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga132cfbb5c581c5cc5adf5350d4161966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga132cfbb5c581c5cc5adf5350d4161966">&#9670;&nbsp;</a></span>calib_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>revision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to get the device revision (DevRev). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">revision</td><td>Device revision is returned here (4 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gabc7aff4f1707fbe0a05cf416955f43b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc7aff4f1707fbe0a05cf416955f43b0">&#9670;&nbsp;</a></span>calib_info_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_info_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Issues an Info command, which return internal device information and can control GPIO and the persistent latch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Selects which mode to be used for info command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2</td><td>Selects the particular fields for the mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_data</td><td>Response from info command (4 bytes). Can be set to NULL if not required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab0335f0c23df27d5a4cb51a05bb7fb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0335f0c23df27d5a4cb51a05bb7fb00">&#9670;&nbsp;</a></span>calib_info_get_latch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_info_get_latch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to get the persistent latch current state for an ATECC608A device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>The state is returned here. Set (true) or Cler (false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab08ad37a48da6aee1448939f9e59d8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab08ad37a48da6aee1448939f9e59d8db">&#9670;&nbsp;</a></span>calib_info_set_latch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_info_set_latch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the Info command to set the persistent latch state for an ATECC608A device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">state</td><td>Persistent latch state. Set (true) or clear (false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga53d3cce5a7f1edfb8386c92d63d3cb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53d3cce5a7f1edfb8386c92d63d3cb5c">&#9670;&nbsp;</a></span>calib_is_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_is_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command, which reads the configuration zone to see if the specified zone is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>The zone to query for locked (use LOCK_ZONE_CONFIG or LOCK_ZONE_DATA). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gadfd40a59b7398ab8a963aa5869a00eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd40a59b7398ab8a963aa5869a00eab">&#9670;&nbsp;</a></span>calib_is_slot_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_is_slot_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command, which reads the configuration zone to see if the specified slot is locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot to query for locked (slot 0-15) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_locked</td><td>Lock state returned here. True if locked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga3e89694762b85f8507a3cdaa11fdb415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e89694762b85f8507a3cdaa11fdb415">&#9670;&nbsp;</a></span>calib_kdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_kdf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>details</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_nonce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the KDF command, which derives a new key in PRF, AES, or HKDF modes. </p>
<p>Generally this function combines a source key with an input string and creates a result key/digest/array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines KDF algorithm (PRF,AES,HKDF), source key location, and target key locations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Source and target key slots if locations are in the EEPROM. Source key slot is the LSB and target key slot is the MSB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">details</td><td>Further information about the computation, depending on the algorithm (4 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Input value from system (up to 128 bytes). Actual size of message is 16 bytes for AES algorithm or is encoded in the MSB of the details parameter for other algorithms. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_data</td><td>Output of the KDF function is returned here. If the result remains in the device, this can be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_nonce</td><td>If the output is encrypted, a 32 byte random nonce generated by the device is returned here. If output encryption is not used, this can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaedcd432286630b9b0b05aef743fcf140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedcd432286630b9b0b05aef743fcf140">&#9670;&nbsp;</a></span>calib_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>summary_crc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Lock command prevents future modifications of the Configuration and/or Data and OTP zones. If the device is so configured, then this command can be used to lock individual data slots. This command fails if the designated area is already locked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Zone, and/or slot, and summary check (bit 7). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">summary_crc</td><td>CRC of the config or data zones. Ignored for slot locks or when mode bit 7 is set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad59ce160afe0d695a51f3bb1869f8f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad59ce160afe0d695a51f3bb1869f8f9f">&#9670;&nbsp;</a></span>calib_lock_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_lock_config_zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally (no CRC required) lock the config zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaedd7f6f6e9a6b5e58fac18416b9cb8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedd7f6f6e9a6b5e58fac18416b9cb8e8">&#9670;&nbsp;</a></span>calib_lock_config_zone_crc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_lock_config_zone_crc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>summary_crc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the config zone with summary CRC. </p>
<p>The CRC is calculated over the entire config zone contents. 88 bytes for ATSHA devices, 128 bytes for ATECC devices. Lock will fail if the provided CRC doesn't match the internally calculated one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">summary_crc</td><td>Expected CRC over the config zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf8b5f9e30a712d0740f1a258ff6481d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8b5f9e30a712d0740f1a258ff6481d5">&#9670;&nbsp;</a></span>calib_lock_data_slot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_lock_data_slot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock an individual slot in the data zone on an ATECC device. Not available for ATSHA devices. Slot must be configured to be slot lockable (KeyConfig.Lockable=1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot to be locked in data zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga8b43d1fe63cc9c5349bd0eacab073f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b43d1fe63cc9c5349bd0eacab073f05">&#9670;&nbsp;</a></span>calib_lock_data_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_lock_data_zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unconditionally (no CRC required) lock the data zone (slots and OTP). </p>
<p>ConfigZone must be locked and DataZone must be unlocked for the zone to be successfully locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga54f25b26b532c6f2cee224ebfd8d53c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54f25b26b532c6f2cee224ebfd8d53c5">&#9670;&nbsp;</a></span>calib_lock_data_zone_crc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_lock_data_zone_crc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>summary_crc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the data zone (slots and OTP) with summary CRC. </p>
<p>The CRC is calculated over the concatenated contents of all the slots and OTP at the end. Private keys (KeyConfig.Private=1) are skipped. Lock will fail if the provided CRC doesn't match the internally calculated one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">summary_crc</td><td>Expected CRC over the data zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae98ccfd6545cf40218259ace032f11d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae98ccfd6545cf40218259ace032f11d1">&#9670;&nbsp;</a></span>calib_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>challenge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes MAC command, which computes a SHA-256 digest of a key stored in the device, a challenge, and other information on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls which fields within the device are used in the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Key in the CryptoAuth device to use for the MAC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">challenge</td><td>Challenge message (32 bytes). May be NULL if mode indicates a challenge isn't required. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>MAC response is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad4e9ba79d8d9d65263d8dd7d5df6fd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e9ba79d8d9d65263d8dd7d5df6fd53">&#9670;&nbsp;</a></span>calib_nonce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_nonce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command in pass-through mode to initialize TempKey to a specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Data to be loaded into TempKey (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0e63b42b9f17b12d9296ac019f9dfd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e63b42b9f17b12d9296ac019f9dfd10">&#9670;&nbsp;</a></span>calib_nonce_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_nonce_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Nonce command, which loads a random or fixed nonce/data into the device for use by subsequent commands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Controls the mechanism of the internal RNG or fixed write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero</td><td>Param2, normally 0, but can be used to indicate a nonce calculation mode (bit 15). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Input value to either be included in the nonce calculation in random modes (20 bytes) or to be written directly (32 bytes or 64 bytes(ATECC608A)) in pass-through mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>If using a random mode, the internally generated 32-byte random number that was used in the nonce calculation is returned here. Can be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga2ec82eed30721cfed86d8c33ad8e9385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ec82eed30721cfed86d8c33ad8e9385">&#9670;&nbsp;</a></span>calib_nonce_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_nonce_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_in_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command in pass-through mode to load one of the device's internal buffers with a fixed value. </p>
<p>For the ATECC608A, available targets are TempKey (32 or 64 bytes), Message Digest Buffer (32 or 64 bytes), or the Alternate Key Buffer (32 bytes). For all other devices, only TempKey (32 bytes) is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Target device buffer to load. Can be NONCE_MODE_TARGET_TEMPKEY, NONCE_MODE_TARGET_MSGDIGBUF, or NONCE_MODE_TARGET_ALTKEYBUF. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Data to load into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in_size</td><td>Size of num_in in bytes. Can be 32 or 64 bytes depending on device and target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga9cc318c2497c9781c42df7a9c54fe234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cc318c2497c9781c42df7a9c54fe234">&#9670;&nbsp;</a></span>calib_nonce_rand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_nonce_rand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a Nonce command to generate a random nonce combining a host nonce (num_in) and a device random number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Host nonce to be combined with the device random number (20 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>Internally generated 32-byte random number that was used in the nonce/challenge calculation is returned here. Can be NULL if not needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaff3cf86f7cf633f06e6ae3d919c34c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff3cf86f7cf633f06e6ae3d919c34c6b">&#9670;&nbsp;</a></span>calib_priv_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_priv_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>priv_key</em>[36], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>write_key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>write_key</em>[32], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>num_in</em>[(20)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga56e669a3df1795896af15dcff989b0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56e669a3df1795896af15dcff989b0f6">&#9670;&nbsp;</a></span>calib_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rand_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Random command, which generates a 32 byte random number from the CryptoAuth device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rand_out</td><td>32 bytes of random data is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga24aaf479dedf2c21cc7af270186805ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24aaf479dedf2c21cc7af270186805ae">&#9670;&nbsp;</a></span>calib_read_bytes_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_read_bytes_zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to read an arbitrary number of bytes from any zone configured for clear reads. </p>
<p>This function will issue the Read command as many times as is required to read the requested data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to read data from. Option are <a class="el" href="a00386.html#add3796a1d4de55604283aef5a70f7945">ATCA_ZONE_CONFIG(0)</a>, <a class="el" href="a00386.html#a547efc6fa3cb0501b2e53f80023dff7e">ATCA_ZONE_OTP(1)</a>, or <a class="el" href="a00386.html#a4c65b241280290fae9fd4faa9d7a292b">ATCA_ZONE_DATA(2)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from if zone is <a class="el" href="a00386.html#a4c65b241280290fae9fd4faa9d7a292b">ATCA_ZONE_DATA(2)</a>. Ignored for all other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Byte offset within the zone to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Read data is returned here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to read starting from the offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gab555925b22a0490252778600c91cb67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab555925b22a0490252778600c91cb67d">&#9670;&nbsp;</a></span>calib_read_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_read_config_zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read the complete device configuration zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">config_data</td><td>Configuration zone data is returned here. 88 bytes for ATSHA devices, 128 bytes for ATECC devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad92e95cf611c8a255a56fdf88b011535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad92e95cf611c8a255a56fdf88b011535">&#9670;&nbsp;</a></span>calib_read_enc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_read_enc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>enc_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>enc_key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>num_in</em>[(20)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5e069fd857436bd88e0441ef4bcf4557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e069fd857436bd88e0441ef4bcf4557">&#9670;&nbsp;</a></span>calib_read_pubkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_read_pubkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read an ECC P256 public key from a slot configured for clear reads. </p>
<p>This function assumes the public key is stored using the ECC public key format specified in the datasheet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from. Only slots 8 to 15 are large enough for a public key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">public_key</td><td>Public key is returned here (64 bytes). Format will be the 32 byte X and Y big-endian integers concatenated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga3247f37c13984694c621c88e0e3840ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3247f37c13984694c621c88e0e3840ea">&#9670;&nbsp;</a></span>calib_read_serial_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_read_serial_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>serial_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command, which reads the 9 byte serial number of the device from the config zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serial_number</td><td>9 byte serial number is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf06f8426afbc3eca5b00e6f42d197492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf06f8426afbc3eca5b00e6f42d197492">&#9670;&nbsp;</a></span>calib_read_sig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_read_sig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command to read a 64 byte ECDSA P256 signature from a slot configured for clear reads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to read from. Only slots 8 to 15 are large enough for a signature. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sig</td><td>Signature will be returned here (64 bytes). Format will be the 32 byte R and S big-endian integers concatenated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae08bb5c72c5f100144a7ccb8dba18dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae08bb5c72c5f100144a7ccb8dba18dc7">&#9670;&nbsp;</a></span>calib_read_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_read_zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Read command, which reads either 4 or 32 bytes of data from a given slot, configuration zone, or the OTP zone. </p>
<p>When reading a slot or OTP, data zone must be locked and the slot configuration must not be secret for a slot to be successfully read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to be read from device. Options are ATCA_ZONE_CONFIG, ATCA_ZONE_OTP, or ATCA_ZONE_DATA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number for data zone and ignored for other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>32 byte block index within the zone. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>4 byte work index within the block. Ignored for 32 byte reads. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Read data is returned here. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data to be read. Must be either 4 or 32.</td></tr>
  </table>
  </dd>
</dl>
<p>returns ATCA_SUCCESS on success, otherwise an error code. </p>

</div>
</div>
<a id="ga85ff79334f1b8e877c0e3bbb31d87f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85ff79334f1b8e877c0e3bbb31d87f43">&#9670;&nbsp;</a></span>calib_secureboot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_secureboot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Secure Boot command, which provides support for secure boot of an external MCU or MPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the SecureBoot command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2</td><td>Not used, must be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">digest</td><td>Digest of the code to be verified (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature of the code to be verified (64 bytes). Can be NULL when using the FullStore mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac</td><td>Validating MAC will be returned here (32 bytes). Can be NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0c79b36f050621e8df14f9804a990162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c79b36f050621e8df14f9804a990162">&#9670;&nbsp;</a></span>calib_secureboot_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_secureboot_mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Secure Boot command with encrypted digest and validated MAC response using the IO protection key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the SecureBoot command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">digest</td><td>Digest of the code to be verified (32 bytes). This is the plaintext digest (not encrypted). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature of the code to be verified (64 bytes). Can be NULL when using the FullStore mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>Host nonce (20 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key (32 bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Verify result is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga1b6999f25a78a2a6313cbb3328394e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b6999f25a78a2a6313cbb3328394e29">&#9670;&nbsp;</a></span>calib_selftest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_selftest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>param2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the SelfTest command, which performs a test of one or more of the cryptographic engines within the ATECC608A chip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Functions to test. Can be a bit field combining any of the following: SELFTEST_MODE_RNG, SELFTEST_MODE_ECDSA_VERIFY, SELFTEST_MODE_ECDSA_SIGN, SELFTEST_MODE_ECDH, SELFTEST_MODE_AES, SELFTEST_MODE_SHA, SELFTEST_MODE_ALL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2</td><td>Currently unused, should be 0. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Results are returned here as a bit field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga76470faf5d311b715ccdacba7548e2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76470faf5d311b715ccdacba7548e2f5">&#9670;&nbsp;</a></span>calib_sha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the SHA command to compute a SHA-256 digest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Size of message parameter in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message data to be hashed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest is returned here (32 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga0dba7f8f64110f7e08f4e924246f12ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dba7f8f64110f7e08f4e924246f12ea">&#9670;&nbsp;</a></span>calib_sha_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>data_out_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command, which computes a SHA-256 or HMAC/SHA-256 digest for general purpose use by the host system. </p>
<p>Only the Start(0) and Compute(1) modes are available for ATSHA devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>SHA command mode Start(0), Update/Compute(1), End(2), Public(3), HMACstart(4), HMACend(5), Read_Context(6), or Write_Context(7). Also message digest target location for the ATECC608A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes in the message parameter or KeySlot for the HMAC key if Mode is HMACstart(4) or Public(3). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message bytes to be hashed or Write_Context if restoring a context on the ATECC608A. Can be NULL if not required by the mode. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data_out</td><td>Data returned by the command (digest or context). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data_out_size</td><td>As input, the size of the data_out buffer. As output, the number of bytes returned in data_out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga55670a11ebdb67c97e37e76a26bac65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55670a11ebdb67c97e37e76a26bac65c">&#9670;&nbsp;</a></span>calib_sha_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to complete SHA-256 or HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest from SHA-256 or HMAC/SHA-256 will be returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of any remaining data to include in hash. Max 64 bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Remaining data to include in hash. NULL if length is 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga6e8094a3c5cebae7cdd2467ea0309df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e8094a3c5cebae7cdd2467ea0309df3">&#9670;&nbsp;</a></span>calib_sha_hmac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha_hmac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the SHA command to compute an HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to be hashed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_slot</td><td>Slot key id to use for the HMAC calculation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>Digest is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Where to save the digest internal to the device. For ATECC608A, can be SHA_MODE_TARGET_TEMPKEY, SHA_MODE_TARGET_MSGDIGBUF, or SHA_MODE_TARGET_OUT_ONLY. For all other devices, SHA_MODE_TARGET_TEMPKEY is the only option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gadadfd6a9da548fa63d6c69b9fe4839b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadadfd6a9da548fa63d6c69b9fe4839b8">&#9670;&nbsp;</a></span>calib_sha_hmac_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha_hmac_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01588.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to complete a HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>HMAC/SHA-256 context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">digest</td><td>HMAC/SHA-256 result is returned here (32 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>Where to save the digest internal to the device. For ATECC608A, can be SHA_MODE_TARGET_TEMPKEY, SHA_MODE_TARGET_MSGDIGBUF, or SHA_MODE_TARGET_OUT_ONLY. For all other devices, SHA_MODE_TARGET_TEMPKEY is the only option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga7f2d006812bec40ac0ef5b02498bec6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f2d006812bec40ac0ef5b02498bec6e">&#9670;&nbsp;</a></span>calib_sha_hmac_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha_hmac_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01588.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to start an HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>HMAC/SHA-256 context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_slot</td><td>Slot key id to use for the HMAC calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga8f2fa75050c0a6cd944d37a7d63ed618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f2fa75050c0a6cd944d37a7d63ed618">&#9670;&nbsp;</a></span>calib_sha_hmac_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha_hmac_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01588.html#ga4c1f62e502c168be9261d2af921e78ba">atca_hmac_sha256_ctx_t</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to add an arbitrary amount of message data to a HMAC/SHA-256 operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>HMAC/SHA-256 context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Message data to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Size of message data in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga386101050bd2c033457a179971c72c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga386101050bd2c033457a179971c72c3d">&#9670;&nbsp;</a></span>calib_sha_read_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha_read_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>context_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to read the SHA-256 context back. Only for ATECC608A with SHA-256 contexts. HMAC not supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">context</td><td>Context data is returned here. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">context_size</td><td>As input, the size of the context buffer in bytes. As output, the size of the returned context data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga39d5cc0ddb695bf9c4d23e90e0d3d296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d5cc0ddb695bf9c4d23e90e0d3d296">&#9670;&nbsp;</a></span>calib_sha_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to initialize SHA-256 calculation engine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga7c2814ae00b7e6ef4bf8b1830d4eabc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c2814ae00b7e6ef4bf8b1830d4eabc5">&#9670;&nbsp;</a></span>calib_sha_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to add 64 bytes of message data to the current context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>64 bytes of message data to add to add to operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga04ea40bc761db46291571e31d0dc050b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04ea40bc761db46291571e31d0dc050b">&#9670;&nbsp;</a></span>calib_sha_write_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sha_write_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>context_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes SHA command to write (restore) a SHA-256 context into the the device. Only supported for ATECC608A with SHA-256 contexts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Context data to be restored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context_size</td><td>Size of the context data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga15d3f1059e6d1dc17382c29c84130873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15d3f1059e6d1dc17382c29c84130873">&#9670;&nbsp;</a></span>calib_sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Sign command, to sign a 32-byte external message using the private key in the specified slot. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of the private key to be used to sign the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>32-byte message to be signed. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature will be returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae453fe5f7e7fd31573ca0c21e61cd918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae453fe5f7e7fd31573ca0c21e61cd918">&#9670;&nbsp;</a></span>calib_sign_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sign_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Sign command, which generates a signature using the ECDSA algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what the source of the message to be signed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Private key slot used to sign the message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature is returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaf74bbc8f13821ea025aecbf8fc6248f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf74bbc8f13821ea025aecbf8fc6248f2">&#9670;&nbsp;</a></span>calib_sign_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sign_internal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_invalidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_full_sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Sign command to sign an internally generated message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot of the private key to be used to sign the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_invalidate</td><td>Set to true if the signature will be used with the Verify(Invalidate) command. false for all other cases. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_full_sn</td><td>Set to true if the message should incorporate the device's full serial number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Signature is returned here. Format is R and S integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gad26b70951a0da6d80fb98027faae7a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad26b70951a0da6d80fb98027faae7a1f">&#9670;&nbsp;</a></span>calib_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>invoke sleep on the CryptoAuth device </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga261fac023e6833d7d042b07f499b622d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga261fac023e6833d7d042b07f499b622d">&#9670;&nbsp;</a></span>calib_updateextra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_updateextra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes UpdateExtra command to update the values of the two extra bytes within the Configuration zone (bytes 84 and 85). </p>
<p>Can also be used to decrement the limited use counter associated with the key in slot NewValue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Mode determines what operations the UpdateExtra command performs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_value</td><td>Value to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gae7339d13bf06e7a5d8abd50ed7654b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7339d13bf06e7a5d8abd50ed7654b87">&#9670;&nbsp;</a></span>calib_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which takes an ECDSA [R,S] signature and verifies that it is correctly generated from a given message and public key. In all cases, the signature is an input to the command. </p>
<p>For the Stored, External, and ValidateExternal Modes, the contents of TempKey (or Message Digest Buffer in some cases for the ATECC608A) should contain the 32 byte message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Verify command mode and options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Stored mode, the slot containing the public key to be used for the verification. ValidateExternal mode, the slot containing the public key to be validated. External mode, KeyID contains the curve type to be used to Verify the signature. Validate or Invalidate mode, the slot containing the public key to be (in)validated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>If mode is External, the public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. NULL for all other modes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>If mode is Validate, the bytes used to generate the message for the validation (19 bytes). NULL for all other modes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac</td><td>If mode indicates a validating MAC, then the MAC will will be returned here. Can be NULL otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gabb7a48cb662f6229e864764a4fc16b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb7a48cb662f6229e864764a4fc16b2f">&#9670;&nbsp;</a></span>calib_verify_extern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_verify_extern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gaa0d9e4b8decddca603fa6a0f00130714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d9e4b8decddca603fa6a0f00130714">&#9670;&nbsp;</a></span>calib_verify_extern_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_verify_extern_mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with all components (message, signature, and public key) supplied. This function is only available on the ATECC608A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>The public key to be used for verification. X and Y integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>System nonce (32 byte) used for the verification MAC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key for verifying the validation MAC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gab2c78ae47cda2f9d3ad0f24b7e3695c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2c78ae47cda2f9d3ad0f24b7e3695c5">&#9670;&nbsp;</a></span>calib_verify_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_verify_invalidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command in Invalidate mode which invalidates a previously validated public key stored in a slot. </p>
<p>This command can only be run after GenKey has been used to create a PubKey digest of the public key to be invalidated in TempKey (mode=0x10).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be invalidated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>19 bytes of data used to build the verification message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, validation public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="ga7c18378e7e634aef3f7cd5124b172f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c18378e7e634aef3f7cd5124b172f1e">&#9670;&nbsp;</a></span>calib_verify_stored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_verify_stored </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command, which verifies a signature (ECDSA verify operation) with a public key stored in the device. The message to be signed will be loaded into the Message Digest Buffer to the ATECC608A device or TempKey for other devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be used in the verification. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="ga93620b7a951daa744e1c47dff7af2f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93620b7a951daa744e1c47dff7af2f5a">&#9670;&nbsp;</a></span>calib_verify_stored_mac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_verify_stored_mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>num_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>io_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command with verification MAC, which verifies a signature (ECDSA verify operation) with a public key stored in the device. This function is only available on the ATECC608A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>32 byte message to be verified. Typically the SHA256 hash of the full message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be used in the verification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_in</td><td>System nonce (32 byte) used for the verification MAC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">io_key</td><td>IO protection key for verifying the validation MAC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="ga0e0e60a885d0a4910d273d2b820f74ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e0e60a885d0a4910d273d2b820f74ce">&#9670;&nbsp;</a></span>calib_verify_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_verify_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>other_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_verified</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Verify command in Validate mode to validate a public key stored in a slot. </p>
<p>This command can only be run after GenKey has been used to create a PubKey digest of the public key to be validated in TempKey (mode=0x10).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key_id</td><td>Slot containing the public key to be validated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Signature to be verified. R and S integers in big-endian format. 64 bytes for P256 curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_data</td><td>19 bytes of data used to build the verification message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_verified</td><td>Boolean whether or not the message, signature, validation public key verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on verification success or failure, because the command still completed successfully. </dd></dl>

</div>
</div>
<a id="gafbc037d57a4cc4fec6a2f291736170cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbc037d57a4cc4fec6a2f291736170cb">&#9670;&nbsp;</a></span>calib_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_wakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>basic API methods are all prefixed with atcab_ (CryptoAuthLib Basic) the fundamental premise of the basic API is it is based on a single interface instance and that instance is global, so all basic API commands assume that one global device is the one to operate on. </p>
<p>wakeup the CryptoAuth device </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga4791634e3df2b2a2746fec15b3c036cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4791634e3df2b2a2746fec15b3c036cb">&#9670;&nbsp;</a></span>calib_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>mac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes either one four byte word or a 32-byte block to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. This command cannot be used to write slots configured as ECC private keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone/Param1 for the write command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address/Param2 for the write command. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Plain-text data to be written or cipher-text for encrypted writes. 32 or 4 bytes depending on bit 7 in the zone. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mac</td><td>MAC required for encrypted writes (32 bytes). Set to NULL if not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga39bfa045068f0a9d2badf844862df2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39bfa045068f0a9d2badf844862df2f2">&#9670;&nbsp;</a></span>calib_write_bytes_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_write_bytes_zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes data into the configuration, otp, or data zones with a given byte offset and length. Offset and length must be multiples of a word (4 bytes). </p>
<p>Config zone must be unlocked for writes to that zone. If data zone is unlocked, only 32-byte writes are allowed to slots and OTP and the offset and length must be multiples of 32 or the write will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Zone to write data to: <a class="el" href="a00386.html#add3796a1d4de55604283aef5a70f7945">ATCA_ZONE_CONFIG(0)</a>, <a class="el" href="a00386.html#a547efc6fa3cb0501b2e53f80023dff7e">ATCA_ZONE_OTP(1)</a>, or <a class="el" href="a00386.html#a4c65b241280290fae9fd4faa9d7a292b">ATCA_ZONE_DATA(2)</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If zone is <a class="el" href="a00386.html#a4c65b241280290fae9fd4faa9d7a292b">ATCA_ZONE_DATA(2)</a>, the slot number to write to. Ignored for all other zones. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset_bytes</td><td>Byte offset within the zone to write to. Must be a multiple of a word (4 bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to be written. Must be a multiple of a word (4 bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gaa5238e0fac86dcb164f3c79d42e97976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5238e0fac86dcb164f3c79d42e97976">&#9670;&nbsp;</a></span>calib_write_config_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_write_config_counter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>counter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counter_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize one of the monotonic counters in device with a specific value. </p>
<p>The monotonic counters are stored in the configuration zone using a special format. This encodes a binary count value into the 8 byte encoded value required. Can only be set while the configuration zone is unlocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_id</td><td>Counter to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter_value</td><td>Counter value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga81f049d53107034808416e8f09e927f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81f049d53107034808416e8f09e927f3">&#9670;&nbsp;</a></span>calib_write_config_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_write_config_zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>config_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes the configuration zone. </p>
<p>First 16 bytes are skipped as they are not writable. LockValue and LockConfig are also skipped and can only be changed via the Lock command.</p>
<p>This command may fail if UserExtra and/or Selector bytes have already been set to non-zero values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config_data</td><td>Data to the config zone data. This should be 88 bytes for SHA devices and 128 bytes for ECC devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ga8fc342d4ebd76c4affd7abc7a1cac2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fc342d4ebd76c4affd7abc7a1cac2aa">&#9670;&nbsp;</a></span>calib_write_enc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_write_enc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>enc_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>enc_key_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>num_in</em>[(20)]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4408e08f86cd3bd48868ffaa0e966b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4408e08f86cd3bd48868ffaa0e966b09">&#9670;&nbsp;</a></span>calib_write_pubkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_write_pubkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the write command to write a public key to a slot in the proper format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>Slot number to write. Only slots 8 to 15 are large enough to store a public key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">public_key</td><td>Public key to write into the slot specified. X and Y integers in big-endian format. 64 bytes for P256 curve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="gac5046bb4ec9b6f7747b70ae9fb8a5922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5046bb4ec9b6f7747b70ae9fb8a5922">&#9670;&nbsp;</a></span>calib_write_zone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00191.html#a22bd6643f31f1d75dc3e7ea939f468cd">ATCA_STATUS</a> calib_write_zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01585.html#gaa94f7bb4af0a3d6735225cc85d92cb50">ATCADevice</a>&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Write command, which writes either 4 or 32 bytes of data into a device zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Device context pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zone</td><td>Device zone to write to (0=config, 1=OTP, 2=data). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>If writing to the data zone, it is the slot to write to, otherwise it should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>32-byte block to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>4-byte word within the specified block to write to. If performing a 32-byte write, this should be 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to be written. Must be either 4 or 32.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ATCA_SUCCESS on success, otherwise an error code. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaa5990c6c2a55759960d25a1f8ad1973d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5990c6c2a55759960d25a1f8ad1973d">&#9670;&nbsp;</a></span>atca_basic_aes_gcm_version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* atca_basic_aes_gcm_version = &quot;2.0&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
